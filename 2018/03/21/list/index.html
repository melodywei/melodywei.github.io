<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="简述在前面我们看了vector的实现之后相信对容器有了一定的认识。容器即为存放物件之所，它代表着一块空间。想要直观的了解一个容器，那么看懂他的空间分配策略是一个非常有效的入手方式。接下来我们就来看看STL中的list又是如何实现的吧。 list的结构list就是我们常说的链表，说到链表相信大家就很熟悉了。非连续空间、通过指针来连接每一个小空间、插入和删除都是O(1)操作，元素访问效率较低等等。。。">
<meta property="og:type" content="article">
<meta property="og:title" content="从零开始，打造自己的STL(四、list)">
<meta property="og:url" content="https://modifying.github.io/2018/03/21/list/index.html">
<meta property="og:site_name" content="melodyのblog">
<meta property="og:description" content="简述在前面我们看了vector的实现之后相信对容器有了一定的认识。容器即为存放物件之所，它代表着一块空间。想要直观的了解一个容器，那么看懂他的空间分配策略是一个非常有效的入手方式。接下来我们就来看看STL中的list又是如何实现的吧。 list的结构list就是我们常说的链表，说到链表相信大家就很熟悉了。非连续空间、通过指针来连接每一个小空间、插入和删除都是O(1)操作，元素访问效率较低等等。。。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180320/0l3c8cHk2m.png?imageslim">
<meta property="og:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180320/CieBhFe8CB.png?imageslim">
<meta property="og:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180320/Ce4Jc17DkH.png?imageslim">
<meta property="og:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180321/386cke12gG.png?imageslim">
<meta property="og:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180321/Fglfi2IeE9.png?imageslim">
<meta property="og:updated_time" content="2018-12-08T16:24:57.685Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从零开始，打造自己的STL(四、list)">
<meta name="twitter:description" content="简述在前面我们看了vector的实现之后相信对容器有了一定的认识。容器即为存放物件之所，它代表着一块空间。想要直观的了解一个容器，那么看懂他的空间分配策略是一个非常有效的入手方式。接下来我们就来看看STL中的list又是如何实现的吧。 list的结构list就是我们常说的链表，说到链表相信大家就很熟悉了。非连续空间、通过指针来连接每一个小空间、插入和删除都是O(1)操作，元素访问效率较低等等。。。">
<meta name="twitter:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180320/0l3c8cHk2m.png?imageslim">






  <link rel="canonical" href="https://modifying.github.io/2018/03/21/list/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>从零开始，打造自己的STL(四、list) | melodyのblog</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-131168677-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-131168677-1');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2fa2044c78f4a75b300904570ea19f8f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">melodyのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://modifying.github.io/2018/03/21/list/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从零开始，打造自己的STL(四、list)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-21 22:30:00" itemprop="dateCreated datePublished" datetime="2018-03-21T22:30:00+08:00">2018-03-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-09 00:24:57" itemprop="dateModified" datetime="2018-12-09T00:24:57+08:00">2018-12-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在前面我们看了vector的实现之后相信对容器有了一定的认识。容器即为存放物件之所，它代表着一块空间。想要直观的了解一个容器，那么看懂他的空间分配策略是一个非常有效的入手方式。接下来我们就来看看STL中的list又是如何实现的吧。</p>
<h1 id="list的结构"><a href="#list的结构" class="headerlink" title="list的结构"></a>list的结构</h1><p>list就是我们常说的链表，说到链表相信大家就很熟悉了。非连续空间、通过指针来连接每一个小空间、插入和删除都是O(1)操作，元素访问效率较低等等。。。<br>list采用的结构是双端环形链表，用下面一幅图来形象的表达</p>
<p><img src="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180320/0l3c8cHk2m.png?imageslim" alt="双端环形链表结构"></p>
<p>咳咳，虽然图是丑了点，确也是可以直观的看出它的结构的。图中红色的方框就代表着一块空间，在这块空间中存放了三个东西，第一个东西是下一块空间所在的位置，也就是next指针所指向的位置。第二个是上一块空间所在的位置。第三个就是存放的数据呐。其中有一个特殊的是有一块 <strong>head</strong> 的区域，有人会想这块区域显然就是标识我大链表的头部了。其实它既是链表头，也是链表尾。看一下下面对链表的遍历操作你很块就能理解了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (auto i = head-&gt;next; i != head; ++it)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="list的空间配置"><a href="#list的空间配置" class="headerlink" title="list的空间配置"></a>list的空间配置</h1><p>list的空间配置呢相对vector就要复杂一点点，vector的空间是一整块一整块分配的，当这一块空间不足够存放我的数据的时候，就重新分配一块*2大小的空间，再将原来的数据搬过来。说了这么多就是想找个对比，没有对比就没有伤害嘛</p>
<p>list是一小块一小块的节点空间，那么每次新增一个节点的时候就要分配一块空间供我们使用。分配多大呢？看一下list的节点的结构就知道那</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _List_node_base</span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base *_m_next;</span><br><span class="line">	_List_node_base *_m_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename _Tp&gt;</span><br><span class="line">struct _List_node : public _List_node_base</span><br><span class="line">&#123;</span><br><span class="line">	_Tp _m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大家看到这个节点的结构的时候有没有感觉到有一点点奇怪，为什么有两个结构体？</p>
<p>在SGI的STL实现中呢，将list的节点分为了指针域和数据域。为什么要这么划分，当然是有它的好处的。</p>
<p>我们对list的操作中更多的是对节点进行遍历，而访问数据成员总是在我们找到了某个节点的时候。那我们在遍历操作中只存放节点的指针域，而不存放数据是不是很大的节省了空间呢，特别是对于c++来说，这个数据域大多都是我们自定义的类，而一个类所占用的空间可能会很大，不像指针，在32位下一个指针才4bytes</p>
<p>看懂了节点的结构之后，那么它的空间分配也就显而易见了，即每次分配<strong>sizeof(_List_node&lt;_Tp&gt;)</strong> 大小的空间即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">class _List_base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef _Alloc allocator_type;</span><br><span class="line"></span><br><span class="line">	_List_base()</span><br><span class="line">	&#123;</span><br><span class="line">		_m_head = _M_get_node();</span><br><span class="line">		_m_head-&gt;_m_next = _m_head;</span><br><span class="line">		_m_head-&gt;_m_prev = _m_head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~_List_base()</span><br><span class="line">	&#123;</span><br><span class="line">		clear();</span><br><span class="line">		_M_put_node(_m_head);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void clear();</span><br><span class="line">protected:</span><br><span class="line">	typedef simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;</span><br><span class="line"></span><br><span class="line">	_List_node&lt;_Tp&gt; * _M_get_node() // 分配节点空间</span><br><span class="line">	&#123;</span><br><span class="line">		return _Alloc_type::allocate(1);</span><br><span class="line">	&#125;</span><br><span class="line">	void _M_put_node(_List_node&lt;_Tp&gt; *_p) // 释放节点空间</span><br><span class="line">	&#123;</span><br><span class="line">		_Alloc_type::deallocate(_p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_List_node&lt;_Tp&gt;* _m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码还是比较简单的，_List_base类主要就负责head节点的初始化工作。需要注意的就是传递给分配器的模板参数是 **_List_node&lt;_Tp&gt;，该类型作为simple_alloc的_Tp参数</p>
<p><img src="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180320/CieBhFe8CB.png?imageslim" alt="simple_alloc"></p>
<h1 id="list的元素访问"><a href="#list的元素访问" class="headerlink" title="list的元素访问"></a>list的元素访问</h1><p>明白了list的内存布局之后，我们在看看list的迭代器，看看迭代器是如何实现对其进行元素访问的。</p>
<p>话不多说，先上代码，从源码中见分晓<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct _List_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base* _m_node;</span><br><span class="line"></span><br><span class="line">	_List_iterator_base(_List_node_base *_x) :_m_node(_x)&#123;&#125;</span><br><span class="line">	_List_iterator_base():_m_node(nullptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	void _M_incr() </span><br><span class="line">	&#123;</span><br><span class="line">		_m_node = _m_node-&gt;_m_next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void _M_decr() </span><br><span class="line">	&#123;</span><br><span class="line">		_m_node = _m_node-&gt;_m_prev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator==(const _List_iterator_base &amp;_x)const</span><br><span class="line">	&#123;</span><br><span class="line">		return _m_node == _x._m_node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator!=(const _List_iterator_base &amp;_x)const</span><br><span class="line">	&#123;</span><br><span class="line">		return _m_node != _x._m_node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看到第一行的_m_node相信大家应该明白了之前所说的为什么将节点的指针域和数据域分开的原因了吧，在迭代器中只需要指针域，因为迭代器的工作就是访问节点，而不是数据</p>
<p>iteartor的基类做的工作很简单</p>
<ol>
<li>初始化当前节点</li>
<li>提供访问当前节点的相邻节点的接口</li>
<li>提供节点比较的方法</li>
</ol>
<p>有了基类提供的接口之后，迭代器的实现也就很简单了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Ref, typename _Ptr&gt;</span><br><span class="line">struct _List_iterator : public _List_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef _List_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;	iterator;</span><br><span class="line">	typedef _List_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt;	const_iterator;</span><br><span class="line">	typedef _List_iterator&lt;_Tp, _Ref, _Ptr&gt;	_Self;</span><br><span class="line"></span><br><span class="line">	typedef _Tp value_type;</span><br><span class="line">	typedef _Ptr pointer;</span><br><span class="line">	typedef _Ref reference;</span><br><span class="line">	typedef _List_node&lt;_Tp&gt; _Node;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	_List_iterator(_Node *_x): _List_iterator_base(_x)&#123;&#125;</span><br><span class="line">	_List_iterator()&#123;&#125;</span><br><span class="line">	_List_iterator(const iterator&amp; _x):_List_iterator_base(_x._m_node)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	reference operator*()const </span><br><span class="line">	&#123;</span><br><span class="line">		return ((_Node*)_m_node)-&gt;_m_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pointer operator-&gt;()const</span><br><span class="line">	&#123;</span><br><span class="line">		return &amp;(operator*());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Self&amp; operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;_M_incr();</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Self operator++(int)</span><br><span class="line">	&#123;</span><br><span class="line">		_Self _tmp = *this;</span><br><span class="line">		this-&gt;_M_incr();</span><br><span class="line">		return _tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Self &amp;operator--()</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;_M_decr();</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	_Self operator--(int)</span><br><span class="line">	&#123;</span><br><span class="line">		_Self _tmp = *this;</span><br><span class="line">		this-&gt;_M_decr();</span><br><span class="line">		return _tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在前面定义了一些类型的别名，iterator真正提供的接口就是访问下一个节点(operator++), 访问前一个节点(operator–)以及访问当前节点的数据(operator*)</p>
<p>前期的准备工作都做好了，可以开始看list的具体实现了</p>
<h1 id="list的具体实现"><a href="#list的具体实现" class="headerlink" title="list的具体实现"></a>list的具体实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc = alloc &gt;</span><br><span class="line">class list : protected _List_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">	typedef _List_base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class="line">public:</span><br><span class="line">	typedef _Tp	value_type;</span><br><span class="line">	typedef _Tp* pointer;</span><br><span class="line">	typedef const _Tp*	const_point;</span><br><span class="line">	typedef _Tp&amp;	reference;</span><br><span class="line">	typedef const _Tp&amp;	const_reference;</span><br><span class="line">	typedef  _List_node&lt;_Tp&gt; _Node;</span><br><span class="line">	typedef size_t	size_type;</span><br><span class="line">	typedef ptrdiff_t	difference_type;</span><br><span class="line">	</span><br><span class="line">	typedef _List_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;	iterator;</span><br><span class="line">	typedef _List_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">	typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">	typedef reverse_iterator&lt;iterator&gt;     reverse_iterator;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">	using _Base::_M_put_node;</span><br><span class="line">	using _Base::_M_get_node;</span><br><span class="line">	using _Base::_m_head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些都是一些别名的定义以及对基类成员和函数的引用，基类的代码在上面有贴出，忘记了的同学可以翻上去看一下</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">list() : _Base()&#123;&#125;</span><br><span class="line"></span><br><span class="line">list(size_type _n, const_reference _value):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _n, _value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(size_type _n):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _n, _Tp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(const_point _first, const_point _last)):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _first, _last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(const_iterator _first, const_iterator _last):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _first, _last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(const list&lt;_Tp, _Alloc&gt; &amp;_x):_Base())</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _x.begin(), _x.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别看构造函数好像都与insert函数有关，然后跑去看insert，结果被其吓倒了，其实构造函数无非就做了两件事</p>
<ol>
<li>通过基类初始化head节点</li>
<li>将传递进来的数据插入到list中</li>
</ol>
<p>只是我们提供的构造数据的方式多种多样，就显得比较负责而已，等到后面我们在来了解它到底是如何进行花式插入的</p>
<h2 id="成员访问函数"><a href="#成员访问函数" class="headerlink" title="成员访问函数"></a>成员访问函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">iterator begin()</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head-&gt;_m_next;</span><br><span class="line">&#125;</span><br><span class="line">const_iterator begin()const</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head-&gt;_m_next;</span><br><span class="line">&#125;</span><br><span class="line">iterator end()</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head;</span><br><span class="line">&#125;</span><br><span class="line">const_iterator end()const</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse_iterator rbegin()</span><br><span class="line">&#123;</span><br><span class="line">	return reverse_iterator(end());</span><br><span class="line">&#125;</span><br><span class="line">const_reverse_iterator rbegin() const</span><br><span class="line">&#123;</span><br><span class="line">	return const_reverse_iterator(end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse_iterator rend()</span><br><span class="line">&#123;</span><br><span class="line">	return reverse_iterator(begin());</span><br><span class="line">&#125;</span><br><span class="line">const_reverse_iterator rend() const</span><br><span class="line">&#123;</span><br><span class="line">	return const_reverse_iterator(begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool empty()const</span><br><span class="line">&#123;</span><br><span class="line">	return _m_head == _m_head-&gt;_m_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_type size()</span><br><span class="line">&#123;</span><br><span class="line">	size_type _result = 0;</span><br><span class="line">	distance(begin(), end(), _result);</span><br><span class="line">	return _result;</span><br><span class="line">&#125;</span><br><span class="line">size_type max_size()const</span><br><span class="line">&#123;</span><br><span class="line">	return (size_type)(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reference front()</span><br><span class="line">&#123;</span><br><span class="line">	return *begin();</span><br><span class="line">&#125;</span><br><span class="line">const_reference front()const</span><br><span class="line">&#123;</span><br><span class="line">	return *begin();</span><br><span class="line">&#125;</span><br><span class="line">reference back()</span><br><span class="line">&#123;</span><br><span class="line">	return *(--end());</span><br><span class="line">&#125;</span><br><span class="line">const_reference back()const</span><br><span class="line">&#123;</span><br><span class="line">	return *(--end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些统一的接口相信大家一看就懂了。我还是在这里多说几句。reverse_iterator是反向迭代器，意思就是将迭代器的访问顺序反着来，本来我们是从头访问到尾，而它正好相反，这个将在后面来实现，在size()中的distance()函数大家可以这样理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto it = begin(); it != end(); ++it)</span><br><span class="line">	++result;</span><br></pre></td></tr></table></figure></p>
<p>它只是为了提供一个统一的接口供不同的迭代器调用。对于list这样的不能随机访问的迭代器来说就要通过遍历来知道它的size有多大，而对于像vector这样的随机访问迭代器来说，直接end()-begin()就知道了它的size，它的作用就是统一接口，针对不同的迭代器采取不同的策略</p>
<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>insert是list中比较重要的一部分了，list就是为了插入删除操作而生的。我们来好好了解一下到底是如何进行花式insert的吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在pos处插入值x</span><br><span class="line">iterator insert(iterator _pos, const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	_Node *_tmp = _M_create_node(_x);</span><br><span class="line">	_tmp-&gt;_m_next = _pos._m_node;</span><br><span class="line">	_tmp-&gt;_m_prev = _pos._m_node-&gt;_m_prev;</span><br><span class="line">	_pos._m_node-&gt;_m_prev-&gt;_m_next = _tmp;</span><br><span class="line">	_pos._m_node-&gt;_m_prev = _tmp;</span><br><span class="line">	return _tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个很关键，还是画一幅图好好理解一下，因为后面的插入操作无非也就是在pos出插入多个值而已，咳，又到了展现画工的时候了，还真是激动。</p>
<p><img src="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180320/Ce4Jc17DkH.png?imageslim" alt="insert1"></p>
<p>好了，这就是初始状态，为了方便，就不画成环形了，大家知道就好<br>接下来分两步走<br>1.改变tmp指针域的指向</p>
<p><img src="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180321/386cke12gG.png?imageslim" alt="insert2"></p>
<p>2.改变pos指针域的指向</p>
<p><img src="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180321/Fglfi2IeE9.png?imageslim" alt="insert3"></p>
<p>红色代表被删除了，蓝色代表新加入的。这样新节点就成功加入到了pos前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iterator insert(iterator _pos)</span><br><span class="line">&#123;</span><br><span class="line">	return insert(_pos, _Tp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(iterator _pos, const_point _first, const_point _last)</span><br><span class="line">&#123;</span><br><span class="line">	for (; _first != _last; ++_first)</span><br><span class="line">		insert(_pos, *_first);</span><br><span class="line">&#125;</span><br><span class="line">void insert(iterator _pos, const_iterator _first, const_iterator _last)</span><br><span class="line">&#123;</span><br><span class="line">	for (; _first != _last; ++_first)</span><br><span class="line">		insert(_pos, *_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(iterator _pos, size_type _n, const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	for (; _n &gt; 0; --_n)</span><br><span class="line">		insert(_pos, _x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，剩下的插入操作都是调用的第一个接口。</p>
<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iterator erase(iterator _pos)</span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base *_next_node = _pos._m_node-&gt;_m_next;</span><br><span class="line">	_List_node_base *_prev_node = _pos._m_node-&gt;_m_prev;</span><br><span class="line">	_Node *_tmp = (_Node*)_pos._m_node;</span><br><span class="line">	_prev_node-&gt;_m_next = _next_node;</span><br><span class="line">	_next_node-&gt;_m_next = _prev_node;</span><br><span class="line">	destroy(&amp;_tmp-&gt;_m_data);</span><br><span class="line">	_M_put_node(_tmp);</span><br><span class="line">	return iterator((_Node*)_next_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作看代码应该很好理解，将pos的前一个节点的next指针指向pos的下一个节点，pos的后一个节点的prev指针指向pos的前一个节点</p>
<h2 id="push-amp-amp-pop"><a href="#push-amp-amp-pop" class="headerlink" title="push &amp;&amp; pop"></a>push &amp;&amp; pop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void push_front(const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _x);</span><br><span class="line">&#125;</span><br><span class="line">void push_front()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin());</span><br><span class="line">&#125;</span><br><span class="line">void push_back(const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	insert(end(), _x);</span><br><span class="line">&#125;</span><br><span class="line">void push_back()</span><br><span class="line">&#123;</span><br><span class="line">	insert(end());</span><br><span class="line">&#125;</span><br><span class="line">void pop_front()</span><br><span class="line">&#123;</span><br><span class="line">	erase(begin());</span><br><span class="line">&#125;</span><br><span class="line">void pop_back()</span><br><span class="line">&#123;</span><br><span class="line">	erase(--end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了insert和erase做接口，push和pop直接调用即可</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/20/alloc/" rel="next" title="从零开始，打造自己的STL(三、alloc)">
                <i class="fa fa-chevron-left"></i> 从零开始，打造自己的STL(三、alloc)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/29/deque/" rel="prev" title="从零开始，打造自己的STL(五、deque)">
                从零开始，打造自己的STL(五、deque) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="melody">
            
              <p class="site-author-name" itemprop="name">melody</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">37</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/melodywei" title="GitHub &rarr; https://github.com/melodywei" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:melodywei97@gmail.com" title="E-Mail &rarr; mailto:melodywei97@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list的结构"><span class="nav-number">2.</span> <span class="nav-text">list的结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list的空间配置"><span class="nav-number">3.</span> <span class="nav-text">list的空间配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list的元素访问"><span class="nav-number">4.</span> <span class="nav-text">list的元素访问</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list的具体实现"><span class="nav-number">5.</span> <span class="nav-text">list的具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">5.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员访问函数"><span class="nav-number">5.2.</span> <span class="nav-text">成员访问函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#insert"><span class="nav-number">5.3.</span> <span class="nav-text">insert</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#erase"><span class="nav-number">5.4.</span> <span class="nav-text">erase</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#push-amp-amp-pop"><span class="nav-number">5.5.</span> <span class="nav-text">push &amp;&amp; pop</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">melody</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
