<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="进程同步看一下上一节写的调用外部shell的方法。 1234567891011121314151617181920memset(final_path, 0, sizeof(final_path));int32_t pid = fork();if (pid)&amp;#123;     while(1);&amp;#125;else&amp;#123;    make_clear_abs_path(argv[0], fin">
<meta property="og:type" content="article">
<meta property="og:title" content="二十三. 进程同步与进程间通信">
<meta property="og:url" content="https://modifying.github.io/2018/05/18/pipe/index.html">
<meta property="og:site_name" content="melodyのblog">
<meta property="og:description" content="进程同步看一下上一节写的调用外部shell的方法。 1234567891011121314151617181920memset(final_path, 0, sizeof(final_path));int32_t pid = fork();if (pid)&amp;#123;     while(1);&amp;#125;else&amp;#123;    make_clear_abs_path(argv[0], fin">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180518/9FC1HDLEHL.png?imageslim">
<meta property="og:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180518/FK0E7lbl8F.png?imageslim">
<meta property="og:updated_time" content="2018-12-08T16:22:30.786Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="二十三. 进程同步与进程间通信">
<meta name="twitter:description" content="进程同步看一下上一节写的调用外部shell的方法。 1234567891011121314151617181920memset(final_path, 0, sizeof(final_path));int32_t pid = fork();if (pid)&amp;#123;     while(1);&amp;#125;else&amp;#123;    make_clear_abs_path(argv[0], fin">
<meta name="twitter:image" content="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180518/9FC1HDLEHL.png?imageslim">






  <link rel="canonical" href="https://modifying.github.io/2018/05/18/pipe/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>二十三. 进程同步与进程间通信 | melodyのblog</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2fa2044c78f4a75b300904570ea19f8f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">melodyのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://modifying.github.io/2018/05/18/pipe/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">二十三. 进程同步与进程间通信
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-18 22:30:00" itemprop="dateCreated datePublished" datetime="2018-05-18T22:30:00+08:00">2018-05-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-09 00:22:30" itemprop="dateModified" datetime="2018-12-09T00:22:30+08:00">2018-12-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p>看一下上一节写的调用外部shell的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(final_path, <span class="number">0</span>, <span class="keyword">sizeof</span>(final_path));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    make_clear_abs_path(argv[<span class="number">0</span>], final_path);</span><br><span class="line">    argv[<span class="number">0</span>] = final_path;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">0</span>], &amp;file_stat) ！= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execv(argv[<span class="number">0</span>], argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是shell fork出一个子进程，通过该子进程调用exec将当前进程替换为要执行的外部命令。此时在父进程的执行代码处，我们用了一个死循环将其简单的阻塞在此，那么为什么这里父进程要阻塞自己。</p>
<p>在fork的原理说过，fork出来的子进程会完全复制父进程的所有资源，包括父进程的堆栈环境等等。在这一段代码中，fork出的子进程会使用到复制过来的栈中的数据，如final_path。如果fork还没有执行完，也就是说子进程还没有完全复制父进程的堆栈环境，而父进程在此时改变了它栈中的数据，那么此时子进程复制的数据可能就不是它想要的数据。此时便需要父进程阻塞起来，让子进程先执行，这就是需要进行进程同步的地方。</p>
<h2 id="wait和exit"><a href="#wait和exit" class="headerlink" title="wait和exit"></a>wait和exit</h2><p>这一节将会通过wait和exit来实现进程的同步，首先来理解一下wait和exit是来干什么的。</p>
<p>wait的作用是让一个进程阻塞自己，直到他的某一个子进程退出。所以说，wait通常由父进程来调用。当一个进程调用wait的时候，内核便会去查找该进程的子进程，如果没有子进程，此时wait会返回-1，否则，该进程便会被阻塞，此时内核就会去遍历它的所有子进程，查找是否有子进程退出，如果有子进程退出便将该子进程的返回值传递给父进程，随后将父进程唤醒。</p>
<p>exit的作用就如其名字一样，让进程退出，结束执行。</p>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>在wait和exit的调用中会产生两个非常有意思的概念，孤儿进程和僵尸进程。</p>
<p>前面介绍wait的时候也说了，wait的一个作用是阻塞父进程自己，使父子进程同步，它的另一个作用是获取子进程的退出状态，也就是取得子进程的退出时的返回值。这个返回值就是平常在main函数中写的return 0，这个0就代表这个进程的退出状态。</p>
<p>当子进程执行完main函数之后，程序的执行流程会返回到c运行库之中(这个是之前所介绍的，main函数只是程序执行流程中的中间部分，它是由c运行库调用通过call指令调用的，执行完了之后会返回)。c运行库会把进程return的返回值通过系统调用exit提交给内核。</p>
<p>下面来解释一下什么是孤儿进程和僵尸进程</p>
<p>如果一个子进程运行结束了，它的父进程没有调用wait，这个子进程就变成了僵尸进程。</p>
<p>如果子进程还在运行，而他的父进程已经退出了，这个子进程就变了孤儿进程。</p>
<p>上面是僵尸进程和孤儿进程的基本概念，接下来从内核层理解一下为什么会出现僵尸进程和孤儿进程。</p>
<p>在进程退出的时候，无论如果他都会调用exit，不管是这个进程主动调用exit退出，还是执行完了之后进入c运行库调用exit。exit会得到一个退出状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是exit的函数原型，status就是传递进去的退出状态，那么这个退出状态要存储在什么地方呢。又如何将这个退出状态传给父进程呢。</p>
<p>由于进程都是自己独立的地址空间，即使是父子之前，他们也是相互独立不可互相访问的，进程间想要通信必须要借助内核，子进程的返回值肯定要先提交给内核，然后父进程向内核要子进程的返回值，父进程如何向内核要子进程的返回值呢，看一下wait函数的原型就知道了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br></pre></td></tr></table></figure></p>
<p>status是父进程用来存储子进程返回值的地址，父进程调用它后，内核就会它子进程的返回值存储到status指向的内存空间中。</p>
<p>接下来说一下子进程的返回值到底存储在什么地方。在操作系统中，为了方便管理，进程相关的数据都统一放在pcb中，当进程结束时，它的返回值会被内核放到进程的pcb中。由于此时进程已经执行完了，内核会把进程占用的大部分资源回收，比如内存，页表等，但是进程的pcb所占的内存还不能回收，因为里面存储着进程的返回值，就像是临终遗言一样，还没有交出去，需要交付给父进程之后才能被回收。它应该在父进程调用wait获取子进程的返回值后，再由内核回收子进程pcb所占用的页框。</p>
<p>说到这里，相信僵尸进程就很好理解了，因为子进程结束了，父进程没有调用wait，导致子进程的pcb无法被内核回收，而导致内核空间被浪费。如果系统中存在大量的僵尸进程，还可能导致无法启动新的进程，毕竟内核的空间总是有限的。</p>
<p>孤儿进程相对来说好理解一点，父进程退出了，子进程还没有调用exit，此时子进程便成了孤儿进程。因为没有父进程再来获取该子进程的退出状态了嘛。但是在linux的处理策略中，孤儿进程会被init进程收养，也就是说，init进程会成为这些进程的父进程，子进程退出的时候就有init进程来为其”收尸”罗。这其实是一种顺理成章的处理策略，因为init进程本身就是所有进程的父进程。</p>
<p>概念上差不多就这些，接下来看一下实现</p>
<p>wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等待子进程调用exit,将子进程的退出状态保存到status指向的变量.</span></span><br><span class="line"><span class="comment"> * 成功则返回子进程的pid,失败则返回-1 */</span></span><br><span class="line"><span class="keyword">pid_t</span> sys_wait(<span class="keyword">int32_t</span> *status)</span><br><span class="line">&#123;</span><br><span class="line">    task_struct *parent_thread = running_thread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 优先处理已经是挂起状态的任务 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">child_elem</span> = <span class="title">list_traversal</span>(&amp;<span class="title">thread_all_list</span>, <span class="title">find_hanging_child</span>, <span class="title">parent_thread</span>-&gt;<span class="title">pid</span>);</span></span><br><span class="line">        <span class="comment">/* 若有挂起的子进程 */</span></span><br><span class="line">        <span class="keyword">if</span> (child_elem != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            task_struct *child_thread = elem2entry(task_struct, all_list_tag, child_elem);</span><br><span class="line">            *status = child_thread-&gt;exit_status;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* thread_exit之后,pcb会被回收,因此提前获取pid */</span></span><br><span class="line">            <span class="keyword">uint16_t</span> child_pid = child_thread-&gt;pid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 2 从就绪队列和全部队列中删除进程表项*/</span></span><br><span class="line">            thread_exit(child_thread, <span class="literal">false</span>); <span class="comment">// 传入false,使thread_exit调用后回到此处</span></span><br><span class="line">            <span class="comment">/* 进程表项是进程或线程的最后保留的资源, 至此该进程彻底消失了 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> child_pid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断是否有子进程 */</span></span><br><span class="line">        child_elem = list_traversal(&amp;thread_all_list, find_child, parent_thread-&gt;pid);</span><br><span class="line">        <span class="keyword">if</span> (child_elem == <span class="literal">NULL</span>)</span><br><span class="line">        &#123; <span class="comment">// 若没有子进程则出错返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 若子进程还未运行完,即还未调用exit,则将自己挂起,直到子进程在执行exit时将自己唤醒 */</span></span><br><span class="line">            thread_block(TASK_WAITING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>exit<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子进程用来结束自己时调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">int32_t</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_struct *child_thread = running_thread();</span><br><span class="line">    child_thread-&gt;exit_status = status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将进程child_thread的所有子进程都过继给init */</span></span><br><span class="line">    list_traversal(&amp;thread_all_list, init_adopt_a_child, child_thread-&gt;pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 回收进程child_thread的资源 */</span></span><br><span class="line">    release_prog_resource(child_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果父进程正在等待子进程退出,将父进程唤醒 */</span></span><br><span class="line">    task_struct *parent_thread = pid2thread(child_thread-&gt;parent_pid);</span><br><span class="line">    <span class="keyword">if</span> (parent_thread-&gt;status == TASK_WAITING)</span><br><span class="line">    &#123;</span><br><span class="line">        thread_unblock(parent_thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将自己挂起,等待父进程获取其status,并回收其pcb */</span></span><br><span class="line">    thread_block(TASK_HANGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><h2 id="管道的原理"><a href="#管道的原理" class="headerlink" title="管道的原理"></a>管道的原理</h2><p>进程虽然是独立运行的个体，但他们之间有时候也需要协作才能完成一些工作，比如有两个进程需要同步数据，进程A把数据准备好后，想把数据发往进程B，进程B必须被提前通知有数据到来。这些需求很多，所以操作系统必须要实现进程间的相互通信。</p>
<p>进程间通信的方式有很多种，有消息队列，共享内存，socket通信，管道等。在这里kernel中就打算实现管道。而且管道命令在linux的shell中使用可以说是非常频繁的。</p>
<p>管道是文件的一种，(操作系统上文件是一个非常大的概念，像管道，socket，设备等都归属于文件的概念中)只是该文件并不存在与文件系统上，它只存在于内存中。既然管道是属于文件的一种，就要按照文件操作的方式来使用，通过open，close，read，write来使用管道，这应该是约定的一种规范吧。</p>
<p>管道是数据的一个中转站，当某个进程往管道中写入数据后，该数据就会被另一个进程读取，之后用新的数据覆盖旧数据，既然是一块数据缓存区，就应该有一个大小。但是由于写入的数据大小是不确定的，这块缓存区的大小很难确定下来，一般来说会使用环形缓存区来存储数据，通过生产者消费者模型对这块环形缓冲区的数据进行读写。这个环形缓冲区用两个指针来维护，一个专门负责读，一个专门负责写，当缓冲区数据满时，生产者睡眠并唤醒消费者。缓冲区空时，消费者睡眠，唤醒生产者。</p>
<p>管道有两端，一端用来读，一端用来写。这个两端的概念实质上是内核为一个管道分配了两个文件描述符，一个负责写，一个负责读。它的模型如下图<br><img src="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180518/9FC1HDLEHL.png?imageslim" alt=""><br>当然，管道创建出来后，自己写自己读是没有意义的。所以通常的走法是创建一个管道后，fork一个子进程，这个子进程会继承当前进程的所有资源，当然也就包括他打开的管道啦。所以父子进程都能通过管道描述符向管道中读写数据。</p>
<p>管道分为两种，匿名管道和命名管道。匿名管道是创建之后只能通过文件描述符来访问的，此管道只对创建它的进程和其子进程可见，其他进程是访问不到的。命名管道就是可以通过其名称，找到该管道的文件描述符，对所有进程都可见。</p>
<h2 id="linux中管道的设计"><a href="#linux中管道的设计" class="headerlink" title="linux中管道的设计"></a>linux中管道的设计</h2><p>linux支持的文件系统比较多，包括ext2，ext3，ext4，ntfs等。为了提供统一的接口，linux加了一层中间层VFS(虚拟文件系统)。Linux处理管道时是利用现有的文件结构和VFS中inode共同完成的，并没有为管道提供另外的数据结构。如下图所示<br><img src="https://melody-pic-1254202436.cos.ap-guangzhou.myqcloud.com/pic/180518/FK0E7lbl8F.png?imageslim" alt=""><br>在图中的文件结构中，f_inode执行VFS中的inode，该inode指向1一个页框大小的内存区域，也就是说linux中管道的缓冲区大小为4096byte，f_op指向操作方法，对于不同的操作对象提供不同的操作方法，对于管道来说，f_op会指向pipe_read或pipe_write方法。</p>
<h2 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断文件描述符local_fd是否是管道 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pipe</span><span class="params">(<span class="keyword">uint32_t</span> local_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> global_fd = fd_local2global(local_fd);</span><br><span class="line">    <span class="keyword">return</span> file_table[global_fd].fd_flag == PIPE_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建管道,成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_pipe(<span class="keyword">int32_t</span> pipefd[<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> global_fd = get_free_slot_in_global();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 申请一页内核内存做环形缓冲区 */</span></span><br><span class="line">    file_table[global_fd].fd_inode = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化环形缓冲区 */</span></span><br><span class="line">    ioqueue_init((struct ioqueue *)file_table[global_fd].fd_inode);</span><br><span class="line">    <span class="keyword">if</span> (file_table[global_fd].fd_inode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将fd_flag复用为管道标志 */</span></span><br><span class="line">    file_table[global_fd].fd_flag = PIPE_FLAG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将fd_pos复用为管道打开数 */</span></span><br><span class="line">    file_table[global_fd].fd_pos = <span class="number">2</span>;</span><br><span class="line">    pipefd[<span class="number">0</span>] = pcb_fd_install(global_fd);</span><br><span class="line">    pipefd[<span class="number">1</span>] = pcb_fd_install(global_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从管道中读数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从管道中读数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buffer = buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取管道的环形缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span> *<span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span> *)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选择较小的数据读取量,避免阻塞 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ioq_len = ioq_length(ioq);</span><br><span class="line">    <span class="keyword">uint32_t</span> size = ioq_len &gt; count ? count : ioq_len;</span><br><span class="line">    <span class="keyword">while</span> (bytes_read &lt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        *buffer = ioq_getchar(ioq);</span><br><span class="line">        ++bytes_read;</span><br><span class="line">        ++buffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>往管道写数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 往管道中写数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span> *<span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span> *)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选择较小的数据写入量,避免阻塞 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ioq_left = bufsize - ioq_length(ioq);</span><br><span class="line">    <span class="keyword">uint32_t</span> size = ioq_left &gt; count ? count : ioq_left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *buffer = buf;</span><br><span class="line">    <span class="keyword">while</span> (bytes_write &lt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        ioq_putchar(ioq, *buffer);</span><br><span class="line">        bytes_write++;</span><br><span class="line">        buffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在shell中支持管道"><a href="#在shell中支持管道" class="headerlink" title="在shell中支持管道"></a>在shell中支持管道</h2><p>在平常使用shell的使用，经常会使用到管道命令，类似这种。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep xxx | grep -v grep</span><br></pre></td></tr></table></figure></p>
<p>管道之所以可以这样使用，是进行了输入输出重定向。通常情况下键盘是输入，屏幕是输入。这就是标准输入与标准输出。而输入输出重定向就是改变输入输出的位置，比如从文件中读取输入称为输入重定向，将结果输出到文件中称为输出重定向。</p>
<p>而管道的作用就是利用了输入输出重定向的与原理，将一个命令的输出作为另一个命令的输入来使用。管道符左边命令的输出数据会作为右边命令的输入数据使用。</p>
<p>核心原理就是这样，实现的时候就需要把旧的文件描述符替换为新的文件描述符，文件描述符是我们获取数据和写入数据的根本，改变了文件描述符中的数据，输入输出的位置自然也就变了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符old_local_fd重定向为new_local_fd */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_fd_redirect</span><span class="params">(<span class="keyword">uint32_t</span> old_local_fd, <span class="keyword">uint32_t</span> new_local_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_struct *cur = running_thread();</span><br><span class="line">    <span class="comment">/* 恢复标准描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (new_local_fd &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;fd_table[old_local_fd] = new_local_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> new_global_fd = cur-&gt;fd_table[new_local_fd];</span><br><span class="line">        cur-&gt;fd_table[old_local_fd] = new_global_fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下shell中对管道的处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 针对管道的处理 */</span></span><br><span class="line"><span class="keyword">char</span> *pipe_symbol = <span class="built_in">strchr</span>(cmd_line, <span class="string">'|'</span>);</span><br><span class="line"><span class="keyword">if</span> (pipe_symbol)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 支持多重管道操作,如cmd1|cmd2|..|cmdn,</span></span><br><span class="line"><span class="comment">     * cmd1的标准输出和cmdn的标准输入需要单独处理 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1 生成管道*/</span></span><br><span class="line">    <span class="keyword">int32_t</span> fd[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;; <span class="comment">// fd[0]用于输入,fd[1]用于输出</span></span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="comment">/* 将标准输出重定向到fd[1],使后面的输出信息重定向到内核环形缓冲区 */</span></span><br><span class="line">    fd_redirect(stdout_no, fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2 第一个命令 */</span></span><br><span class="line">    <span class="keyword">char</span> *each_cmd = cmd_line;</span><br><span class="line">    pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>);</span><br><span class="line">    *pipe_symbol = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行第一个命令,命令的输出会写入环形缓冲区 */</span></span><br><span class="line">    argc = <span class="number">-1</span>;</span><br><span class="line">    argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">    cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跨过'|',处理下一个命令 */</span></span><br><span class="line">    each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将标准输入重定向到fd[0],使之指向内核环形缓冲区*/</span></span><br><span class="line">    fd_redirect(stdin_no, fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">/*3 中间的命令,命令的输入和输出都是指向环形缓冲区 */</span></span><br><span class="line">    <span class="keyword">while</span> ((pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        *pipe_symbol = <span class="number">0</span>;</span><br><span class="line">        argc = <span class="number">-1</span>;</span><br><span class="line">        argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">        cmd_execute(argc, argv);</span><br><span class="line">        each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 处理管道中最后一个命令 */</span></span><br><span class="line">    <span class="comment">/* 将标准输出恢复屏幕 */</span></span><br><span class="line">    fd_redirect(stdout_no, stdout_no);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行最后一个命令 */</span></span><br><span class="line">    argc = <span class="number">-1</span>;</span><br><span class="line">    argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">    cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  将标准输入恢复为键盘 */</span></span><br><span class="line">    fd_redirect(stdin_no, stdin_no);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6 关闭管道 */</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/16/exec/" rel="next" title="二十二. 让shell支持外部命令">
                <i class="fa fa-chevron-left"></i> 二十二. 让shell支持外部命令
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/08/tcp1/" rel="prev" title="Unix网络编程(一、简单回显服务器)">
                Unix网络编程(一、简单回显服务器) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="melody">
            
              <p class="site-author-name" itemprop="name">melody</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">35</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/melodywei" title="GitHub &rarr; https://github.com/melodywei" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:melodywei97@gmail.com" title="E-Mail &rarr; mailto:melodywei97@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进程同步"><span class="nav-number">1.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#wait和exit"><span class="nav-number">1.1.</span> <span class="nav-text">wait和exit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#孤儿进程和僵尸进程"><span class="nav-number">1.1.1.</span> <span class="nav-text">孤儿进程和僵尸进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#管道通信"><span class="nav-number">2.</span> <span class="nav-text">管道通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#管道的原理"><span class="nav-number">2.1.</span> <span class="nav-text">管道的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux中管道的设计"><span class="nav-number">2.2.</span> <span class="nav-text">linux中管道的设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道的实现"><span class="nav-number">2.3.</span> <span class="nav-text">管道的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在shell中支持管道"><span class="nav-number">2.4.</span> <span class="nav-text">在shell中支持管道</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">melody</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
