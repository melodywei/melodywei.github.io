<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="melodyのblog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="melodyのblog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="melodyのblog">






  <link rel="canonical" href="http://yoursite.com/page/3/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>melodyのblog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">melodyのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/protectedmode2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/protectedmode2/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">四. 获取内存容量</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 18:23:04" itemprop="dateCreated datePublished" datetime="2018-04-22T18:23:04+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面一篇文章中介绍了进入保护模式的方法：</p>
<ol>
<li>打开A20</li>
<li>加载gdt</li>
<li>将控制寄存器cr0的pe位置1<br>通过这三步成功的进入到保护模式下，但是在进入保护模式之前，还需要对进行内存的检测工作，启动分页机制等等，最后还要将内核加载到内存当中。这些是之前没有完成的，接下来就要完成这些进入到保护模式之前的准备工作</li>
</ol>
<h1 id="获取物理内存大小"><a href="#获取物理内存大小" class="headerlink" title="获取物理内存大小"></a>获取物理内存大小</h1><p>在linux中，获取内存容量的方法有很多种，比如detect_memory这个函数。不管是通过哪个函数获取到的内存容量，其本质都是通过调用BIOS中断 <strong>int 0x15</strong> 实现的，<strong>0x15</strong>中断下有三个子功能</p>
<ol>
<li>eax=0xe820: 遍历主机全部内存</li>
<li>ax=0xe801: 分别检测低15MB和16~4GB的内存，最大支持4GB</li>
<li>ax=0x88: 最多检测出64MB内存，实际内存超过64MB时也返回64MB</li>
</ol>
<h2 id="0xE820"><a href="#0xE820" class="headerlink" title="0xE820"></a>0xE820</h2><p>0xE820的功能最强，当然也最复杂，它需要多次调用，每次调用都返回一种类型的内存，直到检测完毕。其结果主要通过ARDS(地址范围描述符)结构存储在内存中。ARDS的结构如下</p>
<table>
<thead>
<tr>
<th>偏移量</th>
<th>属性名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>BaseAddrLow</td>
<td>基地址的低32位</td>
</tr>
<tr>
<td>4</td>
<td>BaseAddrHigh</td>
<td>基地址的高32位</td>
</tr>
<tr>
<td>8</td>
<td>LengthLow</td>
<td>内存长度的低32位，以字节为单位</td>
</tr>
<tr>
<td>12</td>
<td>LengthHigh</td>
<td>内存长度的高32位，以字节为单位</td>
</tr>
<tr>
<td>16</td>
<td>Type</td>
<td>本段内存的类型</td>
</tr>
</tbody>
</table>
<p>此结构中每个字段的大小都是4byte，所以此结构大小为20byte，每次int 0x15之后，BIOS就返回这样一个结构的数据。</p>
<p>type字段描述这段内存的类型，也就是表示这段内存的用途。</p>
<table>
<thead>
<tr>
<th>type值</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AddressRangeMemory</td>
<td>这段内存可以被操作系统使用</td>
</tr>
<tr>
<td>2</td>
<td>AddressRangeReserved</td>
<td>内存使用中或者被系统保留，操作系统不可以使用此内存</td>
</tr>
<tr>
<td>其他</td>
<td>未定义</td>
<td>未定义，将来会用到，目前保留，操作系统将其视为AddressRangeReserved</td>
</tr>
</tbody>
</table>
<p>由于我们的kernel运行环境是32位的，所以在ARDS结构属性中，只需要用到低32位属性。BaseAddrLow + LengthLow是一段内存区域的上限。</p>
<p>BIOS中断只是一段函数例程，要按照它的约定对其提供参数。以下是其需要的参数及意义</p>
<p>调用前的输入</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180408/Hf1eg09EAj.png?imageslim" alt="int0x15中断调用约定_输入"></p>
<p>返回后输出</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180408/amE4k3g76j.png?imageslim" alt="int0x15中断调用约定_输出"></p>
<p>调用步骤如下：</p>
<ol>
<li>填充输入的参数</li>
<li>执行中断int 0x15</li>
<li>在cf位为0的情况下，从返回的寄存器中获取结构</li>
</ol>
<p>相应代码如下<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;int 0x15 eax=0xe820 edx=0x534d4150</span></span><br><span class="line"><span class="comment">;--------------------------------------</span></span><br><span class="line">    <span class="comment">;填充输入数据</span></span><br><span class="line">    <span class="keyword">xor</span> <span class="built_in">ebx</span>, <span class="built_in">ebx</span>    <span class="comment">;将ebx清0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0x534d4150</span> </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>, ards_buf  <span class="comment">;ards结构缓冲区</span></span><br><span class="line"><span class="symbol">  .e820_mem_get_loop:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">0xe820</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">20</span>   <span class="comment">;ards地址范围描述符结构大小位20字节</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">;获取所有ards内存段</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">di</span>, <span class="built_in">cx</span>  <span class="comment">;使di增加20字节指向缓冲区中新的ards结构位置</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">word</span> [ards_nr] <span class="comment">;记录ards数量</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">ebx</span>, <span class="number">0</span>  <span class="comment">;如果ebx为0且cf位不为1,说明adrs全部返回</span></span><br><span class="line">    <span class="keyword">jnz</span> .e820_mem_get_loop</span><br><span class="line"></span><br><span class="line">    <span class="comment">;在所有ards结构中找出（base_addr_low + length_low)的最大值，即为内存的容量</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, [ards_nr]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, ards_buf</span><br><span class="line">    <span class="keyword">xor</span> <span class="built_in">edx</span>, <span class="built_in">edx</span></span><br><span class="line"><span class="symbol">  .find_max_mem_area:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span>]  <span class="comment">;base_addr_low</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, [<span class="built_in">ebx</span> + <span class="number">8</span>] <span class="comment">;length_low</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">ebx</span>, <span class="number">20</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">jge</span> .next_ards</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">  .next_ards:</span></span><br><span class="line">    <span class="keyword">loop</span> .find_max_mem_area</span><br><span class="line">    <span class="keyword">jmp</span> .mem_get_ok</span><br><span class="line"></span><br><span class="line"><span class="symbol">  .mem_get_ok:</span></span><br><span class="line">    <span class="keyword">mov</span> [total_mem_bytes], <span class="built_in">edx</span></span><br></pre></td></tr></table></figure></p>
<p>此段代码中，只是简单的按照格式对int 0x15中断的调用，首先是参数的填充，然后对获取所有的ards内存段，接下来找出这所有内存段中 <strong>baseAddrLow+LengthLow</strong> 的最大值，该值也就是内存的总容量</p>
<h2 id="0xE801"><a href="#0xE801" class="headerlink" title="0xE801"></a>0xE801</h2><p>另一个获取内存容量的方法是BIOS 0x15中断的子功能0xE801，此方法相较于之前的方法较为简单，但是最大只能获取到4GB的内存空间。调用这个功能只需要在ax寄存器中存入子功能号0xe801即可，无需其他的输入数据。</p>
<p>通过此方法获取的内存会分为两组数据分别放到两组寄存器中：</p>
<p>首先是低于15MB的内存，这块内存的大小会存入AX寄存器中，但是存入AX寄存器中的数值的单位是1KB，也就是说 <strong>实际的内存大小=AX*1024</strong>，AX的最大值为0x3c00</p>
<p>然后是16MB~4GB的内存空间，这块内存的大小会存入BX寄存器中，单位是64KB。所以 <strong>内存的实际大小=BX*64*1024</strong></p>
<p>下面是BIOS中断0x15子功能0xE801的说明</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180408/cbFgK2Kj0h.png?imageslim" alt="mark"></p>
<p>相应代码如下<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0xe801</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;先算出低15MB的内存</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span> <span class="comment">;将获取到的低15M内存乘1024转化成byte</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">eax</span>, <span class="number">0xffff</span> <span class="comment">;只取低16位，防止乘法溢出</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x100000</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="built_in">edx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;再将16MB以上的空间转化成byte为单位</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">eax</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">0x10000</span> <span class="comment">;32位下默认被乘数是eax，将获取到的内存乘以64KB转换成byte</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">ecx</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">esi</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="built_in">esi</span> </span><br><span class="line"><span class="keyword">jmp</span> .mem_get_ok</span><br></pre></td></tr></table></figure></p>
<h2 id="0x88"><a href="#0x88" class="headerlink" title="0x88"></a>0x88</h2><p>该功能算是获取内存最简单的方法了，但功能也是最简单的，最大只能获取64MB的内存空间</p>
<p>调用方法如下。</p>
<ol>
<li>在ax寄存器中写入子功能号0x88</li>
<li>调用中断0x15</li>
<li>cf为0的情况下， ax即为获取到的内存大小，单位1KB，所以实际内存大小=ax*1024 + 1MB</li>
</ol>
<p>代码如下<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">0x88</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x15</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">eax</span>, <span class="number">0xffff</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0x400</span></span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">edx</span>, <span class="number">16</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">edx</span>, <span class="built_in">eax</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">edx</span>, <span class="number">0x100000</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/protectedmode/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/protectedmode/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">三. 保护模式</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 18:22:52" itemprop="dateCreated datePublished" datetime="2018-04-22T18:22:52+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实模式与保护模式下的分段机制"><a href="#实模式与保护模式下的分段机制" class="headerlink" title="实模式与保护模式下的分段机制"></a>实模式与保护模式下的分段机制</h1><p>程序想要在计算机上运行，就必须将源代码编译链接成二进制的可执行文件之后才可能被操作系统加载执行。如果在加载的过程中，程序的地址都是绝对的物理地址，那么程序就必须放在一个固定的地方，那么拥有两个相同地址的程序就只能运行一个了。</p>
<p>于是，分段机制就产生了。让CPU通过 <strong>段基址：段内偏移</strong> 来访问任意内存，这样程序就可以实现重定位。也就是说，段内偏移相对于段基址是不变的。无论段基址是多少，只要给出段内偏移，CPU就能访问到正确的指令。于是加载用户程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改为该地址，程序便可准确无误的运行，因为程序中用的是偏移地址，相对于新的段基址，该偏移地址处的内容还是一样的，如图所示：</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180405/7Fc8CLLkGK.png?imageslim" alt="mark"></p>
<p>到了保护模式下，虽然访问内存同样是通过段基址：段内偏移的方式进行访问。而且段值同样是存放在原来16位的段寄存器中，但是这些段寄存器存放的不在是段基址，而是相当于一个数组索引的东西，通过这个索引，可以找到一个表项。在这个表项中，存放了段基址等很多的属性，这个表项称为段描述符表。一个段描述符只用来定义一个内存段。代码段要占用一个段描述符，数据段和栈段同样分别要占一个段描述符，这些描述符就存放在全局描述附符表中(GDT)。</p>
<p>一个段描述符表中，会存放很多的段描述符数据，每一个段描述符为8字节，它的格式如下图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180405/fCIe3ib57H.png?imageslim" alt="段描述符格式"></p>
<p>G位表示段界限粒度，为0时表示粒度为1字节，为1时表示粒度为4KB</p>
<p> <strong>实际段界限=(描述符中的段界限+1)*粒度-1</strong>，假设段界限为0xfffff，G位为1时，实际段界限=0x100000*4KB-1 = 0xFFFFFFFF。如果偏移地址超过了段界限，CPU会抛出异常</p>
<p>S为表示是否是系统段。当S为1时，表示非系统段，为0表示系统段。</p>
<p>type字段的属性和S用关系，用一张图来表示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180405/Hm9eL7H93g.png?imageslim" alt="mark"></p>
<p>P位表示段是否位于内存中。</p>
<p>L位用来设置是否为64位代码段</p>
<p>D/B位表示有效地址及操作数的大小。对于代码段来说，此位是D位。为0时表示有效地址和操作数是16位。对于栈段来说，此为是B位，为0时表示使用的16位的栈指针寄存器</p>
<p>我们想要从实模式进入保护模式，就必须构建段描述符表，并将构建好的段描述符加载到全局描述符表中，这是进入保护模式的第一步</p>
<h1 id="实模式下的寻址方式"><a href="#实模式下的寻址方式" class="headerlink" title="实模式下的寻址方式"></a>实模式下的寻址方式</h1><p>在计算机的上古时代，还只有16位的CPU，此时我们只能访问1MB的内存空间，这个阶段也还没有保护模式的概念</p>
<p>在上古时代的CPU设计中，访问内存需要通过 <strong>段基址：段内偏移</strong> 来访问内存，因为当时还是16位的CPU，所以当时的基址寄存器同样也是16位的，16位所能表示的最大地址空间为 <strong>2^10 * 2^6 = 64KB</strong> 也就是说，访问超过64KB的内存空间，就需要切换段基址。</p>
<p>访问内存的方式是通过 <strong>物理地址 = 段基址*16 + 段内偏移</strong>，当时的地址总线是20位的，也就是刚好能表示1MB的内存空间，而CPU只有16位，想要访问到20位的地址空间，就只能通过特殊的方式处理一下，当时CPU的设计者就在地址处理单元中动了手脚，自动将段基址*16，也就是左移4位，在和16位的段内偏移相加，组成20位的物理地址</p>
<p>通过上面这种内存访问的方式，能够表示的最大内存是 <strong>0xffff:0xffff=0x10ffef = 1M + 64K - 16B</strong>超过1M的内存部分被称为高端内存区HMA，由于实模式下的地址线是20位，最大寻址空间是1MB，即0x0~0xfffff。超过1MB内存的部分在逻辑上也是正常的，但物理内存中并没有与之对应的部分。为了让段基址：段内偏移的策略任然可用，CPU采用的做法是将超过1MB的部分自动回绕为0，继续从0地址开始映射</p>
<p>地址回绕如图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180405/J5a8GFDl64.png?imageslim" alt="地址回绕"></p>
<p>了解决上述兼容性问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根）的有效性，被称为A20Gate：</p>
<ol>
<li><p>如果A20Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域；</p>
</li>
<li><p>如果A20Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式即取模方式</p>
</li>
</ol>
<p>如果想要从实模式进入到保护模式下，A20Gate就必须打开，否则只能访问到0x10FFEF的内存空间，这也是我们进入保护模式做的第二步</p>
<p>#进入保护模式</p>
<p>前面介绍了进入保护模式的前两步，现在还剩下最后一步，就可以进入保护模式。</p>
<p>打开cr0控制寄存器的PE位，也就是将PE位置1，这是保护模式的开关</p>
<p>通过前面的介绍，进入保护模式要分三步走</p>
<ol>
<li>打开A20</li>
<li>加载gdt</li>
<li>将cr0的PE位置1</li>
</ol>
<p>下面就来看看具体的代码实现</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line"><span class="meta">section</span> loader vstart=LOADER_BASE_ADDR</span><br><span class="line">LOADER_STACK_TOP <span class="built_in">equ</span> LOADER_BASE_ADDR</span><br><span class="line"><span class="keyword">jmp</span> loader_start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">; 构建全局描述符表，并填充段描述符，段描述符的大小为8字节，在这里将其分为低4字节与高4字节来定义</span></span><br><span class="line"><span class="comment">; dd=define double-word，为4字节</span></span><br><span class="line"><span class="comment">;--------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; gdt的起始地址为GDT_BASE的地址，且gdt的第0个描述符不可用，所以将其直接定义为0</span></span><br><span class="line"><span class="symbol">GDT_BASE:</span> <span class="built_in">dd</span> <span class="number">0x00000000</span></span><br><span class="line">            <span class="built_in">dd</span> <span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 代码段</span></span><br><span class="line"><span class="symbol">CODE_DESC:</span> <span class="built_in">dd</span> <span class="number">0x0000ffff</span></span><br><span class="line">            <span class="built_in">dd</span> DESC_CODE_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="comment">; 数据段和栈段</span></span><br><span class="line"><span class="symbol">DATA_STACK_DESC:</span> <span class="built_in">dd</span> <span class="number">0x0000ffff</span></span><br><span class="line">                 <span class="built_in">dd</span> DESC_DATA_HIGH4</span><br><span class="line"></span><br><span class="line"><span class="comment">; 显存段描述符</span></span><br><span class="line"><span class="symbol">VIDEO_DESC:</span> <span class="built_in">dd</span> <span class="number">0x80000007</span></span><br><span class="line">            <span class="built_in">dd</span> DESC_VIDEO_HIGH4</span><br><span class="line"></span><br><span class="line">GDT_SIZE <span class="built_in">equ</span>   $-GDT_BASE</span><br><span class="line">GDT_LIMIT <span class="built_in">equ</span> GDT_SIZE - <span class="number">1</span></span><br><span class="line"><span class="built_in">times</span> <span class="number">60</span> <span class="built_in">dq</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">SELECTOR_CODE <span class="built_in">equ</span> (<span class="number">0x0001</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0     <span class="comment">; 相当于(CODE_DESC - GDT_BASE)/8 + TI_GDT + RPL0</span></span><br><span class="line">SELECTOR_DATA <span class="built_in">equ</span> (<span class="number">0x0002</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0     <span class="comment">; 同上</span></span><br><span class="line">SELECTOR_VIDEO <span class="built_in">equ</span> (<span class="number">0x0003</span>&lt;&lt;<span class="number">3</span>) + TI_GDT + RPL0    <span class="comment">; 同上 </span></span><br><span class="line"></span><br><span class="line">gdt_ptr <span class="built_in">dw</span> GDT_LIMIT    <span class="comment">;gdt的前2字节是段界限，后4字节是段基址</span></span><br><span class="line">        <span class="built_in">dd</span> GDT_BASE</span><br><span class="line">loadermsg <span class="built_in">db</span> <span class="string">'loader in real.'</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loader_start:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>, LOADER_BASE_ADDR</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bp</span>, loadermsg</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">15</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x1301</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x001f</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1800</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;---------------------------</span></span><br><span class="line"><span class="comment">;准备进入保护模式</span></span><br><span class="line"><span class="comment">;1. 打开A20</span></span><br><span class="line"><span class="comment">;2. 加载gdt</span></span><br><span class="line"><span class="comment">;3. 将cr0的PE位置1</span></span><br><span class="line"><span class="comment">;---------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------打开A20--------</span></span><br><span class="line">    <span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">0x92</span></span><br><span class="line">    <span class="keyword">or</span> <span class="built_in">al</span>, <span class="number">0000_0010b</span></span><br><span class="line">    <span class="keyword">out</span> <span class="number">0x92</span>, <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;-------加载gdt-------</span></span><br><span class="line">    <span class="keyword">lgdt</span> [gdt_ptr]</span><br><span class="line"></span><br><span class="line"><span class="comment">;------cr0第0位置1-----</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">    <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x00000001</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jmp</span> SELECTOR_CODE:p_mode_start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="symbol">p_mode_start:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_DATA</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esp</span>, LOADER_STACK_TOP</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, SELECTOR_VIDEO</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">gs</span>, <span class="built_in">ax</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">160</span>], <span class="string">'P'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jmp</span> $</span><br></pre></td></tr></table></figure>
<p>这这段代码中，前面主要是为段描述符表填充数据，因为一个段描述符占8字节，所以分了两个dword来填充，主要是为了方便。然后在实模式下打印了一句话。接着进入到保护模式中，并在进入到保护模式之后打印了一个字符P</p>
<p>构建段描述符的数据定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br><span class="line"></span><br><span class="line">;----------------------------</span><br><span class="line">;gdt描述符属性</span><br><span class="line"></span><br><span class="line">DESC_G_4K   equ   1_00000000000000000000000b</span><br><span class="line">DESC_D_32   equ    1_0000000000000000000000b</span><br><span class="line">DESC_L      equ     0_000000000000000000000b    ;  64位代码标记，此处标记为0便可。</span><br><span class="line">DESC_AVL    equ      0_00000000000000000000b    ;  cpu不用此位，暂置为0</span><br><span class="line">DESC_LIMIT_CODE2  equ 1111_0000000000000000b</span><br><span class="line">DESC_LIMIT_DATA2  equ DESC_LIMIT_CODE2</span><br><span class="line">DESC_LIMIT_VIDEO2  equ 0000_000000000000000b</span><br><span class="line">DESC_P      equ           1_000000000000000b</span><br><span class="line">DESC_DPL_0  equ            00_0000000000000b</span><br><span class="line">DESC_DPL_1  equ            01_0000000000000b</span><br><span class="line">DESC_DPL_2  equ            10_0000000000000b</span><br><span class="line">DESC_DPL_3  equ            11_0000000000000b</span><br><span class="line">DESC_S_CODE equ              1_000000000000b</span><br><span class="line">DESC_S_DATA equ   DESC_S_CODE</span><br><span class="line">DESC_S_sys  equ              0_000000000000b</span><br><span class="line">DESC_TYPE_CODE  equ           1000_00000000b    ;x=1,c=0,r=0,a=0 代码段是可执行的,非依从&gt;的,不可读的,已访问位a清0.</span><br><span class="line">DESC_TYPE_DATA  equ           0010_00000000b    ;x=0,e=0,w=1,a=0 数据段是不可执行的,向上&gt;扩展的,可写的,已访问位a清0.</span><br><span class="line"></span><br><span class="line">;DESC_CODE_HIGH4 = 1100 1111 1001 1000 0000 0000 代码段的高4字节</span><br><span class="line">DESC_CODE_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00</span><br><span class="line"></span><br><span class="line">;DESC_DATA_HIGH4 = 1100 1111 1001 0010 0000 0000</span><br><span class="line">DESC_DATA_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00</span><br><span class="line"></span><br><span class="line">;DESC_VIDEO_HIGH4= 1100 0000 1001 0010 0000 1011</span><br><span class="line">DESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x0b</span><br><span class="line"></span><br><span class="line">;--------------   选择子属性  ---------------</span><br><span class="line">RPL0  equ   00b</span><br><span class="line">RPL1  equ   01b</span><br><span class="line">RPL2  equ   10b</span><br><span class="line">RPL3  equ   11b</span><br><span class="line">TI_GDT   equ   000b</span><br><span class="line">TI_LDT   equ   100b</span><br></pre></td></tr></table></figure>
<p>运行效果如下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180405/c2m6gbGh63.png?imageslim" alt="mark"></p>
<p>接下来看看GDT中都有哪些数据</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180405/iikiIGB4bj.png?imageslim" alt="mark"></p>
<p>GDT中的第0位是不可用的，第1位是代码段，第2位是数据段，第三位是显存的数据段</p>
<p>cr0控制寄存器中的数据</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180405/baAlg4l5hF.png?imageslim" alt="mark"></p>
<p>PE位大写就表示PE位为1。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/mbr/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/mbr/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">二. 编写mbr，让机器启动起来</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 18:22:36" itemprop="dateCreated datePublished" datetime="2018-04-22T18:22:36+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mbr简介"><a href="#mbr简介" class="headerlink" title="mbr简介"></a>mbr简介</h1><p>大家都知道，在我们按下电脑电源的时候，首先启动的BIOS(基本输入输出系统)，那么BIOS又是如何被启动的呢，谁来唤醒他呢，它又在何处运行呢。要了解这些的话，首先得介绍一下我们实模式的内存布局</p>
<h2 id="实模式的内存布局"><a href="#实模式的内存布局" class="headerlink" title="实模式的内存布局"></a>实模式的内存布局</h2><p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/1H7edCBmd5.png?imageslim" alt="mark"></p>
<p>图中的内容我们现在只需要关注红色框出来的地方，可以看到BIOS的入口地址处只有16BYTE的空间，很显然，这一小块空间肯定存放的不是数据，只能是指令了，图中也写的很明显了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp f000:e05b</span><br></pre></td></tr></table></figure></p>
<p>也就是跳转到了(f000 &lt;&lt; 4) + e05b = fe05b处，这里的段基址左移四位的原因是，在实模式下段基址寄存器只有16位，想一下，16位的寄存器最多访问2^16=64KB的空间，我们想访问实模式下1MB的空间的话就需要将段基址左移4位，自然就可以访问到1MB的空间了，这么做的原因也是出于兼容性而采取的曲线救国方式，虽然我们现在的OS都已经到了64位，它也还得向下兼容不是吗</p>
<p>当我们的电脑加电的一瞬间cs：ip就会被强制置位f000:e05b了，接下来就对内存，显卡等外设进行检查，做好它的初始化工作之后就完成它的任务了，在最后的时候，BIOS会通过绝对远跳<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp 0:0x7c00</span><br></pre></td></tr></table></figure></p>
<p>将接力棒交由MBR来加载我们的内核，我们初步的工作就是编写MBR。在进行内核加载之前，我们先通过MBR打印一些字符，来验证我们之前所说是否正确</p>
<h1 id="编写MBR验证程序"><a href="#编写MBR验证程序" class="headerlink" title="编写MBR验证程序"></a>编写MBR验证程序</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;主引导程序</span></span><br><span class="line"><span class="comment">;---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span> <span class="comment">;程序开始的地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>            <span class="comment">;使用cs初始化其他的寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>            <span class="comment">;因为是通过jmp 0:0x7c00到的MBR开始地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span>            <span class="comment">;所以此时的cs为0,也就是用0初始化其他寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span>            <span class="comment">;此类的寄存器不同通过立即数赋值，采用ax中转</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">fs</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">0x7c00</span>  <span class="comment">;初始化栈指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;清屏利用0x10中断的0x6号功能</span></span><br><span class="line"><span class="comment">;------------------------</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x600</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x700</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x184f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x10</span></span><br><span class="line">    <span class="comment">;获取光标位置</span></span><br><span class="line"><span class="comment">;---------------------</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">3</span>   <span class="comment">; 3号子功能获取光标位置</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">1</span>   <span class="comment">; bh寄存器存储带获取光标位置的页号,从0开始，此处填1可以看成将光标移动到最开始</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;打印字符串</span></span><br><span class="line"><span class="comment">;------------------</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, message</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">6</span>    <span class="comment">;字符串长度，不包括'\0'</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x1301</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jmp</span> $</span><br><span class="line"></span><br><span class="line">    message <span class="built_in">db</span> <span class="string">"My MBR"</span></span><br><span class="line">    <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span> </span><br><span class="line">    <span class="built_in">db</span> <span class="number">0x55</span>, <span class="number">0xaa</span></span><br></pre></td></tr></table></figure>
<p>这段代码通过0x10号中断直接操控显卡，达到打印字符串的目的</p>
<p>编写好后通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -o mbr.bin mbr.S</span><br><span class="line">dd if=mbr.bin of=/home/ba/bochs/hd60M.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure></p>
<p>对我们的汇编代码进行编译并写入之前创建的磁盘中，接下来运行bochs，应该可以看到如下结果</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/0aA2m7E0CB.png?imageslim" alt="mark"></p>
<p>现在我们通过bochs的调试看一下程序到底是怎么执行的，和我们之前所说的是否一致</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/l6k3aA46ml.png?imageslim" alt="mark"></p>
<p>这幅图是在我们开启bochs时显示的结果，很明显可以看到他的cs：ip寄存器的值和我们之前所说的结果一致，在这里进行跳转之后接下来肯定就是一系列的初始化工作了，我们跳过这些初始化的工作，直接进入到MBR执行的开始位置，也就是地址0x7c00处</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/3H9iD4fGIA.png?imageslim" alt="mark"></p>
<p>可以看到，左边是bochs初始化完成之后的输出，这是已经运行到了0x7c00后的结果，看红框标记的地方，有没有感觉很熟悉，这就是我们mbr的第一行代码啦，接下来就会按照我们所写的那样，清屏，打印了。</p>
<h1 id="读取硬盘"><a href="#读取硬盘" class="headerlink" title="读取硬盘"></a>读取硬盘</h1><p>前面通过打印字符串对开机启动过程做了个小小的验证，接下来需要让我们的MBR读取硬盘啦，因为加载kernel的话肯定需要从硬盘中读入数据<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 主引导程序</span></span><br><span class="line"><span class="comment">;---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">%include</span> <span class="string">"boot.inc"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span> <span class="comment">;程序开始的地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>            <span class="comment">;使用cs初始化其他的寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>            <span class="comment">;因为是通过jmp 0:0x7c00到的MBR开始地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span>            <span class="comment">;所以此时的cs为0,也就是用0初始化其他寄存器</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span>            <span class="comment">;此类的寄存器不同通过立即数赋值，采用ax中转</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">fs</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">0x7c00</span>  <span class="comment">;初始化栈指针，sp也就是32位下的esp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;清屏利用0x10中断的0x6号功能</span></span><br><span class="line"><span class="comment">;------------------------</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x600</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x700</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x184f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;获取光标位置</span></span><br><span class="line"><span class="comment">;---------------------</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">3</span>   <span class="comment">; 3号子功能获取光标位置</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">1</span>   <span class="comment">; bh寄存器存储带获取光标位置的页号,从0开始，此处填1可以看成将光标移动到最开始</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;打印字符串`</span></span><br><span class="line"><span class="comment">;------------------</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, message</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">6</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x1301</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x10</span></span><br><span class="line">    </span><br><span class="line">    message <span class="built_in">db</span> <span class="string">"My MBR"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, LOADER_START_SECTOR    <span class="comment">;起始扇区的lba地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, LOADER_BASE_ADDR        <span class="comment">;写入的地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">1</span>                       <span class="comment">;读入的扇区数</span></span><br><span class="line">    <span class="keyword">call</span> rd_disk_m_16</span><br><span class="line"></span><br><span class="line">    <span class="keyword">jmp</span> LOADER_BASE_ADDR</span><br><span class="line"></span><br><span class="line"><span class="comment">;读取n个扇区</span></span><br><span class="line"><span class="comment">;---------------------</span></span><br><span class="line"><span class="symbol">rd_disk_m_16:</span>       <span class="comment">;eax=扇区号，cx=读入的扇区数，bx=将数据写入的内存地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="built_in">eax</span>    <span class="comment">;备份eax和cx</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">di</span>, <span class="built_in">cx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置要读取的扇区数</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f2</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="built_in">al</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">esi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;将lba地址存入0x1f3-0x1f6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;lba地址0-7位写入端口0x1f3</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f3</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;lba地址8-15位写入端口0x1f4</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="number">8</span></span><br><span class="line">    <span class="keyword">shr</span> <span class="built_in">eax</span>, <span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f4</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;lba地址16-23位写入端口0x1f5</span></span><br><span class="line">    <span class="keyword">shr</span> <span class="built_in">eax</span>, <span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f5</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">shr</span> <span class="built_in">eax</span>, <span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">0x0f</span></span><br><span class="line">    <span class="keyword">or</span> <span class="built_in">al</span>, <span class="number">0xe0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f6</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;向0x1f7端口写入读命令</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f7</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0x20</span></span><br><span class="line">    <span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"><span class="symbol">.not_ready:</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line">    <span class="keyword">in</span> <span class="built_in">al</span>, <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">0x88</span> <span class="comment">;第4位为1表示硬盘控制器已经准备号数据传输，第7位为1表示硬盘忙</span></span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">al</span>, <span class="number">0x08</span></span><br><span class="line">    <span class="keyword">jnz</span> .not_ready</span><br><span class="line"></span><br><span class="line"><span class="comment">;从0x1f0端口读数据</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">di</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">256</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0x1f0</span></span><br><span class="line"><span class="symbol">.go_on_read:</span></span><br><span class="line">    <span class="keyword">in</span> <span class="built_in">ax</span>, <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">bx</span>], <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">loop</span> .go_on_read</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span> </span><br><span class="line">    <span class="built_in">db</span> <span class="number">0x55</span>, <span class="number">0xaa</span></span><br></pre></td></tr></table></figure></p>
<p>这是boot.inc中的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOADER_BASE_ADDR equ 0x900</span><br><span class="line">LOADER_START_SECTOR equ 0x2</span><br></pre></td></tr></table></figure></p>
<p>先看看程序的执行流程</p>
<ol>
<li>从0x7c00入口处进入mbr</li>
<li>打印My MBR</li>
<li>为读取磁盘操作传递参数，包括读入的扇区数，读取的数据写入的内存地址</li>
<li>将读取到的数据写入0x900，并跳到此处去执行</li>
</ol>
<p>MBR中的内容差不多就多了，接下来的工作就是逐步完善内核。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/bochs_deploy/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/bochs_deploy/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">一. bochs环境部署</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 18:22:18" itemprop="dateCreated datePublished" datetime="2018-04-22T18:22:18+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h1><p>一台linux操作系统的机器即可，最好是32位的。因为我们实现的小kernel是32位的，在64的机器上进行编译和链接可能会出现某些问题。笔者这里使用的是Ubuntu16.4</p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="bochs安装与配置"><a href="#bochs安装与配置" class="headerlink" title="bochs安装与配置"></a>bochs安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我们自制的操作系统也是运行在一个虚拟机中的，这里我们用的是bochs，bochs本身也是基于x86架构的，这也是我之前说我们的小kernel也是32位的原因<br><a href="https://sourceforge.net/projects/bochs/files/bochs/" target="_blank" rel="noopener">bochs下载地址</a> </p>
<p>点击链接之后你会看到如下界面<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/5gkkHc93Im.png?imageslim" alt="bochs版本"></p>
<p>我是使用的最新版本2.6.9的，大家也可以和我选择一样的版本</p>
<p>进入2.6.9版本的链接之后大家应该会看到如下界面<img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/B63DCAgEG5.png?imageslim" alt="mark"></p>
<p>大家下载我标箭头的文件到你的虚拟机上即可。</p>
<p>其实我们也可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install bochs</span><br></pre></td></tr></table></figure></p>
<p>这个命令进行安装，我不用这个方法安装的原因是安装之后的bochs文件比较分散，造成配置时比较麻烦，自己下载的文件进行安装时配置文件都在一起，管理起来方便</p>
<p>好了，文件下载好了之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf bochs-2.6.9.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>解压之后的文件如图<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/kK6ciCADEi.png?imageslim" alt="mark"></p>
<p>进入到bochs-2.6.9的目录中，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/ba/bochs --enable-debugger --enable-disasm --enable-iodebug --enable-iodebug --enable-x86-debugger --with-x --with-x11</span><br></pre></td></tr></table></figure></p>
<p>prefix中的路径请换成自己对应的安装路径</p>
<p>接下来输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></p>
<p>一段时间之后可能会出现如下错误</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180409/j1K7eik88I.png?imageslim" alt="mark"></p>
<p>因为我这里是一台全新的虚拟机，有许多库都没有安装，可能你们不会出现，如果出现了这个错误之后，安装x11的lib库即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libx11-dev</span><br></pre></td></tr></table></figure>
<p>继续make，出现如下错误</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/bHkDl7dLLi.png?imageslim" alt="mark"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libxrandr-dev</span><br></pre></td></tr></table></figure>
<p>继续make</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/D8bgKJciJJ.png?imageslim" alt="mark"></p>
<p>看到这个就说明离成功只有一步之遥了，哈哈</p>
<p>在之前的配置中加上libs=’-lx11’，完整的配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/home/ba/bochs --enable-debugger --enable-disasm --enable-iodebug --enable-iodebug --enable-x86-debugger --with-x --with-x11 libs=&apos;-lx11&apos;</span><br></pre></td></tr></table></figure>
<p>大家不要忘了把prefix的路径改为自己想安装的路径，接下来make。可以看到没有错误提示了。如果大家出行其他错误可以自行百度。</p>
<p>下一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/cG1E52jj2F.png?imageslim" alt="mark"></p>
<p>大家可以看看自己的安装目录下是否出现这个文件夹，安装目录参考自己配置文件中填写的路径</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>安装好了bochs之后我们要对它进行配置，这个配置大家可以参考安装目录下的bochsrc-sample.txt，该文件的路径在bochs目录下的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">share/doc/bochs/bochsrc-sample.txt</span><br></pre></td></tr></table></figure></p>
<p>因为bochs在运行的时候要加载我们的配置文件，这个配置文件需要我们自己指定，所以我把配置文件放在了bochs目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cd bochs</span><br><span class="line">vim bochsrc.disk</span><br><span class="line"></span><br><span class="line">// 配置如下</span><br><span class="line">＃首先设置 Bochs 在运行过程中能够使用的内存，本例为 32MB。</span><br><span class="line">＃关键字为 megs</span><br><span class="line">megs 32</span><br><span class="line"></span><br><span class="line">＃设置对应真实机器的 BIOS 和 VGA BIOS 。</span><br><span class="line">＃对应两个关键字为 ： romimage 和 vgaromimage</span><br><span class="line">romimage: file＝/home/ba/bochs/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file＝/home/ba/bochs/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">#选择启动盘符</span><br><span class="line">boot: disk  #从硬盘启动</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输入位置</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 关闭鼠标，打开键盘</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard: keymap=/home/ba/bochs/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 设置硬盘</span><br><span class="line">ata0: enabled=1,ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br></pre></td></tr></table></figure></p>
<p>大家在写配置文件的时候一定要把这些路径写成绝对路径，不要使用相对路径，因为bochs不认相对路径</p>
<p>配置文件写完了，那我们运行一下bochs试试， 看看是什么样子</p>
<p>在bochs的目录下输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/bochs</span><br></pre></td></tr></table></figure></p>
<p>接下来就会看到如下界面</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/laKCC319C6.png?imageslim" alt="mark"></p>
<p>可以看到默认的选项是2，要求我们输入配置文件的名称，此时输入bochsrc.disk即可，也就是以前我们写的配置文件的名称。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/m1FHEGhm82.png?imageslim" alt="mark"></p>
<p>在我们输入配置文件按下回车之后可以看到，报了一个PANIC级别的错误，意思是我们没有启动盘，因为bochs是模拟的操作系统进行运行，此时我们还没有启动盘，所以它不知道从哪里开始运行，接下来我们就开始创建启动盘</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/ffKH3L8Lm3.png?imageslim" alt="mark"></p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/m2ED2hdJ77.png?imageslim" alt="mark"></p>
<p>图中需要我们输入的地方我用红色的方框标记出来了，60代表该硬盘的大小为60M，hd60M.img是我给改硬盘取得名字，最后一行用绿色标记的是我们需要加入到配置文件中的，这是我们硬盘配置好之后，bochs给我们自动生成的硬盘信息，接下来在配置文件的最后一行加上该硬盘的信息</p>
<p>完整的配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">＃关键字为 megs</span><br><span class="line">megs 32</span><br><span class="line"></span><br><span class="line">＃设置对应真实机器的 BIOS 和 VGA BIOS 。</span><br><span class="line">＃对应两个关键字为 ： romimage 和 vgaromimage</span><br><span class="line">romimage: file＝/home/ba/bochs/share/bochs/BIOS-bochs-latest</span><br><span class="line">vgaromimage: file＝/home/ba/bochs/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line">#选择启动盘符</span><br><span class="line">boot: disk  #从硬盘启动</span><br><span class="line"></span><br><span class="line"># 设置日志文件的输入位置</span><br><span class="line">log: bochs.out</span><br><span class="line"></span><br><span class="line"># 关闭鼠标，打开键盘</span><br><span class="line">mouse: enabled=0</span><br><span class="line">keyboard: keymap=/home/ba/bochs/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line"></span><br><span class="line"># 设置硬盘</span><br><span class="line">ata0: enabled=1,ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14</span><br><span class="line"></span><br><span class="line"># 启动盘信息</span><br><span class="line">ata0-master: type=disk, path=&quot;hd60M.img&quot;, mode=flat</span><br></pre></td></tr></table></figure>
<p>硬盘信息配置好了之后我们初步的配置就已经搞定了，接下来我们在此启动一下试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/bochs -f bochsrc.disk</span><br></pre></td></tr></table></figure></p>
<p>通过-f 可以直接指定我们的配置文件的名称，如果嫌麻烦，每次必须进入bochs文件下，都要输入这么多字的话，可以直接用别名来代替</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .bashrc</span><br><span class="line"></span><br><span class="line">alias bochs=&apos;/home/ba/bochs/bin/bochs -f /home/ba/bochs/bochsrc.disk&apos;</span><br><span class="line"></span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/l1BJ1LjmA4.png?imageslim" alt="mark"></p>
<p>当然，路径得改成你们自己的。接下来我们就可以在任意路径下输入bochs运行我们的虚拟机啦，此时如果你想运行看看结果的话，大概就是这样吧</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/2cbA07A8I7.png?imageslim" alt="mark"></p>
<p>咳咳，这样其实说明一切都准备好了，属于正常现象，如果不是这样，可能您需要回头再看看自己是不是哪里配置出现了问题。</p>
<p>出现这用错误的原因是因为我们现在的硬盘还只是一个空的硬盘，没有任何数据，又如何能够运行呢，从图上可以看到，CPU一下就跑没影了。在我们平时开机的时候，是不是都要通过BIOS引导，进行硬件，内存的各项检测之后，再将我们的操作系统从硬盘上唤醒。此时操作系统才接管了我们的电脑。我们的配置讲完了，关于主引导的编写可能要等我研究透了之后再和大家分享啦</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/memory_paging/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/memory_paging/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">五. 开启分页机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 18:21:18" itemprop="dateCreated datePublished" datetime="2018-04-22T18:21:18+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么有进行内存分页"><a href="#为什么有进行内存分页" class="headerlink" title="为什么有进行内存分页"></a>为什么有进行内存分页</h1><p>目前我们的小kernel还一直在分段机制下工作，因为还只有一个loader在内存中跑，所以不会出现内存不足的问题。假如说此时未开启分页功能，而物理内存空间又不足了，如下图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180415/09jlI1BKjC.png?imageslim" alt="mark"></p>
<p>此时进程C想要执行，但是内存空间已经不足。要么就等待进程A或者进程B执行完成，这样就有连续的内存空间了。要么就讲进程A的A3段或者进程B的B1段换到硬盘上，腾出一部分空间，同样可以容纳进程C执行</p>
<p>等待是极其不好的用户体验，那么只能将段置换到硬盘上了，但是段的大小并不固定，如何段过大，那么IO操作过多，机器的响应速度就会非常慢。</p>
<p>出现这种情况的本质其实是在分段机制下，线性地址等价于物理地址。那么即使在进程B的下面还有10M的可用空间，但因为两块可用空间并不连续，所以进程C无法使用进程B下面的10M可用空间。</p>
<p>按照这种思路，只需要通过某种映射关系，将线性地址映射到任意的物理地址，就可以解决这种问题了。实现线性地址的连续，而物理地址不需要连续，于是分页机制就诞生了。</p>
<h1 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h1><p>分页机制是工作在分段机制下的，在保护模式下，通过选择子找到段基址，通过段基址：段内偏移的方式组合成线性地址，拿到线性地址之后会根据是否开启分页来找到实际的物理地址，用一副图来解释更加清晰</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180415/a16IBcee48.png?imageslim" alt="mark"></p>
<p>分页机制的作用有两方面</p>
<ol>
<li>将线性地址转换成物理地址</li>
<li>用大小相等的页代替大小不等的段</li>
</ol>
<p>如图所示：</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180415/hbI3Hf3d7K.png?imageslim" alt="mark"></p>
<p>需要通过分页机制来映射的线性地址便有了一个高大上的名字，虚拟地址</p>
<p>假设我们通过逐字节的映射方式</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180415/5gmc02DDkK.png?imageslim" alt="mark"></p>
<p>那么页表中会存放4GB个页表项，页表的大小=4GB*4=16GB，这样显然不合理，一页不能只占1B</p>
<p>我们需要平衡页的大小与页的数量的关系，因为页大小*页数量=4GB，想要减少页表的大小，只能增加一页的大小。最终通过数学求极限，定下4KB为最佳页大小</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180415/LHdD85fKf2.png?imageslim" alt="mark"></p>
<p>这种情况下，4GB的内存被划分为1MB个内存块，每个内存块的大小为4KB，</p>
<p>页表和内存的映射关系如图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180415/kHafg62JD3.png?imageslim" alt="mark"></p>
<p>有了页表之后，如何将线性地址转换成物理地址呢？</p>
<p>在一级页表下，线性地址的高20位被用作页表项的索引，也就是类似于数组下标的东西。通过该索引在页表中找到对应页的物理地址，然后将该物理地址+线性地址的低12位组成真正的物理地址。过程如图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180417/14e4C8BEBD.png?imageslim" alt="mark"></p>
<h1 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h1><p>无论是几级页表，标准页的尺寸都是4KB，这个是不会变的。所以4GB的线性地址空间最多有1M个标准页。一级页表是将这1M个标准页放置到一张页表中，二级页表是将这1M个标准页平均放置1K个页表中，每个页表包含有1K个页表项。页表项是4字节大小，故页表的大小同样为4KB</p>
<p>既然将原本的一个页表划分出了1K个页表，这些页表就必须进行统一管理。为此，专门有一个页目录表来存放这些页表。页目录表中存储的页表称为页目录项(PDE), 页目录项同样为4KB，且最多有1K个页目录项，所以页目录表也是4KB</p>
<p>二级页表的模型如图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180417/ilmHmgmeGG.png?imageslim" alt="mark"></p>
<p>二级页表与一级页表原理虽然相同，但在结构上有了很大的差异，所以虚拟地址到物理地址的转换方式上也发生了很大变化</p>
<p>首先通过虚拟地址的高10位在页目录表中定位一个页表，也就是定位也目录项</p>
<p>然后通过虚拟地址的中间10位在之前定位的页表中找到物理页所在的位置</p>
<p>最后虚拟地址剩下的12位作为找到的物理页的页内偏移</p>
<p>地址转换过程如图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180417/LE68eLDE95.png?imageslim" alt="mark"></p>
<h1 id="PDE与PTE的结构"><a href="#PDE与PTE的结构" class="headerlink" title="PDE与PTE的结构"></a>PDE与PTE的结构</h1><p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180417/Hd12DBhm9h.png?imageslim" alt="mark"></p>
<p>P位：存在位，为1时表示该页在内存中<br>RW：读写位，为1时可读可写，为0是可读不可写<br>US：普通用户/超级用户位，为1时表示处于用户级，也就是3级特权级<br>PWT：页级通写位，为1表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存<br>PCD：页级高速缓存禁止位，为1表示该页启用高速缓存<br>A：访问位，为1表示该页被CPU访问过<br>D：脏页位，当CPU对一个页面执行写操作，此为被赋1<br>PAT：页属性表位，能够在页面一级的粒度上设置内存属性<br>G：全局位，为1表示该页在高速缓存TLB中一直保存</p>
<h1 id="启用分页机制"><a href="#启用分页机制" class="headerlink" title="启用分页机制"></a>启用分页机制</h1><p>启用分页机制需要完成下面三步</p>
<ol>
<li>准备好页目录表和页表</li>
<li>将页表地址写入控制寄存器Cr3</li>
<li>将寄存器Cr0的PG位置1</li>
</ol>
<p>创建页目录表和页表<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">----------创建页目录及页表----------</span><br><span class="line"><span class="symbol">setup_page:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">4096</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">.clear_page_dir:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">byte</span> [PAGE_DIR_TABLE_POS + <span class="built_in">esi</span>], <span class="number">0</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">    <span class="keyword">loop</span> .clear_page_dir</span><br><span class="line"></span><br><span class="line"><span class="symbol">.create_pde:</span>                     </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span>               <span class="comment">; 此时eax为第一个页表的位置及属性</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="built_in">eax</span>                  <span class="comment">; 此处为ebx赋值，是为.create_pte做准备，ebx为基址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   下面将页目录项0和0xc00都存为第一个页表的地址，</span></span><br><span class="line"><span class="comment">;   一个页表可表示4MB内存,这样0xc03fffff以下的地址和0x003fffff以下的地址都指向相同的页表，</span></span><br><span class="line"><span class="comment">;   这是为将地址映射为内核地址做准备</span></span><br><span class="line">    <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P      <span class="comment">; 页目录项的属性RW和P位为1,US为1,表示用户属性,所有特权级别都可以访问.</span></span><br><span class="line">    <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0x0</span>], <span class="built_in">eax</span>       <span class="comment">; 第1个目录项,在页目录表中的第1个目录项写入第一个&gt;页表的位置(0x101000)及属性(7)</span></span><br><span class="line">    <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">0xc00</span>], <span class="built_in">eax</span>     <span class="comment">; 一个页表项占用4字节,0xc00表示第768个页表占用的目录项,0xc00以上的目录项用于内核空间,</span></span><br><span class="line">                             <span class="comment">; 也就是页表的0xc0000000~0xffffffff共计1G属于内核,0x0~0xbfffffff共计3G属于用户进程.</span></span><br><span class="line">    <span class="keyword">sub</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">    <span class="keyword">mov</span> [PAGE_DIR_TABLE_POS + <span class="number">4092</span>], <span class="built_in">eax</span>      <span class="comment">; 使最后一个目录项指向页目录表自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;下面创建页表项(PTE)</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">256</span>                  <span class="comment">; 1M低端内存 / 每页大小4k = 256</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, PG_US_U | PG_RW_W | PG_P         <span class="comment">; 属性为7,US=1,RW=1,P=1</span></span><br><span class="line"><span class="symbol">.create_pte:</span>                     </span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>],<span class="built_in">edx</span>               <span class="comment">; 此时的ebx已经在上面通过eax赋值为0x101000,也就是第一个页表的地址 </span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">edx</span>,<span class="number">4096</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">esi</span> </span><br><span class="line">    <span class="keyword">loop</span> .create_pte</span><br><span class="line"><span class="comment">;创建内核其它页表的PDE</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x2000</span>           <span class="comment">; 此时eax为第二个页表的位置</span></span><br><span class="line">    <span class="keyword">or</span> <span class="built_in">eax</span>, PG_US_U | PG_RW_W | PG_P  <span class="comment">; 页目录项的属性US,RW和P位都为1</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, <span class="number">254</span>              <span class="comment">; 范围为第769~1022的所有目录项数量</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esi</span>, <span class="number">769</span></span><br><span class="line"><span class="symbol">.create_kernel_pde:</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">ebx</span>+<span class="built_in">esi</span>*<span class="number">4</span>], <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">esi</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">eax</span>, <span class="number">0x1000</span></span><br><span class="line">    <span class="keyword">loop</span> .create_kernel_pde</span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 把页目录地址赋给cr3</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, PAGE_DIR_TABLE_POS</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cr3</span>, <span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">; 打开cr0的pg位(第31位)</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="built_in">cr0</span></span><br><span class="line">    <span class="keyword">or</span> <span class="built_in">eax</span>, <span class="number">0x80000000</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cr0</span>, <span class="built_in">eax</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/29/deque/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/29/deque/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">从零开始，打造自己的STL(五、deque)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-29 17:04:18" itemprop="dateCreated datePublished" datetime="2018-03-29T17:04:18+08:00">2018-03-29</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="deque简介"><a href="#deque简介" class="headerlink" title="deque简介"></a>deque简介</h1><p>deque是双向开口的连续线性空间，支持内部元素的随机访问。看到这个概念，相信大家一定会想起vector，vector是单向开口的连续线性空间，内部元素也是可以随机访问的。</p>
<p>deque的元素类似这样</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180329/d4e12dJfg3.png?imageslim" alt="mark"></p>
<p>那么deque像比于vector的差异在哪里</p>
<ol>
<li>deque的头部插入是vector没有的，虽然从技术角度来讲，vector实现头部插入也不是很难，但是效率太低，不值得且没必要</li>
<li>除了一些极端情况下，deque的空间是不需要重新分配的。大家都知道，vector在空间不足的时候，会重新分配一块新的空间，然后将原空间的数据全部copy进去，这个操作其实是非常低效率的。而deque在空间不足的时候，只需要再分配一块空间，并将这块空间链接到原空间上，具体怎么链接，基本上就是deque核心的东西了</li>
<li>deque的排序效率非常低，所以一般是将deque的数据copy到vector中，排好序之后再copy回来</li>
<li>deque同样支持元素的随机访问，这个要归功于其迭代器设计的精妙之处，不像vector，vector的迭代器本身就是元素类型的指针，只是因为他的内存结构，所以能够支持元素的随机访问</li>
</ol>
<h1 id="deque的内存结构"><a href="#deque的内存结构" class="headerlink" title="deque的内存结构"></a>deque的内存结构</h1><p>相信大家对deque如何将一块新空间链接到原空间上非常感兴趣，当时我学deque时也是这样，真正看了deque的源码之后，内心真正的感受是，还有这种操作(手动黑人问号)</p>
<p>下面先看一张deque的内存结构图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180329/lIf0faKlDm.png?imageslim" alt="mark"></p>
<p>首先，deque设计了一块map的映射区域，这块map本质就是元素类型的二级指针，并且用了一块连续的空间来存放这些二级指针，每一个二级指针就会指向一块数据的缓冲区，这样当所有的数据区域都分配完了之后，只需要重新再分配一块空间，并使得map的一块区域指向这块空间即可，这样就成功的将新空间链接上了原空间。</p>
<p>如果map的所有空间都已经映射满了，此时再新增空间的话，就要重新分配map的空间，其分配策略和vector类似，接下来将map中的指针域copy至新空间即可，而数据域是不需要改变的。</p>
<h1 id="deque的空间分配"><a href="#deque的空间分配" class="headerlink" title="deque的空间分配"></a>deque的空间分配</h1><h2 id="deque中数据区的大小"><a href="#deque中数据区的大小" class="headerlink" title="deque中数据区的大小"></a>deque中数据区的大小</h2><p>看了上面的内存结构之后不知道大家有没有一个疑问，数据区的内存要分配多大呢？因为数据区中一块空间的大小是固定的，它并不会动态的增长，我们分配了多大的空间就固定了它能存储的数据量，当这块空间用完了之后就只能再分配一块的数据区</p>
<p>再SGI的STL中是这样设计的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> _Deque_buf_size(<span class="keyword">size_t</span> _size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _size &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span> / _size) : <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数size为元素类型的大小，比如int就是4B，也就是说一块数据区就可以存128个int的数据，512是一个写死的魔数。当然，我们自己也可以将512这个基数通过模板参数传递，让我们自己决定分配多大</p>
<h2 id="deque的内存分配"><a href="#deque的内存分配" class="headerlink" title="deque的内存分配"></a>deque的内存分配</h2><p>deque的内存分配方式分两步走，下面我们将一块数据区的空间称为node</p>
<ol>
<li>分配map</li>
<li>分配node</li>
</ol>
<p>具体怎么分配的我们从源码上了解最为直观</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Deque_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator _m_start;			<span class="comment">// 第一个有效node的位置</span></span><br><span class="line">	iterator _m_finish;			<span class="comment">// 最后一个有效node的位置</span></span><br><span class="line">	_Tp** _m_map;</span><br><span class="line">	<span class="keyword">size_t</span> _m_map_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map的大小默认为8, 超过8时为nodes+2 -- 使得map不会被占满</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> _Deque_base&lt;_Tp, _Alloc&gt;::_M_initialize_map(<span class="keyword">size_t</span> _num_elements)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> _num_nodes = _num_elements / _Deque_buf_size(<span class="keyword">sizeof</span>(_Tp)) + <span class="number">1</span>;</span><br><span class="line">	_m_map_size = _S_initial_map_size &gt; _num_nodes + <span class="number">2</span> ? _S_initial_map_size : _num_nodes + <span class="number">2</span>;</span><br><span class="line">	_m_map = _M_allocate_map(_m_map_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使得start和finish所夹的空间尽量在整个空间的中央，使得向两边扩充的区域尽量相等</span></span><br><span class="line">	_Tp** _start = _m_map + (_m_map_size - _num_nodes) / <span class="number">2</span>;</span><br><span class="line">	_Tp** _finish = _start + _num_nodes;</span><br><span class="line"></span><br><span class="line">	_M_create_nodes(_start, _finish);</span><br><span class="line">	_m_start._M_set_node(_start);</span><br><span class="line">	_m_finish._M_set_node(_finish - <span class="number">1</span>);</span><br><span class="line">	_m_start._m_cur = _m_start._m_first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// finish.cur 指向的是有效元素的后一个位置</span></span><br><span class="line">	_m_finish._m_cur = _m_finish._m_first + _num_elements % _Deque_buf_size(<span class="keyword">sizeof</span>(_Tp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中应该展现了不少分配的细节</p>
<ol>
<li>首先根据元素的个数和元素类型的大小决定所需node的个数</li>
<li>根据node的个数决定map的大小</li>
<li>分配map</li>
<li>start和finish所夹的空间为整个map的中心，</li>
<li>分配node</li>
</ol>
<p>看看分配node的详细代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> _Deque_base&lt;_Tp, _Alloc&gt;::_M_create_nodes(_Tp** _start, _Tp** _finish)</span><br><span class="line">&#123;</span><br><span class="line">	_Tp** _cur;</span><br><span class="line">	<span class="keyword">for</span> (_cur = _start; _cur != _finish; ++_cur)</span><br><span class="line">	&#123;</span><br><span class="line">		*_cur = _M_allocate_node();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Tp *_M_allocate_node()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _Node_alloc_type::allocate(_Deque_buf_size(<span class="keyword">sizeof</span>(_Tp)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> _<span class="function">TP* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> == _n ? <span class="literal">nullptr</span> : (_TP*)_Alloc::allocate(_n * <span class="keyword">sizeof</span>(_TP));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看到map中的[start, finish)区域分别存了每个node的指针，也就实现了map管理node，以后就可以直接通过map访问node了</p>
<h1 id="deque的迭代器实现"><a href="#deque的迭代器实现" class="headerlink" title="deque的迭代器实现"></a>deque的迭代器实现</h1><p>从deque的内存结构中可以看到，deque中的空间并不像vector那样是完全连续的空间，只是一个node中的空间是连续的，那么如何实现对deque中元素的随机访问呢，这个就要归功于deque的iterator了，我们来看一下iterator的实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Ref, <span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Deque_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	_Tp *_m_cur;			<span class="comment">// 指向当前node的  当前位置		</span></span><br><span class="line">	_Tp *_m_first;			<span class="comment">// 指向当前node的  开始位置</span></span><br><span class="line">	_Tp *_m_last;			<span class="comment">// 指向当前node的  最后空间的下一个位置</span></span><br><span class="line">	_Map_pointer _m_node;	<span class="comment">// 指向当前node所在map</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过该函数来跳到另一个缓冲区</span></span><br><span class="line">	<span class="keyword">void</span> _M_set_node(_Map_pointer _new_node)</span><br><span class="line">	&#123;</span><br><span class="line">		_m_node = _new_node;</span><br><span class="line">		_m_first = *_new_node;</span><br><span class="line">		_m_last = _m_first + difference_type(_S_buffer_size());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](difference_type _index)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *(*<span class="keyword">this</span> + _index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    _Self <span class="keyword">operator</span>+(difference_type _n)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		_Self _tmp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> _tmp += _n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Self&amp; <span class="keyword">operator</span>+=(difference_type _n)</span><br><span class="line">	&#123;</span><br><span class="line">		difference_type _offset = _n + (_m_cur - _m_first);</span><br><span class="line">		<span class="keyword">if</span> (_offset &gt;= <span class="number">0</span> &amp;&amp; _offset &lt; difference_type(_S_buffer_size()))</span><br><span class="line">			_m_cur += _n;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//需要跳到另一个node中</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 计算向上或向下的node偏移量</span></span><br><span class="line">			difference_type _node_offset = _offset &gt; <span class="number">0</span> ? _offset / difference_type(_S_buffer_size()) :</span><br><span class="line">				-difference_type((-_offset - <span class="number">1</span>) / _S_buffer_size()) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			_M_set_node(_m_node + _node_offset);</span><br><span class="line">			_m_cur = _m_first + (_offset - _node_offset * difference_type(_S_buffer_size()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对元素的随机访问的操作方式是通过obj[num]来实现的，也就是说我们要实现operator[]操作符，代码中可以看到，op[]是通过op+=()实现的，我们重点也就看op+=()了。</p>
<p>通过一副图来解释一下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180329/H507g75LFd.png?imageslim" alt="mark"></p>
<p>假设我们的偏移大于了一个node的总空间， 也就是n+(cur-start)&gt;_Deque_buf_size(sizeof(_Tp))，此时我们需要调到下一个node之中，可能是向下跳，也可能是向上跳，我们就用向下来举例，此时通过set_node函数调到下一个node之中，访问到我们想访问的元素了。所谓的跳到下一个node，也就是改变了当前node所在map中的指向而已。</p>
<h1 id="deque的构造"><a href="#deque的构造" class="headerlink" title="deque的构造"></a>deque的构造</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(size_type _n, const_reference _value,) : _Base(_n)</span><br><span class="line">&#123;</span><br><span class="line">	_M_fill_initialize(_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个构造函数再来理一下我们之前说的空间分配和迭代器</p>
<p>首先通过deque的基类分配空间<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_Deque_base(<span class="keyword">size_t</span> _num_elements)</span><br><span class="line">	:_m_start(), _m_finish(), _m_map(<span class="literal">nullptr</span>), _m_map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_M_initialize_map(_num_elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map的大小默认为8, 超过8时为nodes+2 -- 使得map不会被占满</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> _Deque_base&lt;_Tp, _Alloc&gt;::_M_initialize_map(<span class="keyword">size_t</span> _num_elements)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">size_t</span> _num_nodes = _num_elements / _Deque_buf_size(<span class="keyword">sizeof</span>(_Tp)) + <span class="number">1</span>;</span><br><span class="line">	_m_map_size = _S_initial_map_size &gt; _num_nodes + <span class="number">2</span> ? _S_initial_map_size : _num_nodes + <span class="number">2</span>;</span><br><span class="line">	_m_map = _M_allocate_map(_m_map_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使得start和finish所夹的空间尽量在整个空间的中央，使得向两边扩充的区域尽量相等</span></span><br><span class="line">	_Tp** _start = _m_map + (_m_map_size - _num_nodes) / <span class="number">2</span>;</span><br><span class="line">	_Tp** _finish = _start + _num_nodes;</span><br><span class="line"></span><br><span class="line">	_M_create_nodes(_start, _finish);</span><br><span class="line">	_m_start._M_set_node(_start);</span><br><span class="line">	_m_finish._M_set_node(_finish - <span class="number">1</span>);</span><br><span class="line">	_m_start._m_cur = _m_start._m_first;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// finish.cur 指向的是有效元素的后一个位置</span></span><br><span class="line">	_m_finish._m_cur = _m_finish._m_first + _num_elements % _Deque_buf_size(<span class="keyword">sizeof</span>(_Tp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码分配好了map和node的空间之后，接下来就是对元素的值进行填充了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;_Tp, _Alloc&gt;::_M_fill_initialize(const_reference _value)</span><br><span class="line">&#123;</span><br><span class="line">	_map_pointer _cur;</span><br><span class="line">	<span class="keyword">for</span> (_cur = _m_start._m_node; _cur &lt; _m_finish._m_node; ++_cur)</span><br><span class="line">		uninitialized_fill(*_cur, *_cur + _S_buffer_size(), _value);</span><br><span class="line">	</span><br><span class="line">	uninitialized_fill(_m_finish._m_first, _m_finish._m_cur, _value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180329/m7lgbaDA5D.png?imageslim" alt="mark"></p>
<p>填充分两步走，先将所有要填满的node进行填充，再填充剩余的</p>
<h1 id="deque的map重分配策略"><a href="#deque的map重分配策略" class="headerlink" title="deque的map重分配策略"></a>deque的map重分配策略</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _M_reserve_map_at_back(size_type _node_to_add = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (_node_to_add + <span class="number">1</span> &gt; _m_map_size - (_m_finish._m_node - _m_map))</span><br><span class="line">		_M_reallocate_map(_node_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _M_reserve_map_at_front(size_type _node_to_add = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (_node_to_add &gt; size_type(_m_start._m_node - _m_map))</span><br><span class="line">		_M_reallocate_map(_node_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_reallocate_map(size_type _node_to_add, <span class="keyword">bool</span> _add_at_front);</span><br></pre></td></tr></table></figure>
<p>map的空间重分配分两种情况</p>
<ol>
<li>在头部添加数据的时候发现前面空间不足</li>
<li>在尾部添加数据时发现尾部空间不足</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">deque</span>&lt;_Tp, _Alloc&gt;::_M_reallocate_map(size_type _node_to_add, <span class="keyword">bool</span> _add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">	size_type _old_num_nodes = _m_finish._m_node - _m_start._m_node + <span class="number">1</span>;</span><br><span class="line">	size_type _new_num_nodes = _old_num_nodes + _node_to_add;</span><br><span class="line"></span><br><span class="line">	_map_pointer _new_start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  <span class="doctag">TODO:</span> 当向某一边添加元素过多时，会导致一边的空间被占满，而另一边还有很多空间，这个时候只需要调整</span></span><br><span class="line">	<span class="comment">// TODO： start 和 finish的指向，使其尽量在整个空间的中间，即可满足条件。不需要重新分配空间</span></span><br><span class="line">	<span class="keyword">if</span> (_m_map_size &gt; <span class="number">2</span> * _new_num_nodes)</span><br><span class="line">	&#123;</span><br><span class="line">		_new_start = _m_map + (_m_map_size - _new_num_nodes) / <span class="number">2</span> + (_add_at_front ? _node_to_add : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (_new_start &lt; _m_start._m_node)</span><br><span class="line">			copy(_m_start._m_node, _m_finish._m_node + <span class="number">1</span>, _new_start);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			copy_backward(_m_start._m_node, _m_finish._m_node + <span class="number">1</span>, _new_start + _old_num_nodes);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		size_type _new_map_size = _m_map_size + </span><br><span class="line">			(_m_map_size &gt; _node_to_add ? _m_map_size : _node_to_add) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		_map_pointer _new_map = _M_allocate_map(_new_map_size);</span><br><span class="line">		_new_start = _new_map + (_new_map_size - _new_num_nodes) / <span class="number">2</span> +</span><br><span class="line">			(_add_at_front ? _node_to_add : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		copy(_m_start._m_node, _m_finish._m_node + <span class="number">1</span>, _new_start);</span><br><span class="line">		_M_deallocate_map(_m_map);</span><br><span class="line"></span><br><span class="line">		_m_map = _new_map;</span><br><span class="line">		_m_map_size = _new_map_size;</span><br><span class="line">	&#125;</span><br><span class="line">	_m_start._M_set_node(_new_start);</span><br><span class="line">	_m_finish._M_set_node(_new_start + _old_num_nodes - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>在添加数据时发现空间不足时并不是一定会对map的空间重新尽心分配，如果一直在尾部添加数据，发现空间不足时，回去检测头部是否有足够的空间，如果有，则直接调整[start, finish)在map中的位置，使其处于map的中间，使map的空间相对平衡，也就不需要重新分配map空间了。</p>
<p>在map的空间实在不足的时候，重新分配map空间，大小为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type _new_map_size = _m_map_size + </span><br><span class="line">			(_m_map_size &gt; _node_to_add ? _m_map_size : _node_to_add) + <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>再将原map中的数据copy到现在的map中即可，当然[start, finish)依然处于新map的中心处</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/vector/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/28/vector/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">从零开始，打造自己的STL(二、vector)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-28 04:19:12" itemprop="dateCreated datePublished" datetime="2018-03-28T04:19:12+08:00">2018-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>vector的内存布局以及操作方式与array非常的类似，都是一段连续的内存空间。两者之间唯一的差距就是空间运用的灵活性。array的空间在配置好了之后就无法更改，它所存放的数据量是固定的，一但空间不够用之后需要重新配置一块更大的空间。vector则不然，它的内存空间会随着元素的加入自动扩充新的空间供给使用，这样使用起来就不需要担心空间是否够用了。</p>
<h1 id="vector的内存结构"><a href="#vector的内存结构" class="headerlink" title="vector的内存结构"></a>vector的内存结构</h1><p>vector采用了连续内存空间的布局，那么它如何管理这块内存？如何做到内存的自增长呢？这一切要从它的内存结构来说起</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/9463d4bb5L.png?imageslim" alt="mark"></p>
<p>如上图所示，假如我们此时拥有8*sizeof(int)大小的空间，当然，内部存放的数据也为int了。vector定义了三个指针来管理这块空间。</p>
<p>start指向首元素所在的位置</p>
<p>finish指向最后一个有效元素所在的后一个位置，这样在新增元素的时候直接就可以放在finish所指的位置，然后再将finish自增即可。</p>
<p>end指向最后一个可用空间的后一个位置。</p>
<p>为何end不直接指向最后一个可用空间呢？</p>
<p>其一，当finish==end时，是否表示空间已经用完了呢，如果end指向的是最后一个可用空间的位置，显然此时还剩下最后一个空间没有被使用，这样对空间用尽的判断就不是很方便。其二，在我们遍历元素时，end指向可用空间的后一个位置能更加方便的作为循环的结束条件，岂不是非常的方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(; first != last; ++first)</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p>
<p>这个应该就是STL中的前闭后开区间设计出来的原因吧，STL中的所有容器皆是采用的前闭后开区间的表示方法</p>
<p>说完了前闭后开区间，接下来说说start，finish这些是个什么东东<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    _Tp* _start;</span><br><span class="line">    _Tp* _finish;</span><br><span class="line">    _Tp* _end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是这三个东东在STL源码当中的定义，他们皆是模板类型_Tp的指针，分别指向不同的位置而已。其实这三个东西也就是vector的迭代器了。因为vector本身内存布局的简单性，只需要通过原生指针就可以对里面的元素进行遍历与访问了。对于某些复杂的容器，他的迭代器可能也会是一个封装好的类。但是所有迭代器的功能都是一样的。提供对容器元素的访问</p>
<h1 id="vector的空间配置"><a href="#vector的空间配置" class="headerlink" title="vector的空间配置"></a>vector的空间配置</h1><p>看懂了vector中内存的布局，那么接下来来看看vector中的空间究竟是如何分配。首先就从vector的构造函数开始吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    vector(const _Alloc&amp;):_m_start(nullptr), _m_finish(nullptr), _m_end(nullptr)&#123;&#125;</span><br><span class="line">    vector(size_t _n, const _Alloc&amp;) :_m_start(nullptr), _m_finish(nullptr), _m_end(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">	_m_start = _M_allocate(_n);</span><br><span class="line">	_m_finish = _m_start;</span><br><span class="line">	_m_end = _m_start + _n;</span><br><span class="line">    &#125; </span><br><span class="line">protected:</span><br><span class="line">    _Tp *_m_start;</span><br><span class="line">    _Tp *_m_finish;</span><br><span class="line">    _Tp *_m_end;</span><br><span class="line"></span><br><span class="line">    typedef simple_alloc&lt;_Tp, _Alloc&gt; _m_data_allocator;</span><br><span class="line"></span><br><span class="line">    _Tp* _M_allocate(size_t _n)</span><br><span class="line">    &#123;</span><br><span class="line">	return _m_data_allocator::allocate(_n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们先看两个简单一点的构造，第一个构造函数简单粗暴，啥也没做。第二个构造函数其实就是分配了n*sizeof(Tp)大小的空间，大家可以吧_M_allocate这个函数想象成malloc。具体内容涉及到分配器的东西，留到下一章分享。</p>
<p>vector的底层通过malloc分配空间（或者也可能是operator new）。众所周知，malloc函数是不会调用类的构造函数的。如果我传递进去的模板参数是一个类类型，这样岂不是出大问题了。其实不然，STL直接将空间分配与元素构造分离开来。对于内置类型，无需进行构造的调用一个方法，需要进行构造的类型调用另一个方法，这样岂不是极大的提高了效率。</p>
<p>空间已经分配好了，接下来该进行元素的填充了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector(size_type _n, const value_type &amp;_val):_Base(_n)</span><br><span class="line">&#123;</span><br><span class="line">    _m_finish = uninitialized_fill_n(_m_start, _n, _val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个构造函数通过其基类先分配好n个大小的空间，在通过填充函数在这n个空间中填充值val并改变finish的指向。所有带uninitialized开头的是一套函数。故名思议，是对未初始化的元素进行的操作。何叫未初始化，就是未进行构造的元素。当然，它内部会有一套机制（POD）来确定该种类型的元素是否需要进行构造。因为其机制较为复杂，我们先只看需要构造的函数如何实现。其实这两者之前并无本质区别，只是在效率上进行了优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _ForwardIter, typename _Size, typename _Tp&gt;</span><br><span class="line">_ForwardIter uninitialized_fill_n(_ForwardIter _first, _Size _n, const _Tp&amp; _val)</span><br><span class="line">&#123;</span><br><span class="line">	_ForwardIter _cur = _first;</span><br><span class="line">	for (; _n &gt; 0; --_n, ++_cur)</span><br><span class="line">		construct(&amp;*_cur, _val);</span><br><span class="line"></span><br><span class="line">	return _cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数其实非常简单易懂，在进行元素构造的时候&amp;*cur这种操作可能会使人有些费解，实际上，它是先调用了迭代器的operator<em>()，再取的地址。具体原因如下。迭代器的op</em>()操作都是取出其中的数据元素，而我们此时显然要对迭代器中的数据进行操作。而直接取一个迭代器的地址并不能代表其中的数据地址。进行构造的底层实现通过placement new完成。</p>
<h1 id="vector的元素操作"><a href="#vector的元素操作" class="headerlink" title="vector的元素操作"></a>vector的元素操作</h1><h2 id="一-添加元素"><a href="#一-添加元素" class="headerlink" title="一. 添加元素"></a>一. 添加元素</h2><p>添加元素整体分为两种情况：空间充足与空间不充足。</p>
<p>如果空间足够，自然就很好解决了，直接将这些元素填充到后面的空间中，再改变finish的指向即可。</p>
<p>如果空间不够，这就要涉及到vector空间自增长的奥秘了。其实原理非常的简单，重新申请一块新空间，将原空间的数据copy进新空间，添加数据，销毁原空间。做法其实和array空间不够时一样，只是vector将其封装好了之后就不需要我们操心这么多了。当然，空间的增长也是需要一定的技巧的。不然我每次空间不够，都只申请比原空间大1的空间，这样反复的申请释放极大的浪费效率，不值当。在vector中，每次的自增长都会是原空间的两倍，甚至更多。源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type _old_size = size();</span><br><span class="line">size_type _len = _old_size + (_old_size &gt; _n ? _old_size : _n);</span><br></pre></td></tr></table></figure></p>
<p>在vector中，添加元素一般通过接口push_back()完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const value_type &amp;_val)</span><br><span class="line">&#123;</span><br><span class="line">	insert(end(), 1，_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该操作即为在末尾处插入一个新元素，会调用下面的insert接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void inset(iterator _pos, size_type _n, const value_type &amp;_val)</span><br><span class="line">&#123;</span><br><span class="line">    if ((size_type)(_m_end - _m_finish) &lt; _n) // 空间不够</span><br><span class="line">    &#123;</span><br><span class="line">        size_type _old_size = size();</span><br><span class="line">	size_type _len = _old_size + (_old_size &gt; _n ? _old_size : _n);</span><br><span class="line">	iterator _new_start = _M_allocate(_len);</span><br><span class="line">        // 拷贝[begin,pos)到new_start处</span><br><span class="line">	iterator _new_finish = uninitialized_copy(begin(), _pos, _new_start);</span><br><span class="line">	_new_finish = uninitialized_fill_n(_new_finish, _n, _val);</span><br><span class="line">	_new_finish = uninitialized_copy(_pos, end(), _new_finish);</span><br><span class="line">			</span><br><span class="line">	destroy(begin(), end());</span><br><span class="line">	_M_deallocate(_m_start);</span><br><span class="line">	_m_start = _new_start;</span><br><span class="line">	_m_finish = _new_finish; </span><br><span class="line">	_m_end = _m_start + _len;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ((size_type)(_m_finish - _pos) &lt; _n)// 填充的值部分需要构造的情况</span><br><span class="line">    &#123;</span><br><span class="line">	size_type _elems_after = _m_finish - _pos;</span><br><span class="line">	uninitialized_fill_n(_m_finish, _n - _elems_after, _val);</span><br><span class="line"></span><br><span class="line">	iterator _old_finish = _m_finish;</span><br><span class="line">	_m_finish += (_n - _elems_after);</span><br><span class="line"></span><br><span class="line">	uninitialized_copy(_pos, _old_finish, _m_finish);</span><br><span class="line">	_m_finish += _elems_after;</span><br><span class="line">	fill(_pos, _old_finish, _val);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (0 &lt; _n) // 空间够, 填充的值不需要构造的情况</span><br><span class="line">    &#123;</span><br><span class="line">	uninitialized_copy(_m_finish - _n, _m_finish, _m_finish);</span><br><span class="line">	iterator _old_finish = _m_finish;</span><br><span class="line">	_m_finish += _n;</span><br><span class="line">	copy_backward(_pos, _old_finish - _n, _old_finish);</span><br><span class="line">	fill_n(_pos, _n, _val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在进行插入操作的时候整体分为两种情况，空间充足和空间不充足的情况。空间足够的时候又分为两种。插入的元素需要进行构造和不需要进行构造的情况。<br>上面提到过，STL中空间的分配和元素的构造是分离开来的，下面以两幅图来解释一下什么是部分需要构造和不需要构造</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/6gj395cbC5.png?imageslim" alt="mark"></p>
<p>假如在此种情况下，我需要在pos处插入n个元素，那么肯定需要把[pos, finish) 处的元素像后移动n位，再从pos开始填充n个val。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/mmBlb6g4Ik.png?imageslim" alt="mark"></p>
<p>从代码中可以看到</p>
<ol>
<li><p>先将finish处也就是图中的old_finish处构造填充了值val</p>
</li>
<li><p>改变finish的指向之后，再将[pos, old_finish) 出的元素构造拷贝到现在finish所在的位置</p>
</li>
<li><p>直接填充[pos, old_finish) 的值为val。此时并没有调用需要进行构造的函数（uninitialized系列）<br>图中红色的代表需要进行构造的位置，可以看到，是否进行构造针对的是地址空间，而不是元素的值。<br>当然，对于push_back()这个函数来说，它永远只可能出现空间不足或者填充的元素需要进行构造的情况。</p>
</li>
</ol>
<h2 id="二-删除元素"><a href="#二-删除元素" class="headerlink" title="二. 删除元素"></a>二. 删除元素</h2><p>删除元素相对来说简单一点，因为它不会改变原有的空间，只需要将待删除元素的后面的元素向前移动即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void pop_back()</span><br><span class="line">&#123;</span><br><span class="line">	erase(end() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterator erase(iterator _pos)</span><br><span class="line">&#123;</span><br><span class="line">	if (_pos + 1 != end())</span><br><span class="line">	    copy(_pos + 1, _m_finish, _pos);</span><br><span class="line"></span><br><span class="line">	--_m_finish;</span><br><span class="line">	destroy(_m_finish);</span><br><span class="line">	return _pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除尾部元素的时候，其实仅仅只是改变了一下finish的指向，并调用了一下析构函数，代码中的destroy并不是释放了那块元素空间。而且对于单个的元素来说，它的空间并不能被释放。可想而知，pop_back()的效率还是相当之高的。</p>
<h2 id="三-元素访问"><a href="#三-元素访问" class="headerlink" title="三. 元素访问"></a>三. 元素访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">iterator begin()</span><br><span class="line">&#123;</span><br><span class="line">	return _m_start;</span><br><span class="line">&#125;</span><br><span class="line">const_iterator begin() const</span><br><span class="line">&#123;</span><br><span class="line">	return _m_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iterator end()</span><br><span class="line">&#123;</span><br><span class="line">	return _m_finish;</span><br><span class="line">&#125;</span><br><span class="line">const_iterator end()const</span><br><span class="line">&#123;</span><br><span class="line">	return _m_finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse_iterator rbegin()</span><br><span class="line">&#123;</span><br><span class="line">	return reverse_iterator(end());</span><br><span class="line">&#125;</span><br><span class="line">const_reverse_iterator rbegin()const</span><br><span class="line">&#123;</span><br><span class="line">	return const_reverse_iterator(end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse_iterator rend()</span><br><span class="line">&#123;</span><br><span class="line">	return reverse_iterator(begin());</span><br><span class="line">&#125;</span><br><span class="line">const_reverse_iterator rend()const</span><br><span class="line">&#123;</span><br><span class="line">	return const_reverse_iterator(begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_type size()const</span><br><span class="line">&#123;</span><br><span class="line">	return size_type(end() - begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_type max_size()const</span><br><span class="line">&#123;</span><br><span class="line">	return (size_type(-1) / sizeof(value_type));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool empty()const</span><br><span class="line">&#123;</span><br><span class="line">	return _m_start == _m_finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reference at(size_type _n)</span><br><span class="line">&#123;</span><br><span class="line">	return const_cast&lt;reference&gt; (static_cast&lt;const vector&amp;&gt;(*this).at(_n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const_reference at(size_type _n)const</span><br><span class="line">&#123;</span><br><span class="line">	if (_n &lt; size())</span><br><span class="line">		return *(begin() + _n);</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		throw std::out_of_range(&quot;out of array range&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reference front()</span><br><span class="line">&#123;</span><br><span class="line">	return *(begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const_reference front()const</span><br><span class="line">&#123;</span><br><span class="line">	return *(begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reference back()</span><br><span class="line">&#123;</span><br><span class="line">	return *(end() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const_reference back()const</span><br><span class="line">&#123;</span><br><span class="line">	return *(end() - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const_reference operator[](size_type _index)const</span><br><span class="line">&#123;</span><br><span class="line">	return *(begin() + _index);</span><br><span class="line">&#125;</span><br><span class="line">reference operator[](size_type _index)</span><br><span class="line">&#123;</span><br><span class="line">	return *(begin() + _index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_type capacity()</span><br><span class="line">&#123;</span><br><span class="line">	return _m_start == nullptr ? 0 : _m_end - _m_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到，在元素访问中有很多精妙的地方。</p>
<ol>
<li><p>begin() 和 end() 所夹的区间即为有效的元素区间，通过事先设计好的结构可以直接的访问到</p>
</li>
<li><p>有效元素的个数直接通过两个指针相减就直接得出</p>
</li>
<li><p>判断vector是否为空直接通过begin()==end() 就可得出<br>这些实现简单，效率奇高的接口都是通过STL精妙的设计自然得出的</p>
</li>
</ol>
<p>STL设计的精妙和实现的巧妙相信从这里面已经可以管中窥豹，关于里面相信的代码和算法大家可以参照SGI的STL</p>
<p>接下来，我将会分享STL隐藏在幕后的一个组件——空间分配器。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/list/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/28/list/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">从零开始，打造自己的STL(四、list)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-28 04:18:10" itemprop="dateCreated datePublished" datetime="2018-03-28T04:18:10+08:00">2018-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在前面我们看了vector的实现之后相信对容器有了一定的认识。容器即为存放物件之所，它代表着一块空间。想要直观的了解一个容器，那么看懂他的空间分配策略是一个非常有效的入手方式。接下来我们就来看看STL中的list又是如何实现的吧。</p>
<h1 id="list的结构"><a href="#list的结构" class="headerlink" title="list的结构"></a>list的结构</h1><p>list就是我们常说的链表，说到链表相信大家就很熟悉了。非连续空间、通过指针来连接每一个小空间、插入和删除都是O(1)操作，元素访问效率较低等等。。。<br>list采用的结构是双端环形链表，用下面一幅图来形象的表达</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180320/0l3c8cHk2m.png?imageslim" alt="双端环形链表结构"></p>
<p>咳咳，虽然图是丑了点，确也是可以直观的看出它的结构的。图中红色的方框就代表着一块空间，在这块空间中存放了三个东西，第一个东西是下一块空间所在的位置，也就是next指针所指向的位置。第二个是上一块空间所在的位置。第三个就是存放的数据呐。其中有一个特殊的是有一块 <strong>head</strong> 的区域，有人会想这块区域显然就是标识我大链表的头部了。其实它既是链表头，也是链表尾。看一下下面对链表的遍历操作你很块就能理解了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (auto i = head-&gt;next; i != head; ++it)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="list的空间配置"><a href="#list的空间配置" class="headerlink" title="list的空间配置"></a>list的空间配置</h1><p>list的空间配置呢相对vector就要复杂一点点，vector的空间是一整块一整块分配的，当这一块空间不足够存放我的数据的时候，就重新分配一块*2大小的空间，再将原来的数据搬过来。说了这么多就是想找个对比，没有对比就没有伤害嘛</p>
<p>list是一小块一小块的节点空间，那么每次新增一个节点的时候就要分配一块空间供我们使用。分配多大呢？看一下list的节点的结构就知道那</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct _List_node_base</span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base *_m_next;</span><br><span class="line">	_List_node_base *_m_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename _Tp&gt;</span><br><span class="line">struct _List_node : public _List_node_base</span><br><span class="line">&#123;</span><br><span class="line">	_Tp _m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大家看到这个节点的结构的时候有没有感觉到有一点点奇怪，为什么有两个结构体？</p>
<p>在SGI的STL实现中呢，将list的节点分为了指针域和数据域。为什么要这么划分，当然是有它的好处的。</p>
<p>我们对list的操作中更多的是对节点进行遍历，而访问数据成员总是在我们找到了某个节点的时候。那我们在遍历操作中只存放节点的指针域，而不存放数据是不是很大的节省了空间呢，特别是对于c++来说，这个数据域大多都是我们自定义的类，而一个类所占用的空间可能会很大，不像指针，在32位下一个指针才4bytes</p>
<p>看懂了节点的结构之后，那么它的空间分配也就显而易见了，即每次分配<strong>sizeof(_List_node&lt;_Tp&gt;)</strong> 大小的空间即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">class _List_base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef _Alloc allocator_type;</span><br><span class="line"></span><br><span class="line">	_List_base()</span><br><span class="line">	&#123;</span><br><span class="line">		_m_head = _M_get_node();</span><br><span class="line">		_m_head-&gt;_m_next = _m_head;</span><br><span class="line">		_m_head-&gt;_m_prev = _m_head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~_List_base()</span><br><span class="line">	&#123;</span><br><span class="line">		clear();</span><br><span class="line">		_M_put_node(_m_head);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void clear();</span><br><span class="line">protected:</span><br><span class="line">	typedef simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;</span><br><span class="line"></span><br><span class="line">	_List_node&lt;_Tp&gt; * _M_get_node() // 分配节点空间</span><br><span class="line">	&#123;</span><br><span class="line">		return _Alloc_type::allocate(1);</span><br><span class="line">	&#125;</span><br><span class="line">	void _M_put_node(_List_node&lt;_Tp&gt; *_p) // 释放节点空间</span><br><span class="line">	&#123;</span><br><span class="line">		_Alloc_type::deallocate(_p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_List_node&lt;_Tp&gt;* _m_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码还是比较简单的，_List_base类主要就负责head节点的初始化工作。需要注意的就是传递给分配器的模板参数是 **_List_node&lt;_Tp&gt;，该类型作为simple_alloc的_Tp参数</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180320/CieBhFe8CB.png?imageslim" alt="simple_alloc"></p>
<h1 id="list的元素访问"><a href="#list的元素访问" class="headerlink" title="list的元素访问"></a>list的元素访问</h1><p>明白了list的内存布局之后，我们在看看list的迭代器，看看迭代器是如何实现对其进行元素访问的。</p>
<p>话不多说，先上代码，从源码中见分晓<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct _List_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base* _m_node;</span><br><span class="line"></span><br><span class="line">	_List_iterator_base(_List_node_base *_x) :_m_node(_x)&#123;&#125;</span><br><span class="line">	_List_iterator_base():_m_node(nullptr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	void _M_incr() </span><br><span class="line">	&#123;</span><br><span class="line">		_m_node = _m_node-&gt;_m_next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void _M_decr() </span><br><span class="line">	&#123;</span><br><span class="line">		_m_node = _m_node-&gt;_m_prev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator==(const _List_iterator_base &amp;_x)const</span><br><span class="line">	&#123;</span><br><span class="line">		return _m_node == _x._m_node;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator!=(const _List_iterator_base &amp;_x)const</span><br><span class="line">	&#123;</span><br><span class="line">		return _m_node != _x._m_node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看到第一行的_m_node相信大家应该明白了之前所说的为什么将节点的指针域和数据域分开的原因了吧，在迭代器中只需要指针域，因为迭代器的工作就是访问节点，而不是数据</p>
<p>iteartor的基类做的工作很简单</p>
<ol>
<li>初始化当前节点</li>
<li>提供访问当前节点的相邻节点的接口</li>
<li>提供节点比较的方法</li>
</ol>
<p>有了基类提供的接口之后，迭代器的实现也就很简单了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Ref, typename _Ptr&gt;</span><br><span class="line">struct _List_iterator : public _List_iterator_base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	typedef _List_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;	iterator;</span><br><span class="line">	typedef _List_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt;	const_iterator;</span><br><span class="line">	typedef _List_iterator&lt;_Tp, _Ref, _Ptr&gt;	_Self;</span><br><span class="line"></span><br><span class="line">	typedef _Tp value_type;</span><br><span class="line">	typedef _Ptr pointer;</span><br><span class="line">	typedef _Ref reference;</span><br><span class="line">	typedef _List_node&lt;_Tp&gt; _Node;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	_List_iterator(_Node *_x): _List_iterator_base(_x)&#123;&#125;</span><br><span class="line">	_List_iterator()&#123;&#125;</span><br><span class="line">	_List_iterator(const iterator&amp; _x):_List_iterator_base(_x._m_node)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	reference operator*()const </span><br><span class="line">	&#123;</span><br><span class="line">		return ((_Node*)_m_node)-&gt;_m_data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pointer operator-&gt;()const</span><br><span class="line">	&#123;</span><br><span class="line">		return &amp;(operator*());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Self&amp; operator++()</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;_M_incr();</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Self operator++(int)</span><br><span class="line">	&#123;</span><br><span class="line">		_Self _tmp = *this;</span><br><span class="line">		this-&gt;_M_incr();</span><br><span class="line">		return _tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_Self &amp;operator--()</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;_M_decr();</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line">	_Self operator--(int)</span><br><span class="line">	&#123;</span><br><span class="line">		_Self _tmp = *this;</span><br><span class="line">		this-&gt;_M_decr();</span><br><span class="line">		return _tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在前面定义了一些类型的别名，iterator真正提供的接口就是访问下一个节点(operator++), 访问前一个节点(operator–)以及访问当前节点的数据(operator*)</p>
<p>前期的准备工作都做好了，可以开始看list的具体实现了</p>
<h1 id="list的具体实现"><a href="#list的具体实现" class="headerlink" title="list的具体实现"></a>list的具体实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc = alloc &gt;</span><br><span class="line">class list : protected _List_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">	typedef _List_base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class="line">public:</span><br><span class="line">	typedef _Tp	value_type;</span><br><span class="line">	typedef _Tp* pointer;</span><br><span class="line">	typedef const _Tp*	const_point;</span><br><span class="line">	typedef _Tp&amp;	reference;</span><br><span class="line">	typedef const _Tp&amp;	const_reference;</span><br><span class="line">	typedef  _List_node&lt;_Tp&gt; _Node;</span><br><span class="line">	typedef size_t	size_type;</span><br><span class="line">	typedef ptrdiff_t	difference_type;</span><br><span class="line">	</span><br><span class="line">	typedef _List_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;	iterator;</span><br><span class="line">	typedef _List_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line">	typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">	typedef reverse_iterator&lt;iterator&gt;     reverse_iterator;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">	using _Base::_M_put_node;</span><br><span class="line">	using _Base::_M_get_node;</span><br><span class="line">	using _Base::_m_head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些都是一些别名的定义以及对基类成员和函数的引用，基类的代码在上面有贴出，忘记了的同学可以翻上去看一下</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">list() : _Base()&#123;&#125;</span><br><span class="line"></span><br><span class="line">list(size_type _n, const_reference _value):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _n, _value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(size_type _n):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _n, _Tp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(const_point _first, const_point _last)):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _first, _last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(const_iterator _first, const_iterator _last):_Base()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _first, _last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list(const list&lt;_Tp, _Alloc&gt; &amp;_x):_Base())</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _x.begin(), _x.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别看构造函数好像都与insert函数有关，然后跑去看insert，结果被其吓倒了，其实构造函数无非就做了两件事</p>
<ol>
<li>通过基类初始化head节点</li>
<li>将传递进来的数据插入到list中</li>
</ol>
<p>只是我们提供的构造数据的方式多种多样，就显得比较负责而已，等到后面我们在来了解它到底是如何进行花式插入的</p>
<h2 id="成员访问函数"><a href="#成员访问函数" class="headerlink" title="成员访问函数"></a>成员访问函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">iterator begin()</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head-&gt;_m_next;</span><br><span class="line">&#125;</span><br><span class="line">const_iterator begin()const</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head-&gt;_m_next;</span><br><span class="line">&#125;</span><br><span class="line">iterator end()</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head;</span><br><span class="line">&#125;</span><br><span class="line">const_iterator end()const</span><br><span class="line">&#123;</span><br><span class="line">	return (_Node*)_m_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse_iterator rbegin()</span><br><span class="line">&#123;</span><br><span class="line">	return reverse_iterator(end());</span><br><span class="line">&#125;</span><br><span class="line">const_reverse_iterator rbegin() const</span><br><span class="line">&#123;</span><br><span class="line">	return const_reverse_iterator(end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverse_iterator rend()</span><br><span class="line">&#123;</span><br><span class="line">	return reverse_iterator(begin());</span><br><span class="line">&#125;</span><br><span class="line">const_reverse_iterator rend() const</span><br><span class="line">&#123;</span><br><span class="line">	return const_reverse_iterator(begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool empty()const</span><br><span class="line">&#123;</span><br><span class="line">	return _m_head == _m_head-&gt;_m_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_type size()</span><br><span class="line">&#123;</span><br><span class="line">	size_type _result = 0;</span><br><span class="line">	distance(begin(), end(), _result);</span><br><span class="line">	return _result;</span><br><span class="line">&#125;</span><br><span class="line">size_type max_size()const</span><br><span class="line">&#123;</span><br><span class="line">	return (size_type)(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reference front()</span><br><span class="line">&#123;</span><br><span class="line">	return *begin();</span><br><span class="line">&#125;</span><br><span class="line">const_reference front()const</span><br><span class="line">&#123;</span><br><span class="line">	return *begin();</span><br><span class="line">&#125;</span><br><span class="line">reference back()</span><br><span class="line">&#123;</span><br><span class="line">	return *(--end());</span><br><span class="line">&#125;</span><br><span class="line">const_reference back()const</span><br><span class="line">&#123;</span><br><span class="line">	return *(--end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些统一的接口相信大家一看就懂了。我还是在这里多说几句。reverse_iterator是反向迭代器，意思就是将迭代器的访问顺序反着来，本来我们是从头访问到尾，而它正好相反，这个将在后面来实现，在size()中的distance()函数大家可以这样理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(auto it = begin(); it != end(); ++it)</span><br><span class="line">	++result;</span><br></pre></td></tr></table></figure></p>
<p>它只是为了提供一个统一的接口供不同的迭代器调用。对于list这样的不能随机访问的迭代器来说就要通过遍历来知道它的size有多大，而对于像vector这样的随机访问迭代器来说，直接end()-begin()就知道了它的size，它的作用就是统一接口，针对不同的迭代器采取不同的策略</p>
<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>insert是list中比较重要的一部分了，list就是为了插入删除操作而生的。我们来好好了解一下到底是如何进行花式insert的吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 在pos处插入值x</span><br><span class="line">iterator insert(iterator _pos, const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	_Node *_tmp = _M_create_node(_x);</span><br><span class="line">	_tmp-&gt;_m_next = _pos._m_node;</span><br><span class="line">	_tmp-&gt;_m_prev = _pos._m_node-&gt;_m_prev;</span><br><span class="line">	_pos._m_node-&gt;_m_prev-&gt;_m_next = _tmp;</span><br><span class="line">	_pos._m_node-&gt;_m_prev = _tmp;</span><br><span class="line">	return _tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个很关键，还是画一幅图好好理解一下，因为后面的插入操作无非也就是在pos出插入多个值而已，咳，又到了展现画工的时候了，还真是激动。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180320/Ce4Jc17DkH.png?imageslim" alt="insert1"></p>
<p>好了，这就是初始状态，为了方便，就不画成环形了，大家知道就好<br>接下来分两步走<br>1.改变tmp指针域的指向</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180321/386cke12gG.png?imageslim" alt="insert2"></p>
<p>2.改变pos指针域的指向</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180321/Fglfi2IeE9.png?imageslim" alt="insert3"></p>
<p>红色代表被删除了，蓝色代表新加入的。这样新节点就成功加入到了pos前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iterator insert(iterator _pos)</span><br><span class="line">&#123;</span><br><span class="line">	return insert(_pos, _Tp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(iterator _pos, const_point _first, const_point _last)</span><br><span class="line">&#123;</span><br><span class="line">	for (; _first != _last; ++_first)</span><br><span class="line">		insert(_pos, *_first);</span><br><span class="line">&#125;</span><br><span class="line">void insert(iterator _pos, const_iterator _first, const_iterator _last)</span><br><span class="line">&#123;</span><br><span class="line">	for (; _first != _last; ++_first)</span><br><span class="line">		insert(_pos, *_first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(iterator _pos, size_type _n, const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	for (; _n &gt; 0; --_n)</span><br><span class="line">		insert(_pos, _x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，剩下的插入操作都是调用的第一个接口。</p>
<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iterator erase(iterator _pos)</span><br><span class="line">&#123;</span><br><span class="line">	_List_node_base *_next_node = _pos._m_node-&gt;_m_next;</span><br><span class="line">	_List_node_base *_prev_node = _pos._m_node-&gt;_m_prev;</span><br><span class="line">	_Node *_tmp = (_Node*)_pos._m_node;</span><br><span class="line">	_prev_node-&gt;_m_next = _next_node;</span><br><span class="line">	_next_node-&gt;_m_next = _prev_node;</span><br><span class="line">	destroy(&amp;_tmp-&gt;_m_data);</span><br><span class="line">	_M_put_node(_tmp);</span><br><span class="line">	return iterator((_Node*)_next_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作看代码应该很好理解，将pos的前一个节点的next指针指向pos的下一个节点，pos的后一个节点的prev指针指向pos的前一个节点</p>
<h2 id="push-amp-amp-pop"><a href="#push-amp-amp-pop" class="headerlink" title="push &amp;&amp; pop"></a>push &amp;&amp; pop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void push_front(const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin(), _x);</span><br><span class="line">&#125;</span><br><span class="line">void push_front()</span><br><span class="line">&#123;</span><br><span class="line">	insert(begin());</span><br><span class="line">&#125;</span><br><span class="line">void push_back(const_reference _x)</span><br><span class="line">&#123;</span><br><span class="line">	insert(end(), _x);</span><br><span class="line">&#125;</span><br><span class="line">void push_back()</span><br><span class="line">&#123;</span><br><span class="line">	insert(end());</span><br><span class="line">&#125;</span><br><span class="line">void pop_front()</span><br><span class="line">&#123;</span><br><span class="line">	erase(begin());</span><br><span class="line">&#125;</span><br><span class="line">void pop_back()</span><br><span class="line">&#123;</span><br><span class="line">	erase(--end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了insert和erase做接口，push和pop直接调用即可</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/alloc/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/28/alloc/" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">从零开始，打造自己的STL(三、alloc)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-28 04:13:48" itemprop="dateCreated datePublished" datetime="2018-03-28T04:13:48+08:00">2018-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在stl中，所有的内存分配与释放都是交由allocator来实现的。在大部分情况下，我们都接触不到这里面的内容，因为它一直是隐藏在幕后悄悄的工作。  </p>
<p>当然如果对于内存分配有特殊的要求的话，STL也提供了接口供我们使用自己的分配器  </p>
<p>比如在vector的定义上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename _Tp, typename _Alloc = alloc &gt;</span><br><span class="line">class vector : protected _Vector_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，模板参数_Alloc是可以由我们自己指定的。在使用的时候我们可以通过如下方式指定自己的分配器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int, myalloc&gt; vec;</span><br></pre></td></tr></table></figure></p>
<p>这样，内存的分配就交由我们来完成了。但是在我们自己的方法中，必须要提供 allocate 和 deallocate 这两个接口。否则是无法使用的  </p>
<h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><p>在SGI的STL中，内存的分配策略有两种</p>
<ol>
<li><p>一级空间配置器。凡是大于128bytes内存的空间，都会交由一级空间配置器来完成。它的底层直接通过 <strong>malloc</strong> 和 <strong>free</strong> 实现。</p>
</li>
<li><p>二级空间配置器。二级空间配置器是通过内存池来管理里面的内存分配与释放。凡是小于128bytes的内存需求都会通过它来配置，通过它可以有效的避免内存碎片，提高内存的利用率 </p>
</li>
</ol>
<p>在我们自己实现的STL中，只实现了一级空间配置器，因为它的实现相对简单<br>在讨论分配器之前，和大家分享一下标准化的一些东西 </p>
<p>首先是一些统一的接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef size_t              size_type;</span><br><span class="line">typedef _Tp                 value_type;</span><br><span class="line">typedef value_type*         iterator;</span><br><span class="line">typedef value_type*         pointer;</span><br><span class="line">typedef const value_type*   const_pointer;</span><br><span class="line">typedef const value_type*   const_iterator;</span><br><span class="line">typedef value_type&amp;         reference;</span><br><span class="line">typedef const value_type&amp;   const_reference;</span><br><span class="line">typedef ptrdiff_t           difference_type;</span><br><span class="line">typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">typedef reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br></pre></td></tr></table></figure></p>
<p>这些接口是每一个容器都必须提供的，详细的原因在迭代器中解释 </p>
<p>其次就是命名规范，所有非标准的东西全部以 “_” 开头</p>
<p>在不考虑内存池和内存分配失败的各种处理策略上，以一个简单的分配器举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template &lt;int _Tp&gt;</span><br><span class="line">class _malloc_alloc</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static void *allocate(size_t _n)</span><br><span class="line">    &#123;</span><br><span class="line">        void *_result = malloc(_n);</span><br><span class="line">        return _result;</span><br><span class="line">    &#125;</span><br><span class="line">    static void deallocate(void *_p)</span><br><span class="line">    &#123;</span><br><span class="line">        free(_p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename _TP, typename _Alloc&gt;</span><br><span class="line">class simple_alloc</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static _TP* allocate(size_t _n)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0 == _n ? nullptr : (_TP*)_Alloc::allocate(_n * sizeof(_TP));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void deallocate(_TP *_p)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nullptr != _p)</span><br><span class="line">            _Alloc::deallocate(_p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef _malloc_alloc&lt;0&gt; malloc_alloc;</span><br><span class="line"></span><br><span class="line">typedef malloc_alloc alloc;</span><br></pre></td></tr></table></figure></p>
<p>malloc_alloc提供内存分配和释放，simple_alloc作为对外统一管理调度的接口。</p>
<h1 id="成员的构造与析构"><a href="#成员的构造与析构" class="headerlink" title="成员的构造与析构"></a>成员的构造与析构</h1><p>从上面大家可以看到，进行内存分配的时候我们调用的底层函数是malloc。众所周知，在c++中，malloc分配的空间是不会调用成员的构造函数的，在STL中是如何解决这一问题的呢。</p>
<p>前面我们提到过，STL中内存分配与成员的构造是分离的，这也是STL提高效率的策略之一。因为对于内置类型来说，并不需要进行构造与析构的，这样，我们将这些类型抽离出来，通过函数重载，使其什么也不做，这样效率就上来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 对原生类型进行重载, 这些类型不需要析构</span><br><span class="line">inline void _Destroy(char*, char*) &#123;&#125;</span><br><span class="line">inline void _Destroy(int*, int*) &#123;&#125;</span><br><span class="line">inline void _Destroy(long*, long*) &#123;&#125;</span><br><span class="line">inline void _Destroy(float*, float*) &#123;&#125;</span><br><span class="line">inline void _Destroy(double*, double*) &#123;&#125;</span><br><span class="line">inline void _Destroy(wchar_t*, wchar_t*) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 对于范围析构的情况，根据不同的类型采取不同的策略</span><br><span class="line">template&lt;typename _ForwardIter&gt;</span><br><span class="line">void _destroy_aux(_ForwardIter _first, _ForwardIter _last, _false_type)</span><br><span class="line">&#123;</span><br><span class="line">    for (; _first != _last; ++_first)</span><br><span class="line">        destroy(&amp;*_first); // op*()</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename _ForwardIter&gt;</span><br><span class="line">void _destroy_aux(_ForwardIter _first, _ForwardIter _last, _true_type)&#123;&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp&gt;</span><br><span class="line">void destroy(_Tp* _pointer)</span><br><span class="line">&#123;</span><br><span class="line">    _pointer-&gt;~_Tp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename _T1, typename _T2&gt;</span><br><span class="line">void construct(_T1 *_p, const _T2 &amp;_val)</span><br><span class="line">&#123;</span><br><span class="line">    new ((void*)_p) _T1(_val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>析构我们有了一定的了解，谈到构造，就要详细的了解一下之前所说的uninitialized系列的函数了，通过这一系列的函数，能够非常方便的对成员进行构造</p>
<p><strong>uninitialized_fill</strong></p>
<p><strong>uninitialized_copy</strong></p>
<p><strong>uninitialized_fill_n</strong></p>
<p>这三大函数完成了STL中所有空间的构造<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// uninitialized_copy</span><br><span class="line">template&lt;typename _InputIter, typename _ForwardIter&gt;</span><br><span class="line">_ForwardIter _uninitialized_copy_aux(_InputIter _first, _InputIter _last, _ForwardIter _result, _false_type)</span><br><span class="line">&#123;</span><br><span class="line">    _ForwardIter _cur = _result;</span><br><span class="line">    for (; _first != _last; ++_first, ++_cur)</span><br><span class="line">        construct(&amp;*_cur, *_first);</span><br><span class="line"></span><br><span class="line">    return _cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename _InputIter, typename _ForwardIter&gt;</span><br><span class="line">_ForwardIter _uninitialized_copy_aux(_InputIter _first, _InputIter _last, _ForwardIter _result, _true_type)</span><br><span class="line">&#123;</span><br><span class="line">    return copy(_first, _last, _result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// uninitialized_fill</span><br><span class="line">template&lt;typename _ForwardIter, typename _Tp&gt;</span><br><span class="line">void _uninitialized_fill_aux(_ForwardIter _first, _ForwardIter _last, const _Tp &amp;_val, _true_type)</span><br><span class="line">&#123;</span><br><span class="line">    fill(_first, _last, _val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename _ForwardIter, typename _Tp&gt;</span><br><span class="line">void _uninitialized_fill_aux(_ForwardIter _first, _ForwardIter _last, const _Tp &amp;_val, _false_type)</span><br><span class="line">&#123;</span><br><span class="line">    _ForwardIter _cur = _first;</span><br><span class="line"></span><br><span class="line">    for (; _cur != _last; ++_cur)</span><br><span class="line">        construct(&amp;*_first, _val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// uninitialized_fill_n</span><br><span class="line">template &lt;typename _ForwardIter, typename _Size, typename _Tp&gt;</span><br><span class="line">inline _ForwardIter</span><br><span class="line">_uninitialized_fill_n_aux(_ForwardIter _first, _Size _n, const _Tp&amp; _x, _true_type)</span><br><span class="line">&#123;</span><br><span class="line">    return fill_n(_first, _n, _x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename _ForwardIter, typename _Size, typename _Tp&gt;</span><br><span class="line">inline _ForwardIter</span><br><span class="line">_uninitialized_fill_n_aux(_ForwardIter _first, _Size _n, const _Tp&amp; _val, _false_type)</span><br><span class="line">&#123;</span><br><span class="line">    _ForwardIter _cur = _first;</span><br><span class="line"></span><br><span class="line">    for (; _n &gt; 0; --_n, ++_cur)</span><br><span class="line">        construct(&amp;*_cur, _val);</span><br><span class="line"></span><br><span class="line">    return _cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这三个函数的实现都非常简单，具体的功能一眼就能看出</p>
<p><strong>uninitialized_copy</strong>是将[first,last)的值拷贝到result中</p>
<p><strong>uninitialized_fill_n</strong>是从first开始，填充n个val的值</p>
<p><strong>uninitialized_fill</strong> 在区域[first,last)中填充val</p>
<p>上面三个函数都分别有两个版本，会根据该种数据类型生成相应的type(false_type或true_type)，根据不同的type调用不同的函数</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/28/synopsis /">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/03/28/synopsis /" class="post-title-link" itemprop="http://yoursite.com/page/3/index.html">从零开始，打造自己的STL(一、简述)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-03-28 03:54:22" itemprop="dateCreated datePublished" datetime="2018-03-28T03:54:22+08:00">2018-03-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对于每一个热爱c++的人来说，STL都是他们日常撸码、高效工作的必定会使用到的标准模板库。STL取用范型的思想，通过模板元编程，去掉了不同型别所带来的差异性，极大的提高了代码的复用性。</p>
<p>既然STL如此强大与方便，我们当然要好好的学习它啊。仅仅停留在使用层面是是远远不够的，我们必须深入到代码内部，详细的了解它内部的工作原理。了解他不只是因为我们作为底层开发者不搞懂原理誓不罢休的精神，更是因为要更好的使用它。相信有过一定模板编程的人来说，都曾今被编译器报的错误震惊过，一看没什么问题啊，怎么瞬间来了二三十个错误。最后找到可能只是一点小小的问题，这就是模板编程强大的背后带来的弊端，它的错误比较难定位，如果我们不懂原理，出了错只能是一头雾水，无从改起。</p>
<p>说了这么多废话，就开始正式介绍STL吧。</p>
<h1 id="STL六大组件"><a href="#STL六大组件" class="headerlink" title="STL六大组件"></a>STL六大组件</h1><p><strong>容器</strong>：容器这个概念比较重要，平常我们使用STL时接触的最多的就是容器了。故名思议，容器是我们STL中存放数据的地方，它提供各种的数据结构，如vector、list、deque、set、map等。它的主要作用是提供了数据的存放场所。</p>
<p><strong>算法</strong>：既然有了容器提供数据的存放之所，那么肯定要有算法来操控这些数据。常见的copy，search，sort，erase算法在这里都有提供。</p>
<p><strong>迭代器</strong>：迭代器在STL中扮演者比较重要的角色，它就像胶水一样将容器和算法这两个不相干的东西粘合起来。因为算法要作用在容器上，就必须访问得到容器内部的数据，而访问容器中的数据就是通过迭代器来实现的。这样算法就不需要直接操控容器，从而保持了容器良好的封装性。</p>
<p><strong>容器适配器</strong>：这个东东其实是对容器的又一层封装，它改变了容器的接口，使之变的像一个新的容器一样，其底层实现原理完全是调用的容器的接口就称之为容器适配器。如stack，queue都是调用底层deque的接口实现的。这种名词讲起来不是很易懂，到后面看到源码之后就很好理解了</p>
<p><strong>分配器</strong>：在STL中，与其说容器是用来存放数据的，不如说它提供了一种数据的存放方式。数据存放的空间是通过分配器进行分配的。这样说着有点绕，说白了。STL将数据空间的分配与释放和数据的存储分离开来，分配器就只负责空间的分配与释放，容器则负责数据的存储</p>
<p><strong>函数对象</strong>：又称仿函数，实现了op()的类可以称之为一个函数对象。仿函数给算法提供了极大的便利性，举个栗子：在进行排序的时候，到底是从小到大排，还是从大到小排呢。STL的sort算法默认提供的是less这个仿函数，也就是从小到大排。当然我们也可以提供自己的比较函数来进行排序。</p>
<p>借用STL源码剖析书中的一副图来描述这六大组件之间的关系</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180328/c8iabc3Fc8.png?imageslim" alt="mark"></p>
<p>简单的介绍了一下STL之后，在后面我们将会正式开始容器部分</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="melody">
            
              <p class="site-author-name" itemprop="name">melody</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">melody</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
