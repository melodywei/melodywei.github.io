<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="melodyのblog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="melodyのblog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="melodyのblog">






  <link rel="canonical" href="http://yoursite.com/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>melodyのblog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">melodyのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/malloc&free/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/07/malloc&free/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">十四. malloc&free的实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-07 18:58:26" itemprop="dateCreated datePublished" datetime="2018-05-07T18:58:26+08:00">2018-05-07</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前的内容中已经实现过内存分配的功能，但之前的内存管理模块中只是实现了内核空间的内存分配，而且每次分配的空间都是已页为单位，也就是只能分配页的整数倍的空间。已页为单位的内存确实是最利于操作系统管理的，但是当只需要小块内存区域的时候，之前的内存管理模块就无法完成了。所以在这里要完善之前的内存管理模块，使其能够支持小块内存的分配。有了底层的内存管理模块的支撑之后，malloc和free的实现就非常容易了。</p>
<h1 id="malloc底层原理"><a href="#malloc底层原理" class="headerlink" title="malloc底层原理"></a>malloc底层原理</h1><p>之前的内存管理模块中是通过bitmap对内存进行管理的，bitmap中的每一个bit位就代表一页大小的内存，该位为1时表示这页已经分配出去了。那么对小块内存进行分配的时候，同样需要一个结构来记录这块内存的情况，也就是说，要通过一种结构来对内存的分配与释放进行管理。</p>
<p>arena是一大块的内存被划分的多个小的内存块的内存仓库。按照内存块的大小，可以划分成不同规格的arena。比如一种arena中全是32byte的内存块，它就只相应32byte以下内存空间的分配。这一整块arena的大小同样是页的整数倍，按照申请内存空间的大小，这个arena可能是1页或者多页。</p>
<p>按照这种原理，arena就由两部分组成，一是这块内存的元信息，用来描述这个arena中剩余的内存块，二是内存池区域，里面就是多个大小相同的内存块。其结构如下图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180507/f7K8iefkG2.png?imageslim" alt="arena结构"></p>
<p>一块arena大小的内存总有分配完的时候，也就是该arena中的所有mem_block都分配出去了，那么肯定需要新增一个与之前arena规格相同的arena来满足内存的需求，那么这些相同规格arena之前同样需要一个结构来进行管理，这个结构用来记录arena的规格以及同规格arena中所有空闲内存块链表</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180507/GFHj8JBHIe.png?imageslim" alt="内存块描述符"></p>
<p>内存块描述符中会将所有同规格arena的空间内存块进行汇总，它相当于所有内存块的大仓库，分配内存的时候经过这个大仓库，找到里面的某个arena，也就是小仓库，最后从这个arena中找到某个空闲的内存块，将其分配出去。这个过程是不是和现实生活中从仓库取物品很类似。</p>
<p>arena中主要是针对小内存分配的管理，里面的内存块规格最大不会超过1024byte，那么对于超过1024byte的空间如何分配呢？一种可能的情况是将多个内存块合并起来，这些合并的内存块组成这个大空间，但是用这种方式对内存块信息的维护就变的极其麻烦。所以对于大的内存就不进行内存块的划分，它的arena就变成了这个样子</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180507/C77IidECHb.png?imageslim" alt="mark"></p>
<p>这里我划分了7种规格的arena，分别为16byte, 32byte, 64byte, …. 1024byte。一个arena一般占用1页也就是4096byte，arena中的元信息在设计中它会占用12byte大小，对于规格为16byte的arena来说，它有(4096 - 12) / 16 = 255个内存块，有4byte的空间被浪费。</p>
<p>在内存分配的过程中，小于16byte的空间就会采用16byte的arena进行分配，后面同理。</p>
<h1 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><p>说了那么多原理，还是来看看代码实现，从源码中能够更清晰的看出其原理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存块描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_block_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> block_size;    <span class="comment">// 内存块规格</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks_per_arena;  <span class="comment">//本arena中可容纳mem_block的数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">free_list</span>;</span>  <span class="comment">// 目前可用的mem_block链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arena</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_block_desc</span> *<span class="title">desc</span>;</span> <span class="comment">// arena中的元信息</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cnt; <span class="comment">// 空闲内存块的数量</span></span><br><span class="line">    <span class="keyword">bool</span> large; <span class="comment">// 是否为大内存，当申请大内存时因为不会对内存块进行划分，他的desc会被置为NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存块描述符个数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DESC_CNT 7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_block_desc</span> <span class="title">k_block_descs</span>[<span class="title">DESC_CNT</span>];</span></span><br></pre></td></tr></table></figure>
<p>内存管理的结构如上面所示，每个成员的作用都已经用注释说明了。需要注意的是当large为false时，该arena的内存块描述符会为NULL，因为该arena不会划分小的内存块，而是作为一个整体使用，且cnt不再表示空闲内存块的数量，而是表示所占用的页框数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">block_desc_init</span><span class="params">(struct mem_block_desc *desc_array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> desc_idx, block_size = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (desc_idx = <span class="number">0</span>; desc_idx &lt; DESC_CNT; ++desc_idx)</span><br><span class="line">    &#123;</span><br><span class="line">        desc_array[desc_idx].block_size = block_size;</span><br><span class="line"></span><br><span class="line">        desc_array[desc_idx].blocks_per_arena = (PG_SIZE - <span class="keyword">sizeof</span>(struct arena)) / block_size;</span><br><span class="line">        list_init(&amp;desc_array[desc_idx].free_list);</span><br><span class="line">        block_size *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对7种规格的内存块描述符进行初始化。</p>
<p>接下来就看sys_malloc的具体实现，该函数就是在堆上分配指定大小的空间。这也是malloc的底层实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sys_malloc</span><span class="params">(<span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> pool_flags pf;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> *<span class="title">mem_pool</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pool_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_block_desc</span> *<span class="title">descs</span>;</span></span><br><span class="line">    task_struct *cur_thread = running_thread();</span><br><span class="line">    <span class="comment">// 判断是内核还是用户进程需要分配空间</span></span><br><span class="line">    <span class="keyword">if</span>(cur_thread-&gt;pgdir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pf = PF_KERNEL;</span><br><span class="line">        pool_size = kernel_pool.pool_size;</span><br><span class="line">        mem_pool = &amp;kernel_pool;</span><br><span class="line">        descs = k_block_descs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pf = PF_USER;</span><br><span class="line">        pool_size = user_pool.pool_size;</span><br><span class="line">        mem_pool = &amp;user_pool;</span><br><span class="line">        descs = cur_thread-&gt;u_block_desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(size &gt; <span class="number">0</span> &amp;&amp; size &lt; pool_size))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arena</span> *<span class="title">a</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_block</span> *<span class="title">b</span>;</span></span><br><span class="line">    lock_acquire(&amp;mem_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理大内存分配的情况，直接分配。</span></span><br><span class="line">    <span class="comment">// 分配的大小对4096向上取整</span></span><br><span class="line">    <span class="keyword">if</span>(size &gt; <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> page_cnt = DIV_ROUND_UP(size + <span class="keyword">sizeof</span>(struct arena), PG_SIZE);</span><br><span class="line"></span><br><span class="line">        a = malloc_page(pf, page_cnt);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(a, <span class="number">0</span>, page_cnt * PG_SIZE);</span><br><span class="line"></span><br><span class="line">            a-&gt;desc = <span class="literal">NULL</span>;</span><br><span class="line">            a-&gt;cnt = page_cnt;</span><br><span class="line">            a-&gt;large = <span class="literal">true</span>;</span><br><span class="line">            lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">void</span> *)(a + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小内存的分配情况</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> desc_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到使用哪种规格的内存描述符</span></span><br><span class="line">        <span class="keyword">for</span> (; desc_idx &lt; DESC_CNT; ++desc_idx)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(size &lt;= descs[desc_idx].block_size)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该内存块描述符中的arena为空时，首先为其分配arena</span></span><br><span class="line">        <span class="comment">// 然后会将该arena根据其描述符中的规格大小进行内存块的划分</span></span><br><span class="line">        <span class="comment">// 划分的过程主要是通过arena2block这个函数对arena中的地址进行转换，使其指向下一个内存块所在的首地址，最后添加到链表中</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;descs[desc_idx].free_list))</span><br><span class="line">        &#123;</span><br><span class="line">            a = malloc_page(pf, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(a, <span class="number">0</span>, PG_SIZE);</span><br><span class="line"></span><br><span class="line">            a-&gt;desc = &amp;descs[desc_idx];</span><br><span class="line">            a-&gt;cnt = descs[desc_idx].blocks_per_arena;</span><br><span class="line">            a-&gt;large = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> block_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; block_idx &lt; descs[desc_idx].blocks_per_arena; ++block_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                b = arena2block(a, block_idx);</span><br><span class="line">                ASSERT(!elem_find(&amp;a-&gt;desc-&gt;free_list, &amp;b-&gt;free_elem));</span><br><span class="line">                list_append(&amp;a-&gt;desc-&gt;free_list, &amp;b-&gt;free_elem);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            intr_set_status(old_status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有空闲的内存块之后找到该内存块相对于arena的偏移地址，该地址便为分配到的空间的首地址</span></span><br><span class="line">        b = elem2entry(struct mem_block, free_elem, list_pop(&amp;descs[desc_idx].free_list));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, descs[desc_idx].block_size);</span><br><span class="line">        a = block2arena(b);</span><br><span class="line">        a-&gt;cnt--;</span><br><span class="line">        lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)b;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数整体的执行流程如下</p>
<p>首先判断是内核还是用户进程需要分配空间，确定在相应的内存池中进行分配</p>
<p>申请的空间大于1024byte的情况，会分配申请内存大小+元信息大小对4096向上取整的页框数，比如说申请的内存大小为4092byte，元信息的大小为12byte，所以总共需要5004byte，也就是说需要2个页框，最后返回的地址要跳过元信息。</p>
<p>对于小于1024byte的情况，从7种规格的arena中找个分配颗粒与所需大小最接近的arena，比如33byte，就会使用64byte的arena。申请63byte空间，同样会使用64byte的arena。也就是说，即使只需要33byte的空间，实际分配的过程中，还是会占用64byte的内存空间。这种空间的浪费是无法避免的。下面看一下执行的结果</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180507/0k3HHmj4AA.png?imageslim" alt="mark"></p>
<p>在调用的过程中申请了两块内存空间，第一块空间的大小为33byte，第二块空间的大小为63byte，这两块空间都是使用64byte的arena，因为是第一次申请空间，所以首先会建立64byte的arena，也就是说这两块空间都会使用同一个页框，该页框的首地址为0xc0102000，首先需要跳过元信息的大小为0xc，所以第一块内存的地址就是0xc0102000+0xc， 第二块内存的地址是0xc0102000 + 0xc + 0x40。</p>
<p>底层的封装已经封装好了，接下来就要通过系统调用，提供对外的接口啦<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)_syscall1(SYS_MALLOC, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>系统调用的原理就是根据传递的子功能号去调用相应的中断处理例程，这里的中断处理例程就是上面的sys_malloc这个函数啦。</p>
<h1 id="实现free"><a href="#实现free" class="headerlink" title="实现free"></a>实现free</h1><p>有了申请内存之后就得有内存的释放，毕竟有借得有换。内存释放的过程其实并不神秘，想想之前申请内存的步骤</p>
<ol>
<li>在虚拟内存池中分配内存地址，它的实质也就是在bitmap中将相应的位置1。</li>
<li>在物理内存池中分配内存地址，这两步说的内存都是以页为单位的，他们是通过bitmap进行管理的。这里同样只需要在物理内存池的bitmap中将相应的位置1</li>
<li>建立虚拟页与物理页之间的映射关系。</li>
</ol>
<p>所以咯，内存的释放只需要将相应的bitmap中的相应位置0即可，然后在页表中去掉对虚拟地址的映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将物理地址pg_phy_addr对应的页回收</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfree</span><span class="params">(<span class="keyword">uint32_t</span> pg_phy_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> *<span class="title">mem_pool</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bit_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pg_phy_addr &gt;= user_pool.phy_addr_start)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_pool = &amp;user_pool;</span><br><span class="line">        bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mem_pool = &amp;kernel_pool;</span><br><span class="line">        bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitmap_set(&amp;mem_pool-&gt;pool_bitmap, bit_idx , <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉页表中虚拟地址的映射，只需要将pte中的P位置0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_pte_remove</span><span class="params">(<span class="keyword">uint32_t</span> vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *pte = pte_ptr(vaddr);</span><br><span class="line">    *pte &amp;= ~PG_P_1;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"invlpg %0"</span> :: <span class="string">"m"</span> (vaddr):<span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回收虚拟内存</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vaddr_remove</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">void</span> *_vaddr, <span class="keyword">uint32_t</span> pg_cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> bit_idx_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>)_vaddr;</span><br><span class="line">    <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; pg_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        task_struct *cur_thread = running_thread();</span><br><span class="line">        bit_idx_start = (vaddr - cur_thread-&gt;userprog_vaddr.vaddr_start) / PG_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; pg_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            bitmap_set(&amp;cur_thread-&gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这些过程是对整页的内存进行释放操作，对于小块内存的回收则更加简单了，只需要将这个内存块加入到该内存块对应的arena的空闲链表中即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回收内存ptr */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_free</span><span class="params">(<span class="keyword">void</span>* ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(ptr != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">enum</span> pool_flags PF;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pool</span>* <span class="title">mem_pool</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断是线程还是进程 */</span></span><br><span class="line">        <span class="keyword">if</span> (running_thread()-&gt;pgdir == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ASSERT((<span class="keyword">uint32_t</span>)ptr &gt;= K_HEAP_START);</span><br><span class="line">            PF = PF_KERNEL;</span><br><span class="line">            mem_pool = &amp;kernel_pool;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            PF = PF_USER;</span><br><span class="line">             mem_pool = &amp;user_pool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock_acquire(&amp;mem_pool-&gt;lock);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mem_block</span>* <span class="title">b</span> = <span class="title">ptr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">arena</span>* <span class="title">a</span> = <span class="title">block2arena</span>(<span class="title">b</span>);</span>      <span class="comment">// 把mem_block转换成arena,获取元信息  </span></span><br><span class="line">        ASSERT(a-&gt;large == <span class="number">0</span> || a-&gt;large == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;desc == <span class="literal">NULL</span> &amp;&amp; a-&gt;large == <span class="literal">true</span>) </span><br><span class="line">        &#123; <span class="comment">// 大于1024的内存</span></span><br><span class="line">            mfree_page(PF, a, a-&gt;cnt); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;               </span><br><span class="line">            <span class="comment">// 小于等于1024的内存块</span></span><br><span class="line">            <span class="comment">/* 先将内存块回收到free_list */</span></span><br><span class="line">            list_append(&amp;a-&gt;desc-&gt;free_list, &amp;b-&gt;free_elem);</span><br><span class="line">     </span><br><span class="line">            <span class="comment">/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */</span></span><br><span class="line">            <span class="keyword">if</span> (++a-&gt;cnt == a-&gt;desc-&gt;blocks_per_arena) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> block_idx;</span><br><span class="line">                <span class="keyword">for</span> (block_idx = <span class="number">0</span>; block_idx &lt; a-&gt;desc-&gt;blocks_per_arena; block_idx++  ) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">mem_block</span>*  <span class="title">b</span> = <span class="title">arena2block</span>(<span class="title">a</span>, <span class="title">block_idx</span>);</span></span><br><span class="line">                    ASSERT(elem_find(&amp;a-&gt;desc-&gt;free_list, &amp;b-&gt;free_elem));</span><br><span class="line">                    list_remove(&amp;b-&gt;free_elem);</span><br><span class="line">                &#125;</span><br><span class="line">                mfree_page(PF, a, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lock_release(&amp;mem_pool-&gt;lock);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于大块的内存，就如之前所说，释放其对应的页。对于小块内存，直接加入其对应的空闲链表中，如果这一整页的内存块都是空闲的，释放该页。</p>
<p>提供系统调用free<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _syscall1(SYS_FREE, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/01/syscall/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/01/syscall/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">十三. 实现系统调用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-01 18:18:02" itemprop="dateCreated datePublished" datetime="2018-05-01T18:18:02+08:00">2018-05-01</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统调用简介"><a href="#系统调用简介" class="headerlink" title="系统调用简介"></a>系统调用简介</h1><p>关于系统调用前面有过简单的介绍，这里将真正实现系统调用</p>
<p>现代的操作系统中，用户的权限是有限的，它不能随意的访问系统中的资源。操作系统屏蔽了用户直接访问硬件的能力，这样做的原因主要是为了安全考虑。</p>
<p>但是如果我们想控制显卡打印字符怎么呢，那就需要通过操作系统提供的接口来完成了，我们调用操作系统提供的接口，然后操作系统去操控硬件，比如说这里的显卡，打印出字符来。我们使用的c语言里面的printf函数，其真实调用的是系统调用接口中的write，操作系统提供的这一系列接口就是系统调用接口。</p>
<p>总结来说，系统调用就是用户进程申请操作系统的帮助，让操作系统帮其完成某项工作，也就相当于用户进程调用了操作系统的功能。</p>
<h1 id="系统调用的实现原理"><a href="#系统调用的实现原理" class="headerlink" title="系统调用的实现原理"></a>系统调用的实现原理</h1><p>系统调用主要是通过中断门实现的，通过软中断int发出中断信号。由于要支持的系统功能很多，不可能每个系统调用就占用一个中断向量。所以规定了0x80为系统调用的中断向量号，在进行系统调用之前，向eax中写入系统调用的子功能号，再进行系统调用的时候，系统就会根据eax的值来决定调用哪个中断处理例程。</p>
<h1 id="linux中系统调用的实现"><a href="#linux中系统调用的实现" class="headerlink" title="linux中系统调用的实现"></a>linux中系统调用的实现</h1><p>在完善我们的系统调用之前，先看看linux中是如何实现系统调用的。</p>
<p>通过man syscall查看系统调用的文档</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180501/g6e71hdJGe.png?imageslim" alt="linux syscall"></p>
<p>这里面可以看到他的原型是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">syscall</span><span class="params">(<span class="keyword">long</span> number, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数接收一个系统调用号，由于不同的子功能所需的参数都是不同的，所以该函数需要支持可变参数。</p>
<p>这里可以看一个例子</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180501/b9C6K5bD68.png?imageslim" alt="mark"></p>
<p>这里调用了系统调用SYS_gettid，这个SYS_gettid定义在</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180501/HD5g3e2gLc.png?imageslim" alt="mark"></p>
<p>继续向后找，可以看到最终的定义就是一个数值，也就是SYS_gettid的子功能号。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180501/KkeGm92JFi.png?imageslim" alt="mark"></p>
<p>syscall其实是一个间接的系统调用，它是一个库函数，不是操作系统直接提供的。</p>
<p>linux中也有直接提供的系统调用，就是_syscall。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180501/CGaeH7HLGd.png?imageslim" alt="_syscall"></p>
<p>这种系统调用方式是通过宏机制来实现的，参数个数不同就对应不同的宏，但是最大支持的参数只有6个，而且会引发安全问题，所以它已经被废弃了。</p>
<p>而我们的kernel就打算用这种方式来实现系统调用，因为相对来说简单</p>
<h1 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h1><p>实现系统调用的流程如下</p>
<ol>
<li>用中断门实现系统调用，通过0x80中断作为系统调用的入口</li>
<li>在IDT中安装0x80号中断对应的描述符，在该描述符中注册系统调用对应的中断处理例程</li>
<li>建立系统调用子功能表，利用eax寄存器中的子功能号在该表中索引相应的处理函数</li>
<li>用宏实现用户空间系统调用接口_syscall，最大只支持3个参数，ebx保存第一个参数，ecx保存第二个参数，edx保存第三个参数</li>
</ol>
<p>就按照这个步骤一步步完成代码</p>
<p>在idt中添加0x80的描述符，该描述符必须要在3特权级下能够访问，否则用户就无法调用系统调用接口了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> uint32_t <span class="title">syscall_handler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">idt_desc_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lastindex = IDT_DESC_CNT - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; IDT_DESC_CNT - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	make_idt_desc(&amp;idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler);</span><br><span class="line"></span><br><span class="line">	put_str(<span class="string">"   idt_desc_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统调用宏的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无参数的系统调用 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall0(NUMBER)  \</span></span><br><span class="line">(&#123;                         \</span><br><span class="line">        <span class="keyword">int</span> retval;        \</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(      \</span><br><span class="line">            <span class="string">"int $0x80"</span>    \</span><br><span class="line">            : <span class="string">"=a"</span>(retval) \</span><br><span class="line">            : <span class="string">"a"</span>(NUMBER)  \</span><br><span class="line">            : <span class="string">"memory"</span>);   \</span><br><span class="line">        retval;            \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一个参数的系统调用 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall1(NUMBER, ARG1)      \</span></span><br><span class="line">    (&#123;                               \</span><br><span class="line">        <span class="keyword">int</span> retval;                  \</span><br><span class="line">        <span class="keyword">asm</span> <span class="keyword">volatile</span>(                \</span><br><span class="line">            <span class="string">"int $0x80"</span>              \</span><br><span class="line">            : <span class="string">"=a"</span>(retval)           \</span><br><span class="line">            : <span class="string">"a"</span>(NUMBER), <span class="string">"b"</span>(ARG1) \</span><br><span class="line">            : <span class="string">"memory"</span>);             \</span><br><span class="line">        retval;                      \</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 两个参数的系统调用 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall2(NUMBER, ARG1, ARG2) (&#123;    \</span></span><br><span class="line">    <span class="keyword">int</span> retval;                             \</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(                           \</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int $0x80"</span>                         \</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"=a"</span>(retval)                      \</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"a"</span>(NUMBER), <span class="string">"b"</span>(ARG1), <span class="string">"c"</span>(ARG2) \</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"memory"</span>)</span></span>;                        \</span><br><span class="line">    retval;                                 \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 三个参数的系统调用 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall3(NUMBER, ARG1, ARG2, ARG3) (&#123;         \</span></span><br><span class="line">    <span class="keyword">int</span> retval;                                        \</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(                                      \</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int $0x80"</span>                                    \</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"=a"</span>(retval)                                 \</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"a"</span>(NUMBER), <span class="string">"b"</span>(ARG1), <span class="string">"c"</span>(ARG2), <span class="string">"d"</span>(ARG3) \</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"memory"</span>)</span></span>;                                   \</span><br><span class="line">    retval;                                            \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>完成0x80的处理例程</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">bits</span> <span class="number">32</span>]</span><br><span class="line"><span class="meta">extern</span> syscall_table</span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="meta">global</span> syscall_handler</span><br><span class="line"><span class="symbol">syscall_handler:</span></span><br><span class="line">    <span class="comment">; 保存上下文环境</span></span><br><span class="line">    <span class="keyword">push</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ds</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">fs</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">gs</span></span><br><span class="line">    <span class="keyword">pushad</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">push</span> <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">edx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ecx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line"></span><br><span class="line">    // 调用相应的处理程序</span><br><span class="line">    <span class="keyword">call</span> [syscall_table + <span class="number">4</span> * <span class="built_in">eax</span>]</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">12</span> <span class="comment">; 跨过上面的三个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">; 将 call 调用后的返回值存入当前内核栈中 eax 的位置</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">esp</span> + <span class="number">4</span> * <span class="number">8</span>], <span class="built_in">eax</span></span><br><span class="line">    <span class="keyword">jmp</span> intr_exit</span><br></pre></td></tr></table></figure>
<p>初始化系统调用子功能对应的处理程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> syscall_nr 32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *syscall;</span><br><span class="line">syscall syscall_table[syscall_nr];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回当前任务的pid */</span></span><br><span class="line"><span class="keyword">uint32_t</span> sys_getpid(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> running_thread()-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化系统调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    put_str(<span class="string">"syscall_init start\n"</span>);</span><br><span class="line">    syscall_table[SYS_GETPID] = sys_getpid;</span><br><span class="line">    put_str(<span class="string">"syscall_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供用户使用的系统调用接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回当前任务pid */</span></span><br><span class="line"><span class="keyword">uint32_t</span> getpid()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall0(SYS_GETPID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前就有了一个getpid的系统调用接口</p>
<h1 id="系统调用write以及printf函数的实现"><a href="#系统调用write以及printf函数的实现" class="headerlink" title="系统调用write以及printf函数的实现"></a>系统调用write以及printf函数的实现</h1><p>目前这个write只是一个简易版，它的主要功能是为printf函数提供支持。哈哈，终于要实现自己的printf函数了。有了前面的基础，再添加一个系统调用就很简单了。</p>
<p>添加SYS_WRITE的处理程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> sys_write(<span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    console_put_str(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化系统调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    put_str(<span class="string">"syscall_init start\n"</span>);</span><br><span class="line">    syscall_table[SYS_GETPID] = sys_getpid;</span><br><span class="line">    syscall_table[SYS_WRITE] = sys_write;</span><br><span class="line">    put_str(<span class="string">"syscall_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供用户调用接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> write(<span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall1(SYS_WRITE, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变参数的原理"><a href="#可变参数的原理" class="headerlink" title="可变参数的原理"></a>可变参数的原理</h2><p>我们平时使用的函数中，大多数参数的个数都是已知的。函数占用的是静态内存，也就是说再编译期就要确定为其分配多大的空间。这个空间的大小在函数声明的时候就已经确定了。比如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译器会自动的根据函数参数的类型在栈中分配好空间。那么问题来了，对于这种参数确定的函数，编译器能够知道为其分配多少空间。那么在参数可变的情况下，编译器有是如何为其分配空间的呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>printf函数的原型如上，通常我们是这样调用它的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"aaa%s %c"</span>, str, ch);</span><br></pre></td></tr></table></figure>
<p>从这种调用方式来看，虽然说他的参数是可变的，同样也可以说他的参数是固定的。因为在调用它的时候这个format是固定的，format就是指 <strong>aaa%s %c</strong>这段内容，每一个 <strong>%</strong> 后面就带表需要一个参数，这里就固定了它有两个参数。每个 <strong>%</strong> 便是在栈中寻找可变参数的依据。</p>
<p>gcc对于可变参数的支持是通过 <strong>va_start, va_end, va_arg</strong> 这三个宏来实现的。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180501/BA161ACaJA.png?imageslim" alt="可变参数原理"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个宏的作用相当于初始化ap指针，使其执行v的地址</span></span><br><span class="line">va_start(ap,v) </span><br><span class="line"></span><br><span class="line"><span class="comment">//ap是指向可变参数指针变量，t是可变参数的类型，该函数的作用是使ap指向栈中下一个参数的地址并返回其值 </span></span><br><span class="line">va_arg(ap,t)</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空ap</span></span><br><span class="line">va_end(ap)</span><br></pre></td></tr></table></figure>
<p>我们通过对printf函数中format的解析，每找到一个 <strong>%</strong> 通过 <strong>%</strong> 后面接的字符来判断参数的类型，知道该参数的类型之后，就可以调用va_arg找到该参数在栈中的地址，也就可以顺利的实现printf了。下面看一下具体的解析format的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">vsprintf</span>(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf_ptr = str;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *index_ptr = format;</span><br><span class="line">    <span class="keyword">char</span> index_char = *index_ptr;</span><br><span class="line">    <span class="keyword">int32_t</span> arg_int;</span><br><span class="line">    <span class="keyword">char</span> *arg_str;</span><br><span class="line">    <span class="keyword">while</span> (index_char)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index_char != <span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(buf_ptr++) = index_char;</span><br><span class="line">            index_char = *(++index_ptr);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index_char = *(++index_ptr); <span class="comment">// 得到%后面的字符</span></span><br><span class="line">        <span class="keyword">switch</span> (index_char)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            arg_str = va_arg(ap, <span class="keyword">char</span> *);</span><br><span class="line">            <span class="built_in">strcpy</span>(buf_ptr, arg_str);</span><br><span class="line">            buf_ptr += <span class="built_in">strlen</span>(arg_str);</span><br><span class="line">            index_char = *(++index_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">            *(buf_ptr++) = va_arg(ap, <span class="keyword">char</span>);</span><br><span class="line">            index_char = *(++index_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">            arg_int = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">            <span class="comment">/* 若是负数, 将其转为正数后,再正数前面输出个负号'-'. */</span></span><br><span class="line">            <span class="keyword">if</span> (arg_int &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arg_int = <span class="number">0</span> - arg_int;</span><br><span class="line">                *buf_ptr++ = <span class="string">'-'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            itoa(arg_int, &amp;buf_ptr, <span class="number">10</span>);</span><br><span class="line">            index_char = *(++index_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'x'</span>:</span><br><span class="line">            arg_int = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">            itoa(arg_int, &amp;buf_ptr, <span class="number">16</span>);</span><br><span class="line">            index_char = *(++index_ptr); <span class="comment">// 跳过格式字符并更新index_char</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用就是对format进行解析，这里只处理了 % 后面接单个字符的情况，总共解析了字符串，字符，整数，16进制整数这些类型。</p>
<p>解析的过程其实就是将原先%x替换成栈中的数据。</p>
<p>比如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"aaa %s"</span>, str);</span><br></pre></td></tr></table></figure></p>
<p>在找到%s后，知道了参数的类型为char*，就调用va_arg得到该参数在栈中的地址，然后将%s替换成栈中的数据。</p>
<p>这三个宏的实现如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* va_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(ap, v) ap = (va_list)&amp;v <span class="comment">// 把ap指向第一个固定参数v</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap, t) *((t *)(ap += 4))  <span class="comment">// ap指向下一个参数并返回其值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(ap) ap = NULL             <span class="comment">// 清除ap</span></span></span><br></pre></td></tr></table></figure></p>
<p>解析完了之后就可以直接通过printf函数调用输出了，顺带也罢sprintf实现了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 同printf不同的地方就是字符串不是写到终端,而是写到buf中 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">sprintf</span>(<span class="keyword">char</span> *buf, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="keyword">uint32_t</span> retval;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    retval = <span class="built_in">vsprintf</span>(buf, format, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 格式化输出字符串format */</span></span><br><span class="line"><span class="keyword">uint32_t</span> <span class="built_in">printf</span>(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format); <span class="comment">// 使args指向format</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 用于存储拼接后的字符串</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(buf, format, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到printf函数确实是通过系统调用write实现的。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/30/process/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/30/process/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">十二. 实现用户进程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-30 23:57:08" itemprop="dateCreated datePublished" datetime="2018-04-30T23:57:08+08:00">2018-04-30</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h1><p>单核CPU想要实现多任务，唯一的方案就是多个任务共享同一个CPU，也就是让CPU在多个任务间轮转。</p>
<p>CPU执行任务时，需要把任务运行所需要的数据加载到寄存器、栈和内存中，因为CPU只能直接处理这些数据，这是CPU在设计上就直接决定的。任务的数据和指令是CPU的处理对象，任务的执行会占用寄存器和内存。</p>
<p>内存相对于CPU来说是低速设备，里面的数据往往被加载到高速寄存器之后被CPU处理，再将结果写到内存中。所以寄存器中的数据就是当前任务的最新状态。采用轮流使用CPU的方式运行多任务，在当前任务被换下CPU的时候，任务的状态应该被保存一份，TSS就是用来关联任务的。</p>
<p>TSS(任务状态段)是由程序员来提供，CPU进行维护。程序员提供是指需要我们定义一个结构体，里面存放任务要用的寄存器数据。CPU维护是指切换任务时，CPU会自动把旧任务的数据存放的结构体变量中，然后将新任务的TSS数据加载到相应的寄存器中</p>
<p>TSS和之前所说的段一样，本质上也是一片存储数据的内存区域，CPU用这块内存区域保存任务的最新状态。所以也需要一个描述符结构来表示它，这个描述符就是TSS描述符，它的结构如下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/km3jBH77lI.png?imageslim" alt="TSS描述符"></p>
<p>这个描述符主要关注于它type字段中的B位，B位为1时表示任务繁忙。</p>
<p>任务繁忙有两方面的意义，一是此任务正在CPU上运行，二是此任务嵌套调用了新的任务，CPU此时正在执行这个新的任务，此任务暂时挂起，等到新任务运行完了之后返回此任务继续执行</p>
<p>这个B位是由CPU自动维护的，任务被调到上CPU的时候，CPU自动将此B位置1，被换下CPU的时候，自动将其置0</p>
<p>前面说的TSS描述符是用来描述TSS的，TSS的结构如下图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/2mlGgEAJLd.png?imageslim" alt="TSS结构"></p>
<p>TSS结构中的数据就是我们保存任务时需要存储的数据，我们提供的保存TSS的数据结构也要照着这个设计。</p>
<h1 id="Linux中采用的任务切换方式"><a href="#Linux中采用的任务切换方式" class="headerlink" title="Linux中采用的任务切换方式"></a>Linux中采用的任务切换方式</h1><p>Linux为了提高任务切换的速度，通过如下方式来进行任务切换</p>
<p>一个CPU上的所有任务共享一个TSS，通过TR寄存器保存这个TSS，在使用ltr指令加载TSS之后，该TR寄存器永远指向同一个TSS，之后在进行任务切换的时候也不会重新加载TSS，只需要把TSS中的SS0和esp0更新为新任务的内核栈的段地址及栈指针。</p>
<p>在当初硬件厂商设计TSS的时候，本意是想让一个任务保存一份TSS，这样在切换任务的时候，重新从内存中加载TSS，让TR寄存器指向该TSS，从而实现任务切换。但是这种方式切换任务，每次都要从内存中加载数据，对于CPU来说，速度太慢了，而且切换的步骤也十分繁琐。</p>
<p>Linux的任务切换方式只需要修改TSS中的SS0和esp0，进行任务切换的速度当然是大幅度提升了。</p>
<h1 id="初始化TSS"><a href="#初始化TSS" class="headerlink" title="初始化TSS"></a>初始化TSS</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任务状态段tss结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> backlink;</span><br><span class="line">    <span class="keyword">uint32_t</span>* esp0;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss0;</span><br><span class="line">    <span class="keyword">uint32_t</span>* esp1;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss1;</span><br><span class="line">    <span class="keyword">uint32_t</span>* esp2;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss2;</span><br><span class="line">    <span class="keyword">uint32_t</span> cr3;</span><br><span class="line">    <span class="keyword">uint32_t</span> (*eip) (<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> eflags;</span><br><span class="line">    <span class="keyword">uint32_t</span> eax;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> es;</span><br><span class="line">    <span class="keyword">uint32_t</span> cs;</span><br><span class="line">    <span class="keyword">uint32_t</span> ss;</span><br><span class="line">    <span class="keyword">uint32_t</span> ds;</span><br><span class="line">    <span class="keyword">uint32_t</span> fs;</span><br><span class="line">    <span class="keyword">uint32_t</span> gs;</span><br><span class="line">    <span class="keyword">uint32_t</span> ldt;</span><br><span class="line">    <span class="keyword">uint32_t</span> trace;</span><br><span class="line">    <span class="keyword">uint32_t</span> io_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该TSS的结构完全是根据上面图中所需而定义的。</p>
<p>TSS的初始化工作主要是初始化TSS结构的ss0和esp0，然后将TSS描述符加载到全局描述符表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_tss_esp</span><span class="params">(task_struct* pthread)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tss.esp0 = (<span class="keyword">uint32_t</span>*)((<span class="keyword">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct gdt_desc <span class="title">make_gdt_desc</span><span class="params">(<span class="keyword">uint32_t</span>* desc_addr, <span class="keyword">uint32_t</span> limit, <span class="keyword">uint8_t</span> attr_low, <span class="keyword">uint8_t</span> attr_high)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> desc_base = (<span class="keyword">uint32_t</span>)desc_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gdt_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.limit_low_word = limit &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_low_word = desc_base &amp; <span class="number">0x0000ffff</span>;</span><br><span class="line">    desc.base_mid_byte = ((desc_base &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    desc.attr_low_byte = (<span class="keyword">uint8_t</span>)(attr_low);</span><br><span class="line">    desc.limit_high_attr_high = (((limit &amp; <span class="number">0x000f0000</span>) &gt;&gt; <span class="number">16</span>) + (<span class="keyword">uint8_t</span>)(attr_high));</span><br><span class="line">    desc.base_high_byte = desc_base &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tss_init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    put_str(<span class="string">"tss_init start\n"</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> tss_size = <span class="keyword">sizeof</span>(tss);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tss, <span class="number">0</span>, tss_size);</span><br><span class="line">    tss.ss0 = SELECTOR_K_STACK;</span><br><span class="line">    tss.io_base = tss_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* gdt段基址为0x900,把tss放到第4个位置,也就是0x900+0x20的位置 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为0的TSS描述符 */</span></span><br><span class="line">    *((struct gdt_desc*)<span class="number">0xc0000920</span>) = make_gdt_desc((<span class="keyword">uint32_t</span>*)&amp;tss, tss_size - <span class="number">1</span>, TSS_ATTR_LOW, TSS_ATTR_HIGH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在gdt中添加dpl为3的数据段和代码段描述符 */</span></span><br><span class="line">    *((struct gdt_desc*)<span class="number">0xc0000928</span>) = make_gdt_desc((<span class="keyword">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">    *((struct gdt_desc*)<span class="number">0xc0000930</span>) = make_gdt_desc((<span class="keyword">uint32_t</span>*)<span class="number">0</span>, <span class="number">0xfffff</span>, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/* gdt 16位的limit 32位的段基址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> gdt_operand = ((<span class="number">8</span> * <span class="number">7</span> - <span class="number">1</span>) | ((<span class="keyword">uint64_t</span>)(<span class="keyword">uint32_t</span>)<span class="number">0xc0000900</span> &lt;&lt; <span class="number">16</span>));   <span class="comment">// 7个描述符大小</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"lgdt %0"</span> : : <span class="string">"m"</span> (gdt_operand))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"ltr %w0"</span> : : <span class="string">"r"</span> (SELECTOR_TSS))</span></span>;</span><br><span class="line">    put_str(<span class="string">"tss_init and ltr done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的步骤TSS描述符就被加载到gdt中了，可以直接在模拟器中观察当前gdt的数据</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/lAghbc8JFJ.png?imageslim" alt="gdt数据"></p>
<h1 id="实现用户进程"><a href="#实现用户进程" class="headerlink" title="实现用户进程"></a>实现用户进程</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现进程的过程是在之前的线程基础上进行的，在当初创建线程的时候是将栈的返回地址指向了kernel_thread函数，通过该函数调用线程函数实现的，其执行流程如下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/fjGHAkkHGf.png?imageslim" alt="线程函数执行流程"></p>
<p>这里我们只需要把执行线程的函数换成创建进程的函数就可以啦。</p>
<p>进程与线程最大的区别就每个进程都拥有单独的4GB虚拟地址空间，所以，需要单独为每个进程维护一个虚拟地址池，用来标记该进程中哪些地址被分配了，哪些地址没有被分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *self_kstack; <span class="comment">// 内核线程的栈顶地址</span></span><br><span class="line">    task_status status;    <span class="comment">// 当前线程的状态</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> priority;</span><br><span class="line">    <span class="keyword">uint8_t</span> ticks;  <span class="comment">// 线程执行的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> elapsed_ticks;  <span class="comment">// 线程已经执行的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> *pgdir; <span class="comment">//进程页表的虚拟地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span> <span class="title">userprog_vaddr</span>;</span> <span class="comment">// 用户进程的虚拟地址池</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">uint32_t</span> stack_magic;   <span class="comment">// 栈的边界标记，用来检测栈溢出</span></span><br><span class="line">&#125;task_struct;</span><br></pre></td></tr></table></figure>
<p>该结构是进程线程通用的，是用来管理进程或线程数据的。有些数据是进程特用的，这样在线程使用该结构的时候只需要将这些数据置0即可。在这里将这个结构作为进程的pcb使用。</p>
<h2 id="为用户进程创建页表"><a href="#为用户进程创建页表" class="headerlink" title="为用户进程创建页表"></a>为用户进程创建页表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在虚拟内存池中申请pg_cnt个虚拟页</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vaddr_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...内核内存池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户内存池</span></span><br><span class="line">        task_struct *cur = running_thread();</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span>(bit_idx_start == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; pg_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            bitmap_set(&amp;cur-&gt;userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vaddr_start = cur-&gt;userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line"></span><br><span class="line">        ASSERT((<span class="keyword">uint32_t</span>)vaddr_start &lt; (<span class="number">0xc0000000</span> - PG_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_user_pages</span><span class="params">(<span class="keyword">uint32_t</span> pg_cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock_acquire(&amp;user_pool.lock);</span><br><span class="line">    <span class="keyword">void</span> *vaddr = malloc_page(PF_USER, pg_cnt);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    lock_release(&amp;user_pool.lock);</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进入3特权级"><a href="#进入3特权级" class="headerlink" title="进入3特权级"></a>进入3特权级</h2><p>到目前为止我们一直工作在0级特权级下，这里既然是模仿操作系统的实现，用户进程肯定还是要工作在3特权级下的。这个kernel再简陋，基本的功能还是要有的。</p>
<p>一般情况下，CPU不允许从高特权级转向低特权级，只有从中断返回或者从调用门返回的情况下才可以。</p>
<p>这里采用从中断返回的方式进入3特权级。由于目前还没有用户进程，也就别谈从中断返回了，都没有进入中断何谈从中断返回呢，这里就只能再次欺骗一下CPU，就像之前创建线程一样，制造从中断返回的条件，执行iretd指令了。</p>
<p>iretd指令会用带栈中的数据作为返回地址，还会加载栈中的eflags的值到eflags寄存器，如果栈中的cs.rpl为更低的特权级，处理器的特权级检查通过之后会将栈中的cs载入到CS寄存器。从中断返回的过程就是进入中断的逆过程，所以我们只需要在栈中准备好数据，调用iretd指令即可。</p>
<p>构建用户进程初始上下文信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_process</span><span class="params">(<span class="keyword">void</span> *filename_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *function = filename_;</span><br><span class="line">    task_struct *cur = running_thread();</span><br><span class="line">    cur-&gt;self_kstack += <span class="keyword">sizeof</span>(thread_stack);</span><br><span class="line">    intr_stack *proc_stack = (struct intr_stack *)cur-&gt;self_kstack;</span><br><span class="line">    proc_stack-&gt;edi = proc_stack-&gt;esi = proc_stack-&gt;ebp = proc_stack-&gt;esp_dummy = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;ebx = proc_stack-&gt;edx = proc_stack-&gt;ecx = proc_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line">    proc_stack-&gt;gs = <span class="number">0</span>; <span class="comment">// 用户态用不上,直接初始为0</span></span><br><span class="line">    proc_stack-&gt;ds = proc_stack-&gt;es = proc_stack-&gt;fs = SELECTOR_U_DATA;</span><br><span class="line">    proc_stack-&gt;eip = function; <span class="comment">// 待执行的用户程序地址</span></span><br><span class="line">    proc_stack-&gt;cs = SELECTOR_U_CODE;</span><br><span class="line">    proc_stack-&gt;eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);</span><br><span class="line">    proc_stack-&gt;esp = (<span class="keyword">void</span> *)((<span class="keyword">uint32_t</span>)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE);</span><br><span class="line">    proc_stack-&gt;ss = SELECTOR_U_DATA;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movl %0, %%esp; jmp intr_exit"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 :</span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"g"</span>(proc_stack)</span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>激活页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 激活页表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_dir_activate</span><span class="params">(task_struct *p_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 若为内核线程,需要重新填充页表为0x100000 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pagedir_phy_addr = <span class="number">0x100000</span>; <span class="comment">// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir != <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// 用户态进程有自己的页目录表</span></span><br><span class="line">        pagedir_phy_addr = addr_v2p((<span class="keyword">uint32_t</span>)p_thread-&gt;pgdir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新页目录寄存器cr3,使新页表生效 */</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movl %0, %%cr3"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 :</span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"r"</span>(pagedir_phy_addr)</span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 激活线程或进程的页表,更新tss中的esp0为进程的特权级0的栈 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_activate</span><span class="params">(task_struct *p_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(p_thread != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 击活该进程或线程的页表 */</span></span><br><span class="line">    page_dir_activate(p_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */</span></span><br><span class="line">    <span class="keyword">if</span> (p_thread-&gt;pgdir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 更新该进程的esp0,用于此进程被中断时保留上下文 */</span></span><br><span class="line">        update_tss_esp(p_thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建用户进程的页目录表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> *create_page_dir(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *page_dir_vaddr = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_dir_vaddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        console_put_str(<span class="string">"create_page_dir: get_kernel_page failed!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************** 1  先复制页表  *************************************/</span></span><br><span class="line">    <span class="comment">/*  page_dir_vaddr + 0x300*4 是内核页目录的第768项 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">uint32_t</span> *)((<span class="keyword">uint32_t</span>)page_dir_vaddr + <span class="number">0x300</span> * <span class="number">4</span>), (<span class="keyword">uint32_t</span> *)(<span class="number">0xfffff000</span> + <span class="number">0x300</span> * <span class="number">4</span>), <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/*****************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************** 2  更新页目录地址 **********************************/</span></span><br><span class="line">    <span class="keyword">uint32_t</span> new_page_dir_phy_addr = addr_v2p((<span class="keyword">uint32_t</span>)page_dir_vaddr);</span><br><span class="line">    <span class="comment">/* 页目录地址是存入在页目录的最后一项,更新页目录地址为新页目录的物理地址 */</span></span><br><span class="line">    page_dir_vaddr[<span class="number">1023</span>] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">    <span class="comment">/*****************************************************************************/</span></span><br><span class="line">    <span class="keyword">return</span> page_dir_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建用户进程虚拟地址位图 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_user_vaddr_bitmap</span><span class="params">(task_struct *user_prog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_start = USER_VADDR_START;</span><br><span class="line">    <span class="keyword">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>, PG_SIZE);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">    user_prog-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>;</span><br><span class="line">    bitmap_init(&amp;user_prog-&gt;userprog_vaddr.vaddr_bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建用户进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建用户进程 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_execute</span><span class="params">(<span class="keyword">void</span> *filename, <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */</span></span><br><span class="line">    task_struct *thread = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">    init_thread(thread, name, default_prio);</span><br><span class="line">    create_user_vaddr_bitmap(thread);</span><br><span class="line">    thread_create(thread, start_process, filename);</span><br><span class="line">    thread-&gt;pgdir = create_page_dir();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    ASSERT(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line"></span><br><span class="line">    ASSERT(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用户进程一般是由加载器将用户程序加载到内存中，再根据其文件格式解析里面的内容，将程序的段加载到相应的内存地址，CS:EIP指向程序的入口地址，程序便执行起来了。由于目前还没有实现文件系统，只能通过函数来模拟进程的执行，但是产生的效果是一样的。</p>
<p>进程的创建便完成了。由于目前只能模拟一下进程的运行，所以模拟运行的线程函数任然运行在内核空间中，但是进程该有的属性都有了，比如3特权级，自己单独的页表，3特权级栈等。拥有了这些属性就可以称之为一个用户进程</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/lbj97jH421.png?imageslim" alt="mark"></p>
<p>这是运行了进程函数之后cs的值，其低2位的值为11，也就是rpl=3，目前确实运行在3特权级下.</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/30/sync/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/30/sync/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">十一. 线程同步</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-30 20:58:56" itemprop="dateCreated datePublished" datetime="2018-04-30T20:58:56+08:00">2018-04-30</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="乱序输出"><a href="#乱序输出" class="headerlink" title="乱序输出"></a>乱序输出</h1><p>前面完成了多线程之后，那么肯定会涉及到线程的同步问题。因为线程的执行是随机的，乱序的。虽然我们这个小kernel实现的调度器算法比较简陋，它的随机性没那么强，但是每次进行线程切换的时候，还是有可能产生问题。并且问题已经产生了。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/KjE2G4eK79.png?imageslim" alt="乱序输出"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    put_str(<span class="string">"I am kernel\n"</span>);</span><br><span class="line">    init_all();</span><br><span class="line">    thread_start(<span class="string">"thread_a"</span>, <span class="number">31</span>, k_thread, <span class="string">"argA "</span>);</span><br><span class="line">    thread_start(<span class="string">"thread_b"</span>, <span class="number">8</span>, k_thread, <span class="string">"argB "</span>);</span><br><span class="line">    intr_enable();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        put_str(<span class="string">"Main "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在线程中运行的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       put_str((<span class="keyword">char</span>*)arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生这总结果的原因是由上面这段代码所致。</p>
<p>我们预期的输出结果应该是这样的</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/m4HLlK2I3k.png?imageslim" alt="mark"></p>
<p>可以看到，上面的输出结果显得比较杂乱，主要是字符串的交界处，会出现却字符，多空格的现象。而且还引发了GP异常。</p>
<p>这个结果正是证实了之前所说的，每发生一次线程切换，都有可能带来问题。</p>
<p>而带来问题的原因就是这个里面的put_str函数。</p>
<p>这个函数主要做了三个事情实现打印</p>
<ol>
<li>获取光标值</li>
<li>将光标值转换为显存地址，在此地址处写入字符</li>
<li>更新光标的值</li>
</ol>
<p>很明显这三步应该同时完成，不可拆分的。那么想象一下这种情况，线程1执行完了第一步之后，时间片用完，就被换下了CPU。现在轮到线程2执行，线程2又会执行第一步，且这个第一步获取到的光标值会和之前线程1获取到的一样。然后线程2开始向后打印。</p>
<p>终于又轮到线程1执行了，当时他是执行到第一步，那么接下来他就开始执行第二步。可以看到，问题就已经产生了。线程1获取到的光标值早就被线程2用到了，那么线程1在打印的过程中就会覆盖线程2打印的数据。</p>
<p>这个是输出的混乱问题，引发GP异常的原因主要是由于这个简陋的滚屏操作所致，在滚屏的过程中产生了线程切换，导致最后获取到的显存地址会超过显存段而引发的GP异常</p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>既然要进行线程同步，那么肯定要在需要同步的地方阻止线程的切换。这里主要通过信号量的机制对公共资源加锁，达到同步的目的。</p>
<p>信号量的原理本省比较简单。通过P、V操作来表示信号量的增减。</p>
<p>P、V操作的执行过程</p>
<p>P操作，减少信号量</p>
<ol>
<li>判断信号量是否大于0</li>
<li>如果大于0， 将其减一</li>
<li>如果小于0，将当前线程阻塞</li>
</ol>
<p>V操作，增加信号量</p>
<ol>
<li>将信号量的值加一</li>
<li>唤醒等待的线程</li>
</ol>
<p>信号量是一个全局的共享资源，所以对其进行增减操作的时候必须是原子操作，这个原子操作通过关中断来实现。</p>
<p>将线程阻塞的操作也很容易实现，只需要将其从就绪队列中移除即可，下面简单的看一下实现过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信号量结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">uint8_t</span>  value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">list</span> <span class="title">waiters</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 锁结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   task_struct* holder; <span class="comment">// 锁的持有者</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">semaphore</span> <span class="title">semaphore</span>;</span> <span class="comment">// 用二元信号量实现锁</span></span><br><span class="line">   <span class="keyword">uint32_t</span> holder_repeat_nr; <span class="comment">// 锁的持有者重复申请锁的次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>P操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信号量down操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_down</span><span class="params">(struct semaphore *psema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 关中断来保证原子操作 */</span></span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    <span class="keyword">while</span> (psema-&gt;value == <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 若value为0,表示已经被别人持有</span></span><br><span class="line">        ASSERT(!elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag));</span><br><span class="line">        <span class="comment">/* 当前线程不应该已在信号量的waiters队列中 */</span></span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag))</span><br><span class="line">        &#123;</span><br><span class="line">            PANIC(<span class="string">"sema_down: thread blocked has been in waiters_list\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */</span></span><br><span class="line">        list_append(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag);</span><br><span class="line">        thread_block(TASK_BLOCKED); <span class="comment">// 阻塞线程,直到被唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/</span></span><br><span class="line">    psema-&gt;value--;</span><br><span class="line">    ASSERT(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>V操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 信号量的up操作 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_up</span><span class="params">(struct semaphore *psema)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 关中断,保证原子操作 */</span></span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    ASSERT(psema-&gt;value == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;psema-&gt;waiters))</span><br><span class="line">    &#123;</span><br><span class="line">        task_struct *thread_blocked = elem2entry(task_struct, general_tag, list_pop(&amp;psema-&gt;waiters));</span><br><span class="line">        thread_unblock(thread_blocked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    psema-&gt;value++;</span><br><span class="line">    ASSERT(psema-&gt;value == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 恢复之前的中断状态 */</span></span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取锁和释放锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取锁plock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_acquire</span><span class="params">(struct lock *plock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 排除曾经自己已经持有锁但还未将其释放的情况。*/</span></span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder != running_thread())</span><br><span class="line">    &#123;</span><br><span class="line">        sema_down(&amp;plock-&gt;semaphore); <span class="comment">// 对信号量P操作,原子操作</span></span><br><span class="line">        plock-&gt;holder = running_thread();</span><br><span class="line">        ASSERT(plock-&gt;holder_repeat_nr == <span class="number">0</span>);</span><br><span class="line">        plock-&gt;holder_repeat_nr = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放锁plock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_release</span><span class="params">(struct lock *plock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(plock-&gt;holder == running_thread());</span><br><span class="line">    <span class="keyword">if</span> (plock-&gt;holder_repeat_nr &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        plock-&gt;holder_repeat_nr--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(plock-&gt;holder_repeat_nr == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    plock-&gt;holder = <span class="literal">NULL</span>; <span class="comment">// 把锁的持有者置空放在V操作之前</span></span><br><span class="line">    plock-&gt;holder_repeat_nr = <span class="number">0</span>;</span><br><span class="line">    sema_up(&amp;plock-&gt;semaphore); <span class="comment">// 信号量的V操作,也是原子操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>阻塞线程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当前线程将自己阻塞,标志其状态为stat. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_block</span><span class="params">(task_status stat)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/</span></span><br><span class="line">    ASSERT(stat == TASK_BLOCKED || stat == TASK_WAITING || stat == TASK_HANGING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    task_struct* cur_thread = running_thread();</span><br><span class="line"></span><br><span class="line">    cur_thread-&gt;status = stat; <span class="comment">// 置其状态为stat </span></span><br><span class="line">    schedule();            <span class="comment">// 将当前线程换下处理器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */</span></span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>唤醒线程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将线程pthread解除阻塞 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_unblock</span><span class="params">(task_struct* pthread)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    ASSERT((pthread-&gt;status == TASK_BLOCKED) || (pthread-&gt;status == TASK_WAITING) || (pthread-&gt;status == TASK_HANGING));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread-&gt;status != TASK_READY) </span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(!elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elem_find(&amp;thread_ready_list, &amp;pthread-&gt;general_tag)) </span><br><span class="line">        &#123;</span><br><span class="line">            PANIC(<span class="string">"thread_unblock: blocked thread in ready_list\n"</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        list_push(&amp;thread_ready_list, &amp;pthread-&gt;general_tag);    <span class="comment">// 放到队列的最前面,使其尽快得到调度</span></span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">   &#125;   </span><br><span class="line">   intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/30/thread/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/30/thread/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">十. 内核线程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-30 00:06:30" itemprop="dateCreated datePublished" datetime="2018-04-30T00:06:30+08:00">2018-04-30</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现线程函数"><a href="#实现线程函数" class="headerlink" title="实现线程函数"></a>实现线程函数</h1><p>观察一下这段c语言代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread function\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main function\n"</span>);</span><br><span class="line">	</span><br><span class="line">	_beginthread(threadFunc, <span class="number">0</span>, <span class="literal">NULL</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是举个简单的例子，没有考虑错误处理和资源回收。</p>
<p>在程序中，在main函数中输出了一句话，然后开启一个线程，然后让这个线程也输出一句话。通过这个简单的例子差不多就可以建立线程最初的印象了，线程就是运行一段函数的载体。</p>
<p>我在刚开始接触线程的时候对它的理解是这样的：</p>
<p>在一个程序中，至少是有一条线程的，那就是主线程。这个主线程和普通线程也是类似的。它也是运行一段函数的载体，但是它是入口函数运行的载体。这个入口函数放到c语言里面来讲就是平时所用的main函数。</p>
<p>线程的生命周期就是它执行的函数的生命周期，当函数执行完成之后，这条线程的使命也就完成了。当然，线程的使命结束了不代表它就消亡了，这条线程也可能被挂起，留待将来有需要时再将其唤醒。</p>
<p>线程才是真正的执行体，进程只是为程序的执行提供资源。</p>
<p>线程的执行时间和顺序根据他的调度策略来。</p>
<p>主线程的存亡代表整个进程的存亡。主线程执行完成之后，代表整个进程要干的活都已经全部干完了，那么此时进程已经没有存在的必要了，它就会被操作系统回收。</p>
<h2 id="线程函数和普通函数的区别"><a href="#线程函数和普通函数的区别" class="headerlink" title="线程函数和普通函数的区别"></a>线程函数和普通函数的区别</h2><p>对线程有了一个基本的理解之后，那么来了解一下，线程执行的函数和平常的函数调用有什么区别？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funca</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    funcb(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">funcb</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通的函数之间发生函数调用的时候，主要的故事都发生在被调用函数的栈中。</p>
<p>首先，备份主调函数的栈，在被调函数的栈顶存放主调函数的返回地址。</p>
<p>然后，根据函数调用约定，在被调函数的栈中存放好要传递的参数。</p>
<p>最后，执行被调函数。</p>
<p>一般的函数调用是随着此函数所在的调度单元一块在处理器上运行的，这个调度单元可能是整个进程，也可能是某个线程。因为线程用也可以发生函数调用嘛。在这个调度单元中，就会保存它所依赖的上下文环境。如寄存器，栈等。</p>
<p>线程是一套机制，它能够为一段代码也就是线程函数创造它所依赖的上下文环境，从而让其具有独立性，可以单独的在处理器上执行。线程函数与普通函数的区别应该就是在这个上下文环境中了。普通函数的上下文环境依赖于执行它的执行流，线程函数想要执行就得创建它的上下文环境。</p>
<p>下面就通过代码简单的模拟一下线程的创建执行过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> tag_task_status</span><br><span class="line">&#123;</span><br><span class="line">    TASK_RUNNING,</span><br><span class="line">    TASK_READY,</span><br><span class="line">    TASK_BLOCKED,</span><br><span class="line">    TASK_WAITING,</span><br><span class="line">    TASK_HANGING,</span><br><span class="line">    TASK_DIED</span><br><span class="line">&#125;task_status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程栈</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_thread_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*eip)(thread_func *func, <span class="keyword">void</span> *func_arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *unused_retaddr;</span><br><span class="line">    thread_func *function;</span><br><span class="line">    <span class="keyword">void</span> *func_arg;</span><br><span class="line">&#125;thread_stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *self_kstack; <span class="comment">// 内核线程的栈顶地址</span></span><br><span class="line">    task_status status;    <span class="comment">// 当前线程的状态</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> priority;</span><br><span class="line">    <span class="keyword">uint32_t</span> stack_magic;   <span class="comment">// 栈的边界标记，用来检测栈溢出</span></span><br><span class="line">&#125;task_struct;</span><br></pre></td></tr></table></figure>
<p>目前只是简单的模拟一下线程的创建执行过程，所以过程比较简单，这里是用到了ret指令的一个小技巧。</p>
<p>平常发生的函数调用都是通过汇编指令call实现的，这个是属于我们主动去调用这个函数。而线程函数并不是我们主动调用的，它是由操作系统的调度器来调用的，时间片分配到了哪个线程上，哪个线程就占有CPU执行代码。这里会通过ret指令来实现伪被动调用，是一种欺骗CPU的办法。</p>
<p>CPU执行哪条指令是通过EIP的指向来决定的，而ret指令在返回的时候，当前的栈顶就会被当做是返回地址，这个返回地址会被赋值给EIP。也就是说，我们可以把某个函数的地址放在栈顶，通过这个函数来执行线程函数。那么在ret返回的时候，就会进入我们指定的函数当中，这个函数就会来调用线程函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化线程基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_thread</span><span class="params">(task_struct* pthread, <span class="keyword">char</span>* name, <span class="keyword">int</span> prio)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(*pthread));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line"></span><br><span class="line">    pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;ticks = prio;</span><br><span class="line">    pthread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self_kstack是线程自己在内核态下使用的栈顶地址 </span></span><br><span class="line">    pthread-&gt;self_kstack = (<span class="keyword">uint32_t</span>*)((<span class="keyword">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19971234</span>;     <span class="comment">// 自定义的魔数，检查栈溢出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_create</span><span class="params">(task_struct* pthread, thread_func function, <span class="keyword">void</span>* func_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先预留中断使用栈的空间</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(intr_stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留出线程栈空间</span></span><br><span class="line">    pthread-&gt;self_kstack -= <span class="keyword">sizeof</span>(thread_stack);</span><br><span class="line"></span><br><span class="line">    thread_stack* kthread_stack = (thread_stack*)pthread-&gt;self_kstack; </span><br><span class="line">    kthread_stack-&gt;eip = kernel_thread;</span><br><span class="line">    kthread_stack-&gt;function = function;</span><br><span class="line">    kthread_stack-&gt;func_arg = func_arg;</span><br><span class="line">    kthread_stack-&gt;ebp = kthread_stack-&gt;ebx = kthread_stack-&gt;esi = kthread_stack-&gt;edi = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数主要是对线程的信心进程初始化。由于栈是向下增长的，所以在init中，首先让其指向了分配的线程空间(也就是一页大小的空间，下面可以看到)的最高地址处，然后在create_thread函数中，首先留出了一块空间，这个是将来线程调度时会使用到的中断栈，再留出线程栈的空间，方便从下往上填充数据。此时栈的数据如下。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180429/BC5Gh68Fkm.png?imageslim" alt="线程栈"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kernel_thread</span><span class="params">(thread_func *function, <span class="keyword">void</span> *func_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    function(func_arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一优先级为prio的线程,线程名为name,线程所执行的函数是function(func_arg) </span></span><br><span class="line"><span class="function">task_struct* <span class="title">thread_start</span><span class="params">(<span class="keyword">char</span>* name, <span class="keyword">int</span> prio, thread_func function, <span class="keyword">void</span>*  func_arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// pcb都位于内核空间,包括用户进程的pcb也是在内核空间</span></span><br><span class="line">    task_struct* thread = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret"</span>  : : <span class="string">"g"</span> (thread-&gt;self_kstack) : <span class="string">"memory"</span>)</span></span>;     </span><br><span class="line">    <span class="keyword">return</span> thread;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_start就是开启线程的接口函数，在调用的时候主要是通过里面的内联汇编进入到线程函数中，该内联汇编的主要作用是准备好数据之后执行ret，此时会从栈顶会得到返回地址，该地址也就是上面赋值的eip，也就是kernel_thread的地址，然后执行该函数，kernel_thread从栈中得到参数，也就是栈顶+4的真正要执行的线程函数地址，和栈顶+8的线程函数所需的参数。</p>
<h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>上面简单的模拟了一下线程的创建，但是没有实现线程的调度工作，所以创建线程之后，CPU只会在该线程上执行，所以表现出来还是单线程。</p>
<p>这里会采用轮询算法实现多线程的调度工作。每产生一个时钟中断就算是一个时钟周期，当前线程的时钟周期执行完了之后，就会将该线程放到队尾，换下一个线程执行。</p>
<p>每一个线程所能执行的时钟周期由它的优先级决定。</p>
<p>用了一个双向链表来存储线程的节点信息，该双向链表结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化线程信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *self_kstack; <span class="comment">// 内核线程的栈顶地址</span></span><br><span class="line">    task_status status;    <span class="comment">// 当前线程的状态</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> ticks;  <span class="comment">// 线程执行的时间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> elapsed_ticks;  <span class="comment">// 线程已经执行的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">general_tag</span>;</span>  <span class="comment">// 就绪线程节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">all_list_tag</span>;</span> <span class="comment">// 所有线程的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> stack_magic;   <span class="comment">// 栈的边界标记，用来检测栈溢出</span></span><br><span class="line">&#125;task_struct;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化线程基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_thread</span><span class="params">(task_struct* pthread, <span class="keyword">char</span>* name, <span class="keyword">int</span> prio)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pthread, <span class="number">0</span>, <span class="keyword">sizeof</span>(task_struct));</span><br><span class="line">    <span class="built_in">strcpy</span>(pthread-&gt;name, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread == main_thread)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread-&gt;status = TASK_RUNNING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread-&gt;status = TASK_READY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread-&gt;priority = prio;</span><br><span class="line">    pthread-&gt;ticks = prio;</span><br><span class="line">    pthread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// self_kstack是线程自己在内核态下使用的栈顶地址 </span></span><br><span class="line">    pthread-&gt;self_kstack = (<span class="keyword">uint32_t</span>*)((<span class="keyword">uint32_t</span>)pthread + PG_SIZE);</span><br><span class="line">    pthread-&gt;stack_magic = <span class="number">0x19971234</span>;     <span class="comment">// 自定义的魔数，检查栈溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建线程时将线程添加进链表中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一优先级为prio的线程,线程名为name,线程所执行的函数是function(func_arg) </span></span><br><span class="line"><span class="function">task_struct* <span class="title">thread_start</span><span class="params">(<span class="keyword">char</span>* name, <span class="keyword">int</span> prio, thread_func function, <span class="keyword">void</span>*  func_arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// pcb都位于内核空间,包括用户进程的pcb也是在内核空间</span></span><br><span class="line">    task_struct* thread = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    init_thread(thread, name, prio);</span><br><span class="line">    thread_create(thread, function, func_arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    ASSERT(!elem_find(&amp;thread_ready_list, &amp;thread-&gt;general_tag));</span><br><span class="line">    <span class="comment">/* 加入就绪线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_ready_list, &amp;thread-&gt;general_tag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保之前不在队列中 */</span></span><br><span class="line">    ASSERT(!elem_find(&amp;thread_all_list, &amp;thread-&gt;all_list_tag));</span><br><span class="line">    <span class="comment">/* 加入全部线程队列 */</span></span><br><span class="line">    list_append(&amp;thread_all_list, &amp;thread-&gt;all_list_tag);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> thread;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化内核主线程。</p>
<p>在当初写内核加载器的时候，内核的栈就已将预留出来了。当时内核的入口地址是0xc009f000。内核的栈地址在0xc009e000处，这块空间时不需要额外进行分配的。由于目前已知运行在内核上，可以通过running_thread()直接获取到该页的起始地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task_struct *<span class="title">running_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> (<span class="string">"mov %%esp, %0"</span> : <span class="string">"=g"</span> (esp));</span><br><span class="line">    <span class="keyword">return</span> (task_struct *)(esp &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_main_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    main_thread = running_thread();</span><br><span class="line">    init_thread(main_thread, <span class="string">"main"</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">    ASSERT(!elem_find(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag));</span><br><span class="line">    list_append(&amp;thread_all_list, &amp;main_thread-&gt;all_list_tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程调度器</p>
<p>该调度器会在线程的时间片用完之后被调用。如果该线程是在运行态因为时间片用完的情况下，直接将其加入到就绪队列的队尾。因为其他原因被挂起的情况暂不处理。</p>
<p>然后会从就绪队列中取出下一个节点。该节点是就绪线程的节点地址。也就是task_struct中的general_tag地址，需要通过该地址找到task_struct的首地址。这里通过宏来实现，实现过程也很简单。用该节点的地址 - general_tag在task_struct中的偏移即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offset(struct_type, member) (int)(&amp;((struct_type*)0)-&gt;member)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> elem2entry(struct_type, struct_member_name, elem_ptr) \</span></span><br><span class="line">(struct_type*)((<span class="keyword">int</span>)elem_ptr - offset(struct_type, struct_member_name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(intr_get_status() == INTR_OFF);</span><br><span class="line"></span><br><span class="line">    task_struct* cur = running_thread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;status == TASK_RUNNING) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 若此线程只是cpu时间片到了,将其加入到就绪队列尾</span></span><br><span class="line">        ASSERT(!elem_find(&amp;thread_ready_list, &amp;cur-&gt;general_tag));</span><br><span class="line">        list_append(&amp;thread_ready_list, &amp;cur-&gt;general_tag);</span><br><span class="line">        cur-&gt;ticks = cur-&gt;priority;     <span class="comment">// 重新将当前线程的ticks再重置为其priority;</span></span><br><span class="line">        cur-&gt;status = TASK_READY;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">/* 若此线程需要某事件发生后才能继续上cpu运行,</span></span><br><span class="line"><span class="comment">       不需要将其加入队列,因为当前线程不在就绪队列中。*/</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    ASSERT(!list_empty(&amp;thread_ready_list));</span><br><span class="line">    thread_tag = <span class="literal">NULL</span>;     <span class="comment">// thread_tag清空</span></span><br><span class="line">    <span class="comment">/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */</span></span><br><span class="line">    thread_tag = list_pop(&amp;thread_ready_list);</span><br><span class="line">    task_struct* next = elem2entry(task_struct, general_tag, thread_tag);</span><br><span class="line">    next-&gt;status = TASK_RUNNING;</span><br><span class="line">    switch_to(cur, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch_to函数用来实现线程的切换，它需要做的就是保存当前环境，进入到另一个线程当中，进入的方式就是通过前面介绍的ret指令</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">bits</span> <span class="number">32</span>] </span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="meta">global</span> switch_to</span><br><span class="line"><span class="symbol">switch_to:</span></span><br><span class="line">    <span class="comment">;栈中此处是返回地址         </span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">esi</span> </span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">edi</span> </span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebx</span> </span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebp</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esp</span> + <span class="number">20</span>]       <span class="comment">; 得到栈中的参数cur, cur = [esp+20]</span></span><br><span class="line">    <span class="keyword">mov</span> [<span class="built_in">eax</span>], <span class="built_in">esp</span>                <span class="comment">; 保存栈顶指针esp. task_struct的self_kstack字段,</span></span><br><span class="line">                  <span class="comment">; self_kstack在task_struct中的偏移为0,</span></span><br><span class="line">                  <span class="comment">; 所以直接往thread开头处存4字节便可。</span></span><br><span class="line"><span class="comment">;------------------  以上是备份当前线程的环境，下面是恢复下一个线程的环境  ----------------</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, [<span class="built_in">esp</span> + <span class="number">24</span>]       <span class="comment">; 得到栈中的参数next, next = [esp+24]</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esp</span>, [<span class="built_in">eax</span>]        <span class="comment">; pcb的第一个成员是self_kstack成员,用来记录0级栈顶指针,</span></span><br><span class="line">                  <span class="comment">; 用来上cpu时恢复0级栈,0级栈中保存了进程或线程所有信息,包括3级栈指针</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebp</span> </span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebx</span> </span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">edi</span> </span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">esi</span> </span><br><span class="line">    <span class="keyword">ret</span>               <span class="comment">; 返回到上面switch_to下面的那句注释的返回地址,</span></span><br><span class="line">                  <span class="comment">; 未由中断进入,第一次执行时会返回到kernel_thread</span></span><br></pre></td></tr></table></figure>
<p>时钟中断号是0x20，没发生一次时钟中断，就要将当前线程的可执行时间片减一，直到他时间片用完，进行线程调度。下面是时钟中断处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intr_timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_struct *cur_thread = running_thread();</span><br><span class="line"></span><br><span class="line">    ASSERT(cur_thread-&gt;stack_magic == <span class="number">0x19971234</span>);</span><br><span class="line"></span><br><span class="line">    cur_thread-&gt;elapsed_ticks++;</span><br><span class="line"></span><br><span class="line">    ticks++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur_thread-&gt;ticks == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cur_thread-&gt;ticks--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程调度总算是差不多了。个人感觉还有很多地方理解不到位，里面如果有错误，还望指出。</p>
<p>运行一下看看结果如何</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180430/m4HLlK2I3k.png?imageslim" alt="mark"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/memory_alloc/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/25/memory_alloc/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">九. 内核的内存分配</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-25 15:01:08" itemprop="dateCreated datePublished" datetime="2018-04-25T15:01:08+08:00">2018-04-25</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面已经准备好了内存池，这里就要正式实现内存的分配了。因为到目前为止，还没有用户进程，所以这里只实现内核中的动态内存分配。</p>
<p>内存分配的过程如下：</p>
<ol>
<li>在虚拟内存池中申请n个虚拟页</li>
<li>在物理内存池中分配物理页</li>
<li>在页表中添加虚拟地址与物理地址的映射关系</li>
</ol>
<p>接下来就是一步步完成这三步</p>
<h1 id="申请虚拟页"><a href="#申请虚拟页" class="headerlink" title="申请虚拟页"></a>申请虚拟页</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在虚拟内存池中申请pg_cnt个虚拟页</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">vaddr_get</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vaddr_start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pf == PF_KERNEL)</span><br><span class="line">    &#123;</span><br><span class="line">        bit_idx_start = bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap, pg_cnt);</span><br><span class="line">        <span class="keyword">if</span>(bit_idx_start == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cnt &lt; pg_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            bitmap_set(&amp;kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户内存池</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)vaddr_start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该步只需要在在需要在虚拟内存池的位图结构中找到连续n个空闲的空间即可</p>
<p>虚拟内存池的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">virtual_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> <span class="title">vaddr_bitmap</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr_start;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>kernel_vaddr是一个全局的虚拟内存池变量，它的初始化过程是在上一章完成的。</p>
<p>kernel_vaddr中的vaddr_start就是内核堆空间的起始地址，这个地址被设置为0xc0100000。因为在位图中，1bit实际代表1页大小的内存，所以这个地址的转换原理还是很简单的。<strong>申请到的空间的起始虚拟地址</strong> 就等于 <strong>堆空间的起始地址</strong> 加 <strong>虚拟页的偏移量</strong> * <strong>页大小</strong></p>
<h1 id="分配物理页"><a href="#分配物理页" class="headerlink" title="分配物理页"></a>分配物理页</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在m_pool指向的物理内存池中分配一个物理页</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">palloc</span><span class="params">(struct pool *m_pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bit_idx = bitmap_scan(&amp;m_pool-&gt;pool_bitmap, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(bit_idx == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bitmap_set(&amp;m_pool-&gt;pool_bitmap, bit_idx, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> page_phyaddr = bit_idx * PG_SIZE + m_pool-&gt;phy_addr_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)page_phyaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配物理页的过程同分配虚拟页的过程差不多，只是这里是在物理内存池中进行分配。而且在分配的过程中，并不需要物理页是连续的，所以在这里一次只分配一个物理页。这样就可以做到虚拟地址连续，而物理地址不需要连续。</p>
<h1 id="添加虚拟地址和物理地址的映射关系"><a href="#添加虚拟地址和物理地址的映射关系" class="headerlink" title="添加虚拟地址和物理地址的映射关系"></a>添加虚拟地址和物理地址的映射关系</h1><p>在添加虚拟地址到物理地址映射关系的过程中，肯定要对页表或者页目录进行修改。因为这个对应关系都是写在页表中的，既然此时他们之间没有映射关系，那么就需要在页表中进行添加或者修改，是该虚拟地址能对应到物理地址上。</p>
<p>为了能够在页表中添加或修改数据，就需要访问到该虚拟地址对应的 <strong>页目录项地址(PDE)</strong> 和 <strong>页表项地址(PTE)</strong> 通过PDE和PTE对页表进行修改</p>
<p>也就是说，找到该虚拟地址对应的PDE和PTE就成了这步的关键。</p>
<p>下面说一下处理器如何处理一个32位的虚拟地址，使其对应到物理地址上</p>
<ol>
<li>首先通过高10位的pde索引，找到页表的物理地址</li>
<li>其次通过中间10位的pte索引，得到物理页的物理地址</li>
<li>最后把低12位作为物理页的页内偏移，加上物理页的物理地址，即为最终的物理地址</li>
</ol>
<p>通过这幅图来说明一下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180425/2JFCg05BJ2.png?imageslim" alt="虚拟地址到物理地址的映射"></p>
<p>想要找到一个虚拟地址对应的PDE地址，那么首先要知道页目录表的地址，然后通过该虚拟地址的高10位，得到它相对于页目录表的偏移，便可以最终得到PDE的地址</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180425/99GEI7IGI3.png?imageslim" alt="mark"></p>
<p>通过上面的图来说明一下，想要知道0x00c03123的PDE地址，这里假设页目录表的首地址为0xfffff000，0x00c03123的高十位为0x3，而页目录表中，每一个小方框的大小都为4字节，所以最终 <strong>PDE=0xfffff000 + 0x3 * 4</strong></p>
<p>而当初在规划页表的时候，最后一个页目录项中存储的是页目录表的物理地址。当高20位全为1的时候访问到的就是最后一个页目录项，所以页目录表的物理地址也就为0xfffff000，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到虚拟地址对应的pde指针</span></span><br><span class="line"><span class="keyword">uint32_t</span> *pde_ptr(<span class="keyword">uint32_t</span> vaddr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *pde = (<span class="keyword">uint32_t</span>*)(<span class="number">0xfffff000</span> + PDE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pde;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到PTE的地址的过程就稍微复杂一点。</p>
<p>首先得知道页目录表中第0个页目录项所对应的页表的物理地址，这里假设是0xffc00000。</p>
<p>然后得知道它是哪张页表，也就是说是哪个页目录项所对应的页表，一个页目录项对应4KB大小的页表</p>
<p>最后根据该虚拟地址在页表中的偏移，也就是虚拟地址的中间10位，得到该PTE</p>
<p>同样通过0x00c03123来举例，它的高十位是0x3，中间十位是0x3</p>
<p><strong>PTE = 0xffc00000 + 高十位 * 0x1000 + 中间十位 * 4</strong></p>
<p>下面代码中的计算方式有点区别但是思路是一致的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到虚拟地址对应的pte指针</span></span><br><span class="line"><span class="keyword">uint32_t</span> *pte_ptr(<span class="keyword">uint32_t</span> vaddr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *pte = (<span class="keyword">uint32_t</span>*)(<span class="number">0xffc00000</span> + ((vaddr &amp; <span class="number">0xffc00000</span>) &gt;&gt; <span class="number">10</span>) + PTE_IDX(vaddr) * <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 0xffc00000 + 0x3 &gt;&gt; 10</span></span><br><span class="line">    <span class="keyword">return</span> pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里放一张地址的映射关系图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180425/6FECI7J8D4.png?imageslim" alt="mark"></p>
<p>解决了最复杂的PTE和PDE的地址获取问题，下面添加虚拟地址到物理地址的映射关系就简单了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在页表中添加虚拟地址到物理地址的映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_table_add</span><span class="params">(<span class="keyword">void</span> *_vaddr, <span class="keyword">void</span> *_page_phyaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>)_vaddr;</span><br><span class="line">    <span class="keyword">uint32_t</span> page_phyaddr = (<span class="keyword">uint32_t</span>)_page_phyaddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> *pde = pde_ptr((<span class="keyword">uint32_t</span>)vaddr);</span><br><span class="line">    <span class="keyword">uint32_t</span> *pte = pte_ptr((<span class="keyword">uint32_t</span>)vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在页目录内判断目录项的P位，若为1,表示该表已存在</span></span><br><span class="line">    <span class="keyword">if</span>(*pde &amp; <span class="number">0x01</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建页表的时候，pte不应该存在</span></span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x01</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!(*pte &amp; <span class="number">0x01</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            *pte = page_phyaddr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;<span class="comment">// 页目录项不存在，此时先创建页目录项</span></span><br><span class="line">        <span class="keyword">uint32_t</span> pde_phyaddr = (<span class="keyword">uint32_t</span>)palloc(&amp;kernel_pool);</span><br><span class="line"></span><br><span class="line">        *pde = pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)((<span class="keyword">int</span>)pte &amp; <span class="number">0xfffff000</span>), <span class="number">0</span>, PG_SIZE);</span><br><span class="line"></span><br><span class="line">        ASSERT(!(*pte &amp; <span class="number">0x01</span>));</span><br><span class="line">        *pte = page_phyaddr | PG_US_U | PG_RW_W | PG_P_1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里直接对pde或者pte内部的数据赋值就好了，赋值的数据需要根据pde和pte的结构来。直接上结构图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180417/Hd12DBhm9h.png?imageslim" alt="PDE与PTE的结构图"></p>
<p>前二十位是物理地址的高20位，后面的则是一些访问属性。这里不再过多解释</p>
<h1 id="内存分配接口函数"><a href="#内存分配接口函数" class="headerlink" title="内存分配接口函数"></a>内存分配接口函数</h1><p>函数已经全部封装好了，接下来是对外接口的提供了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> pool_flags</span><br><span class="line">&#123;</span><br><span class="line">    PF_KERNEL=<span class="number">1</span>,</span><br><span class="line">    PF_USER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配pg_cnt 个页空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc_page</span><span class="params">(<span class="keyword">enum</span> pool_flags pf, <span class="keyword">uint32_t</span> pg_cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(pg_cnt &gt; <span class="number">0</span> &amp;&amp; pg_cnt &lt; <span class="number">3840</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *vaddr_start = vaddr_get(pf, pg_cnt);</span><br><span class="line">    <span class="keyword">if</span>(vaddr_start == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr = (<span class="keyword">uint32_t</span>)vaddr_start;</span><br><span class="line">    <span class="keyword">uint32_t</span> cnt = pg_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool</span> *<span class="title">mem_pool</span> = <span class="title">pf</span> &amp; <span class="title">PF_KERNEL</span> ? &amp;<span class="title">kernel_pool</span> :</span> &amp;user_pool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> *page_phyaddr = palloc(mem_pool);</span><br><span class="line">        <span class="keyword">if</span>(page_phyaddr == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;<span class="comment">// 此处分配失败需要释放已申请的虚拟页和物理页</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        page_table_add((<span class="keyword">void</span>*)vaddr, page_phyaddr);</span><br><span class="line">        vaddr += PG_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内核物理内存池中申请pg_cnt页内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_kernel_pages</span><span class="params">(<span class="keyword">uint32_t</span> pg_cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *vaddr = malloc_page(PF_KERNEL, pg_cnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vaddr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vaddr,<span class="number">0</span>, pg_cnt * PG_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就在bochs中运行看看申请的空间有没有被写入页表中</p>
<p>这个是目前内核的内存布局信息，内核物理内存开始地址为0x200000。并且我们申请的内存开始地址是在0xc010000处，这也是内核堆空间的起始地址</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180425/3JE65Ig8Ih.png?imageslim" alt="内存布局信息"></p>
<p>在main函数中我申请了三页的内存，这里也确实做了三页的内存映射。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180425/DCggdBdg1g.png?imageslim" alt="页表信息"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/23/memory_pool/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/23/memory_pool/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">八. 内存池规划</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-23 16:22:08" itemprop="dateCreated datePublished" datetime="2018-04-23T16:22:08+08:00">2018-04-23</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="bitmap简介"><a href="#bitmap简介" class="headerlink" title="bitmap简介"></a>bitmap简介</h1><p>计算机中一些资源的数量非常庞大，比如内存容量和硬盘容量。为了使用这些资源，必须涉及到一套管理这些资源的方法，而方法中必须要构建数据结构来存储管理数据，这些数据本身也是需要占用内存的</p>
<p>计算机中最小的单位是位，那么用一组二进制位串来管理其他单位大小的资源是很自然的，这组二进制位中的每一位与其他资源的数据单位是一一对应的关系，这实际是一种映射关系，于是这组二进制位便有了一个名字—-位图</p>
<p>位图与内存的映射关系如下图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180423/71313j7e7h.png?imageslim" alt="位图与内存的映射关系"></p>
<p>图中的一个黑点代表计算机中的1bit，这1bit就会映射内存中4kb的空间，也就是1页的空间，这1bit有两个值，0或1。1代表这一页的内存已经被分配出去。</p>
<p>通过这种管理方式可以知道</p>
<p><strong>1byte</strong> 的位图空间可以映射 <strong>1 * 8 * 4KB = 32KB</strong> 的内存空间<br>那么 <strong>一页4096Bbyte</strong> 的位图空间就可以映射 <strong>32 * 4096 / 1024 = 128MB</strong>的内存空间</p>
<p>位图的结构还是比较简单的，下面来看看位图具体的实现</p>
<h1 id="bitmap实现"><a href="#bitmap实现" class="headerlink" title="bitmap实现"></a>bitmap实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> btmp_bytes_len;</span><br><span class="line">    <span class="keyword">uint8_t</span> *bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>位图的定义中，btmp_bytes_len用来记录位图所占字节的大小。bits用于保存位图的起始地址，bits的类型是 <strong>uint8_t*</strong> 此类型强调的是字节型指针，主要是让其以 1字节的单位进行偏移，这样可以简化对 <strong>字节</strong> 中 <strong>位</strong> 的操作 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITMAP_MASK 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化位图，将位图中的数据清0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_init</span><span class="params">(struct bitmap *btmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(btmp-&gt;bits, <span class="number">0</span>, btmp-&gt;btmp_bytes_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断位图中的第bit_idx位是否为1, 如果是，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bitmap_scan_test</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>; <span class="comment">// 位图中bit_idx所在的byte索引</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bit_odd = bit_idx % <span class="number">8</span>; <span class="comment">// 该bit在 1byte中的偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bitmap_scan_test函数用来对判断bit_idx位是否为1， bit_idx是相对于位图起始地址的 <strong>bit偏移量</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在位图中申请连续的cnt位个空间，成功返回在位图中的bit偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitmap_scan</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> idx_byte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((<span class="number">0xff</span> == btmp-&gt;bits[idx_byte]) &amp;&amp; (idx_byte &lt; btmp-&gt;btmp_bytes_len))</span><br><span class="line">    &#123;<span class="comment">// 判断该字节是否全部为1, 且位图大小必须 小于 要申请的空间</span></span><br><span class="line">        <span class="comment">// 代表该字节已全部占用，继续向下字节查找</span></span><br><span class="line">        ++idx_byte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(idx_byte &lt; btmp-&gt;btmp_bytes_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存池中找不到可用空间</span></span><br><span class="line">    <span class="keyword">if</span> (idx_byte == btmp-&gt;btmp_bytes_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在idx_byte中有空闲位后，对该byte进行逐bit比对，直到有连续的bits=cnt</span></span><br><span class="line">    <span class="keyword">int</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">uint8_t</span>)(BITMAP_MASK &lt;&lt; idx_bit) &amp; btmp-&gt;bits[idx_byte])</span><br><span class="line">    &#123;<span class="comment">// 找到idx_byte中为0的bit所在的位置</span></span><br><span class="line">        ++idx_bit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bit_idx_start = idx_byte * <span class="number">8</span> + idx_bit; <span class="comment">// 空闲位在位图中的bit偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位图中还剩余的bits数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bit_left = (btmp-&gt;btmp_bytes_len * <span class="number">8</span> - bit_idx_start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> next_bit = bit_idx_start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> count = <span class="number">1</span>;  <span class="comment">// 记录找到的空闲位数量</span></span><br><span class="line"></span><br><span class="line">    bit_idx_start = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 在剩余的空间中继续查找，直到有连续的bits=cnt</span></span><br><span class="line">    <span class="keyword">while</span> (bit_left-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!bitmap_scan_test(btmp, next_bit))</span><br><span class="line">        &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            bit_idx_start = next_bit - cnt + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++next_bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bit_idx_start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将位图中的bit_idx位 设置为value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitmap_set</span><span class="params">(struct bitmap *btmp, <span class="keyword">uint32_t</span> bit_idx, <span class="keyword">int8_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(value == <span class="number">0</span> || value == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> byte_idx = bit_idx / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> bit_odd = bit_idx % <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        btmp-&gt;bits[byte_idx] |= (BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        btmp-&gt;bits[byte_idx] &amp;= ~(BITMAP_MASK &lt;&lt; bit_odd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bitmap_scan 会在位图中找连续cnt位个空间，该空间必须是连续的，如果成功找到，会返回该空间起始位置相对于位图起始地址的 <strong>bit偏移量</strong></p>
<p>位图的结构有了之后，就要通过它对内存进行管理，在这里，先对物理内存进行划分。</p>
<h1 id="内存池规划"><a href="#内存池规划" class="headerlink" title="内存池规划"></a>内存池规划</h1><p>内核和用户进程都是要运行在物理内存之上的，操作系统为了正常运行，不能用户进程申请多少内存，就分配多少内存，否则可能导致物理内存不足，导致内核自己都无法正常运行。</p>
<p>基于这个原因，将物理内存划分成两部分，一为用户物理内存池，此部分的物理内存专门用于分配给用户进程。二为内核物理内存池，此内存池只供给操作系统使用</p>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>在分页机制下，程序中的地址都是虚拟地址，在32位环境下，虚拟地址空间为4GB。且每个任务都有自己独立的4GB虚拟地址空间，各个程序之间的虚拟地址可以相同，不仅用户进程是这样，内核同样如此。</p>
<p>程序在动态申请内存的过程中，操作系统会为进程或者内核自己在堆中选择一空闲的虚拟地址，并且找个空闲的物理地址作为此虚拟地址的映射。之后将该虚拟地址返回给用户进程。</p>
<p>为了找出空闲的虚拟地址，就必须对虚拟地址也进行管理，需要为所有任务都维护一个虚拟内存地址池。</p>
<p>对内核来说也不例外，虽然内核在需要空间时可以即拿即用，但是通过这些统一的管理方式使得内核不显得如此混乱，结构性好。</p>
<p>内核在申请空间的时候，先从内核自己的虚拟地址池中分配好虚拟地址再从内核物理地址池中分配物理内存，最后在内核自己的页表中将这两种地址建立好映射关系，内存就分配完成</p>
<p>对用户进程来说，它向操作系统申请内存时，操作系统先从用户进程自己的虚拟地址分配虚拟地址，在从用户物理内存池中分配空闲的物理内存，用户物理内存池是被所有用户进程所共享的。最后在用户进程自己的页表中将这两种地址建立好映射关系</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180423/h4jbK1Lh6C.png?imageslim" alt="虚拟内存池与物理内存池"></p>
<h2 id="内存池的初始化"><a href="#内存池的初始化" class="headerlink" title="内存池的初始化"></a>内存池的初始化</h2><p>虚拟内存池和物理内存池的结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct virtual_addr</span><br><span class="line">&#123;</span><br><span class="line">    struct bitmap vaddr_bitmap;</span><br><span class="line">    uint32_t vaddr_start;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pool</span><br><span class="line">&#123;</span><br><span class="line">    struct bitmap pool_bitmap;  // 内存池的位图结构</span><br><span class="line">    uint32_t phy_addr_start; </span><br><span class="line">    uint32_t pool_size;         </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pool kernel_pool, user_pool; // 生成内核内存池和用户内存池</span><br><span class="line">struct virtual_addr kernel_vaddr;   // 此结构用来给内核分配虚拟地址</span><br></pre></td></tr></table></figure></p>
<p>在前面创建页目录和页表的时候，我们将虚拟地址0xc0000000~0xc00fffff映射到了物理地址0x0~0xfffff，0xc0000000是内核空间的起始虚拟地址，这1MB空间做的对等映射。所以内核堆空间的开始地址从0xc0100000开始</p>
<p>在之前的设计中，0xc009f000为内核主线程的栈顶，0xc009e000将作为主线程的pcb使用，那么在低端1MB的空间中，就只剩下0xc009a000~0xc009dfff这4 * 4KB的空间未使用，所以位图的地址就安排在0xc009a000处，这里还剩下四个页框的大小，所能表示的内存大小为512MB</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_BITMAP_BASE 0xc009a000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K_HEAP_START 0xc0100000</span></span><br></pre></td></tr></table></figure>
<p>在内存池的初始化中，只需要根据物理内存的总大小，内核物理内存池和用户物理内存池平均分割物理内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化内存池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mem_pool_init</span><span class="params">(<span class="keyword">uint32_t</span> all_mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    put_str(<span class="string">"   mem_pool_init start\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前只初始化了低端1MB的内存页表，也就是256个页表</span></span><br><span class="line">    <span class="keyword">uint32_t</span> page_table_size = PG_SIZE * <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> used_mem = page_table_size + <span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> free_mem = all_mem - used_mem;</span><br><span class="line">    <span class="keyword">uint16_t</span> all_free_pages = free_mem / PG_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> kernel_free_pages = all_free_pages / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> user_free_pages = all_free_pages - kernel_free_pages;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核的位图大小，在位图中，1bit表示1页</span></span><br><span class="line">    <span class="keyword">uint32_t</span> kbm_length = kernel_free_pages / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ubm_length = user_free_pages / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核内存池的起始地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> kp_start = used_mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户内存池的起始地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> up_start = kp_start + kernel_free_pages * PG_SIZE;</span><br><span class="line"></span><br><span class="line">    kernel_pool.phy_addr_start = kp_start;</span><br><span class="line">    user_pool.phy_addr_start = up_start;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_size = kernel_free_pages * PG_SIZE;</span><br><span class="line">    user_pool.pool_size = user_free_pages * PG_SIZE;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">    user_pool.pool_bitmap.btmp_bytes_len = ubm_length;</span><br><span class="line"></span><br><span class="line">    kernel_pool.pool_bitmap.bits = (<span class="keyword">void</span>*)MEM_BITMAP_BASE;</span><br><span class="line">    user_pool.pool_bitmap.bits = (<span class="keyword">void</span>*)(MEM_BITMAP_BASE + kbm_length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出内存信息</span></span><br><span class="line">    put_str(<span class="string">"      kernel_pool_bitmap_start:"</span>);</span><br><span class="line">    put_int((<span class="keyword">int</span>)kernel_pool.pool_bitmap.bits);</span><br><span class="line">    put_str(<span class="string">" kernel_pool_phy_addr_start:"</span>);</span><br><span class="line">    put_int(kernel_pool.phy_addr_start);</span><br><span class="line">    put_str(<span class="string">"\n"</span>);</span><br><span class="line">    put_str(<span class="string">"      user_pool_bitmap_start:"</span>);</span><br><span class="line">    put_int((<span class="keyword">int</span>)user_pool.pool_bitmap.bits);</span><br><span class="line">    put_str(<span class="string">" user_pool_phy_addr_start:"</span>);</span><br><span class="line">    put_int(user_pool.phy_addr_start);</span><br><span class="line">    put_str(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将位图置0</span></span><br><span class="line">    bitmap_init(&amp;kernel_pool.pool_bitmap);</span><br><span class="line">    bitmap_init(&amp;user_pool.pool_bitmap);</span><br><span class="line"></span><br><span class="line">    kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;</span><br><span class="line">    kernel_vaddr.vaddr_bitmap.bits = (<span class="keyword">void</span>*)(MEM_BITMAP_BASE + kbm_length + ubm_length);</span><br><span class="line"></span><br><span class="line">    kernel_vaddr.vaddr_start = K_HEAP_START;</span><br><span class="line">    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);</span><br><span class="line">    put_str(<span class="string">"   mem_pool_init done\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    put_str(<span class="string">"mem_init start\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物理内存的大小放在地址0xb00处</span></span><br><span class="line">    <span class="keyword">uint32_t</span> mem_bytes_total = *((<span class="keyword">uint32_t</span>*)<span class="number">0xb00</span>);</span><br><span class="line"></span><br><span class="line">    mem_pool_init(mem_bytes_total);</span><br><span class="line"></span><br><span class="line">    put_str(<span class="string">"mem_init done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/queue/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/queue/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">从零开始，打造自己的STL(七、queue)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 20:05:38" itemprop="dateCreated datePublished" datetime="2018-04-22T20:05:38+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一部分内容是关于队列的内容，它也是一个容器适配器，只是对deque接口的简单调用，deque在前面已将有了详细的介绍，这里就不过多说明。</p>
<p>在队列之后还有一个容器适配器，优先队列，因为优先队列涉及到堆排序，准备放到后面讲所有容器介绍完了之后再来介绍</p>
<p>下面直接上queue的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = <span class="built_in">deque</span>&lt;_Tp&gt; &gt;</span><br><span class="line">class <span class="built_in">queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::value_type      value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::size_type       size_type;</span><br><span class="line">	<span class="keyword">typedef</span>          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::reference       reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	_Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">queue</span>() :c() &#123;&#125;</span><br><span class="line">	<span class="built_in">queue</span>(<span class="keyword">const</span> _Sequence &amp;_c) :c(_c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.empty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.front();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.front();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.back();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.back();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; _val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		c.push_back(_val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.pop_front();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/stack/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/stack/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">从零开始，打造自己的STL(六、stack)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 20:00:00" itemprop="dateCreated datePublished" datetime="2018-04-22T20:00:00+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/STL/" itemprop="url" rel="index"><span itemprop="name">STL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面一章中介绍了deque，除了 C++11 标准中的 array 和 forward_list 之外，序列式容器就已经全部介绍完了，这一部分开始就准备介绍容器适配器。容器适配器相较于容器来说，更加的简单。因为容器适配器里面所有的接口都是对容器内部方法的调用。可以把他们之间的关系当成组合关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence=<span class="built_in">deque</span>&lt;_Tp&gt; &gt;</span><br><span class="line">class <span class="built_in">stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::size_type size_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span>          _Sequence                  container_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::reference       reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	_Sequence c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">stack</span>() :c() &#123;&#125;</span><br><span class="line">	<span class="built_in">stack</span>(<span class="keyword">const</span> _Sequence &amp;_s) :c(_s) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.empty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> c.back();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; _val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		c.push_back(_val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		c.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码可以说再简单不过了，通过模板参数 <strong>_Sequence</strong> 可以决定使用哪个容器来作为栈的接口，在这里，默认使用的是deque，其实，只要是实现了empty, size, back, push_back, pop_back的容器，在这里都可以使用。只是使用不同的容器所带来的性能会有所不同。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/interrupt/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/04/22/interrupt/" class="post-title-link" itemprop="http://yoursite.com/page/2/index.html">七. 中断</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 18:29:48" itemprop="dateCreated datePublished" datetime="2018-04-22T18:29:48+08:00">2018-04-22</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>中断是指CPU获知了计算机中发生的某些事，CPU暂停正在执行的程序，转而去执行处理该事件的程序，当这段程序执行完了之后，CPU继续执行刚才的程序。</p>
<p>通过中断可以极大的提高CPU的执行效率，如果没有中断，在处理器与外部设备通信时，他必须在向该设备发送指令后进入忙等待，反复轮询该设备是否就绪，这样就浪费了大量处理器的执行周期。引入中断之后，当处理器发出设备请求后就可以立即返回处理其他任务，而当设备动作完成之后，发送中断信号给处理器，后者就可以在完成动作之后回来获取处理结果</p>
<h1 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h1><p>按照中断事件来源分类，可以把中断分为外部中断和内部中断</p>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p>外部中断是指来自CPU外部的中断，而外部的中断源通常时某个硬件，所以外部的中断也叫硬件中断</p>
<p>由于外部设备在种类和数量上都非常多，CPU不可能为每个外部设备专门设计一个接口去处理他的中断信号。所以只能提供统一的接口作为中断信号的公共线路，所有来自外设的中断信号都共享公共线路连接都CPU。</p>
<p>其接口示意图如下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180419/AIikb6ajl0.png?imageslim" alt="mark"></p>
<p>从INTR引脚收到的中断都是不影响系统运行的，可以随时处理，他不会影响到CPU的执行。也称为可屏蔽中断。可以通过eflag中的if位将所有这些外部中断屏蔽</p>
<p>从NMI引脚收到的中断，通常是由于系统发生致命错误所导致的，比如电源掉电，内存读写错误等等。</p>
<h2 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h2><p>内部中断可分为软中断和异常</p>
<p>软中断是由软件主动发起的中断，他是软件主动发起的。</p>
<p>发起软中断有以下几种方式</p>
<ol>
<li><p><strong>int 8位的立即数</strong> 通过它，我们可以发起系统调用，8位的立即数可以表示256种中断。处理器支持的中断也是256种</p>
</li>
<li><p><strong>int3</strong> 调试断点指令，在调式程序的时候，我们所下的断点就是通过他来实现的。通过调试器fork子进程，在断点处用int3替换原指令，从而使子进程调用int3触发中断</p>
</li>
<li><p><strong>into</strong> 中断溢出指令，只有在eflags中的OF位为1的情况下才会被触发</p>
</li>
<li><p><strong>bound</strong> 检查数组索引越界指令</p>
</li>
<li><p><strong>ud2</strong> 未定义指令，CPU遇到无效指令时触发该中断</p>
</li>
</ol>
<p>异常是在指令执行期间CPU内部产生的错误引起的，由于是运行时错误，他不受eflags中的IF位的影响</p>
<p>异常按照轻重的等级，可分为以下三种</p>
<ol>
<li><p>Fault，也称故障。属于可被修复的一种类型，当发生此类异常时，CPU将机器状态恢复到异常之前的状态，之后调用中断处理程序，通常都能够被解决。缺页异常就属于此种异常</p>
</li>
<li><p>Trap，也称陷阱。此异常通常在调试中。</p>
</li>
<li><p>Abort，也称终止。程序发生了此类异常通常就无法继续执行下去，操作系统会将此程序从进程表中去除。</p>
</li>
</ol>
<h1 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h1><p>中断描述符表是保护模式下用于存储中断处理程序入口的表，当CPU接受到一个中断时，需要根据该中断的中断向量号在此表中检索对应的描述符，在该描述符中找到中断处理程序的起始地址，然后执行中断处理程序</p>
<h2 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h2><p>在中断描述符表中存储的不只是中断描述符，还包括任务门描述符和陷阱门描述符。IDT中只有这种称为门的描述符，那么就要了解一下这些门的具体结构</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180419/5fbdHfAag5.png?imageslim" alt="任务门描述符"></p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180419/AeE7bAB3jI.png?imageslim" alt="中断门描述符"></p>
<p>中断门包含了中断处理程序所在的段选择子和段内偏移地址，当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，避免中断嵌套。linux就是利用的中断门实现的系统调用，也就是int 0x80。</p>
<p>中断门只允许存放在IDT中，而其他的门描述符则不然。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180419/9773glc7f0.png?imageslim" alt="陷阱门描述符"></p>
<p>在描述符中，通过S字段+type字段来确定描述符的具体类型</p>
<p>S字段为1时代表系统段，为0时代表数据段。此处的门描述符全部处于系统段下。</p>
<p>DPL表示描述符特权级</p>
<hr>
<h2 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h2><ol>
<li>处理器根据中断向量号定位中断门描述符</li>
<li>处理器进行特权级检查</li>
<li>执行中断处理程序</li>
</ol>
<p>这里重点要说一下特权级检查的过程。</p>
<p>为了防止3特权级下的用户主动调用只为内核服务的程序，当前的特权级必须经受的住中断门的考验，得“进入门内”。进门一般分为两步，“跨过门槛”，“进入门框”</p>
<p>“跨过门槛”的过程其实是检查 <strong>当前特权级(CPL)</strong> 和 <strong>门描述符特权级(DPL)</strong> 的大小。要求 <strong>CPL权限大于等于DPL</strong>，在数值上 <strong>CPL&lt;=DPL</strong>，“门槛”检查才通过，特权级的数值越小代表特权级越高。否则抛出异常</p>
<p>“进入门框”的过程实质是检查 <strong>CPL</strong> 和 <strong>门描述符中选择子对应的目标代码段的DPL</strong>，要求 <strong>CPL权限小于目标代码段的DPL</strong>，在数值上 <strong>CPL&gt;目标代码段DPL</strong>，此处不能相等。</p>
<p>如果该中断是一个软中断，也就是通过 int n, int3, into等引发的中断，执行上述两步的特权级检查</p>
<p>如果该中断是外部设备中断或者异常，只需要执行第二步的特权级检查</p>
<p>中断处理过程的示意图：</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180419/el0FIba2hH.png?imageslim" alt="中断处理过程"></p>
<h1 id="中断发生时的压栈"><a href="#中断发生时的压栈" class="headerlink" title="中断发生时的压栈"></a>中断发生时的压栈</h1><p>在中断发生之后，处理器要去执行中断处理程序，该中断处理程序是通过中断门描述符中保存的代码段选择子和段内偏移找到的，也就是说需要重新加载段寄存器，那么为了能在中断处理完了之后还能返回当前进程，就必须保存当前进程的 <strong>CS:EIP</strong>，保存的地方当然就是中断处理程序的栈中了。因为中断可以在任意特权级下发生，所以当前进程的EFLAGS寄存器同样需要保存，如果涉及到特权级的变化，还需要压如SS和ESP寄存器</p>
<p>通过一副图来详细解释压栈的情况与顺序</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180419/Dmmcgegmkh.png?imageslim" alt="中断压栈"></p>
<p>图A、B：在发生中断是通过特权级的检测，发现需要向高特权级转移，所以要保存当前程序栈的SS和ESP的值，在这里记为ss_old, esp_old，然后在新栈中压入当前程序的eflags寄存器</p>
<p>图C、D：由于要切换目标代码段，这种段间转移，要对CS和EIP进行备份，同样将其存入新栈中。某些异常会有错误码，用来标识异常发生在哪个段上，对于有错误码的情况，要将错误码也压入栈中。</p>
<p>入栈说完了，在中断执行完了返回的时候通过指令 <strong>iret</strong> 完成，这个指令专门用于从中断返回</p>
<p><strong>iret</strong> 指令会从栈顶依次弹出EIP、CS、EFLAGS，根据特权级的变化还有ESP、SS。但是该指令并不验证数据的正确性，而且他从栈中弹出数据的顺序是不变的，也就是说，在有error_code的情况下，iret返回时并不会主动跳过这个数据，需要我们手动进行处理</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="melody">
            
              <p class="site-author-name" itemprop="name">melody</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">melody</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
