<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="melodyのblog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="melodyのblog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="melodyのblog">






  <link rel="canonical" href="http://yoursite.com/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>melodyのblog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">melodyのblog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/pipe/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/18/pipe/" class="post-title-link" itemprop="http://yoursite.com/index.html">二十三. 进程同步与进程间通信</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-18 17:07:18" itemprop="dateCreated datePublished" datetime="2018-05-18T17:07:18+08:00">2018-05-18</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p>看一下上一节写的调用外部shell的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(final_path, <span class="number">0</span>, <span class="keyword">sizeof</span>(final_path));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    make_clear_abs_path(argv[<span class="number">0</span>], final_path);</span><br><span class="line">    argv[<span class="number">0</span>] = final_path;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">0</span>], &amp;file_stat) ！= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execv(argv[<span class="number">0</span>], argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是shell fork出一个子进程，通过该子进程调用exec将当前进程替换为要执行的外部命令。此时在父进程的执行代码处，我们用了一个死循环将其简单的阻塞在此，那么为什么这里父进程要阻塞自己。</p>
<p>在fork的原理说过，fork出来的子进程会完全复制父进程的所有资源，包括父进程的堆栈环境等等。在这一段代码中，fork出的子进程会使用到复制过来的栈中的数据，如final_path。如果fork还没有执行完，也就是说子进程还没有完全复制父进程的堆栈环境，而父进程在此时改变了它栈中的数据，那么此时子进程复制的数据可能就不是它想要的数据。此时便需要父进程阻塞起来，让子进程先执行，这就是需要进行进程同步的地方。</p>
<h2 id="wait和exit"><a href="#wait和exit" class="headerlink" title="wait和exit"></a>wait和exit</h2><p>这一节将会通过wait和exit来实现进程的同步，首先来理解一下wait和exit是来干什么的。</p>
<p>wait的作用是让一个进程阻塞自己，直到他的某一个子进程退出。所以说，wait通常由父进程来调用。当一个进程调用wait的时候，内核便会去查找该进程的子进程，如果没有子进程，此时wait会返回-1，否则，该进程便会被阻塞，此时内核就会去遍历它的所有子进程，查找是否有子进程退出，如果有子进程退出便将该子进程的返回值传递给父进程，随后将父进程唤醒。</p>
<p>exit的作用就如其名字一样，让进程退出，结束执行。</p>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>在wait和exit的调用中会产生两个非常有意思的概念，孤儿进程和僵尸进程。</p>
<p>前面介绍wait的时候也说了，wait的一个作用是阻塞父进程自己，使父子进程同步，它的另一个作用是获取子进程的退出状态，也就是取得子进程的退出时的返回值。这个返回值就是平常在main函数中写的return 0，这个0就代表这个进程的退出状态。</p>
<p>当子进程执行完main函数之后，程序的执行流程会返回到c运行库之中(这个是之前所介绍的，main函数只是程序执行流程中的中间部分，它是由c运行库调用通过call指令调用的，执行完了之后会返回)。c运行库会把进程return的返回值通过系统调用exit提交给内核。</p>
<p>下面来解释一下什么是孤儿进程和僵尸进程</p>
<p>如果一个子进程运行结束了，它的父进程没有调用wait，这个子进程就变成了僵尸进程。</p>
<p>如果子进程还在运行，而他的父进程已经退出了，这个子进程就变了孤儿进程。</p>
<p>上面是僵尸进程和孤儿进程的基本概念，接下来从内核层理解一下为什么会出现僵尸进程和孤儿进程。</p>
<p>在进程退出的时候，无论如果他都会调用exit，不管是这个进程主动调用exit退出，还是执行完了之后进入c运行库调用exit。exit会得到一个退出状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是exit的函数原型，status就是传递进去的退出状态，那么这个退出状态要存储在什么地方呢。又如何将这个退出状态传给父进程呢。</p>
<p>由于进程都是自己独立的地址空间，即使是父子之前，他们也是相互独立不可互相访问的，进程间想要通信必须要借助内核，子进程的返回值肯定要先提交给内核，然后父进程向内核要子进程的返回值，父进程如何向内核要子进程的返回值呢，看一下wait函数的原型就知道了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br></pre></td></tr></table></figure></p>
<p>status是父进程用来存储子进程返回值的地址，父进程调用它后，内核就会它子进程的返回值存储到status指向的内存空间中。</p>
<p>接下来说一下子进程的返回值到底存储在什么地方。在操作系统中，为了方便管理，进程相关的数据都统一放在pcb中，当进程结束时，它的返回值会被内核放到进程的pcb中。由于此时进程已经执行完了，内核会把进程占用的大部分资源回收，比如内存，页表等，但是进程的pcb所占的内存还不能回收，因为里面存储着进程的返回值，就像是临终遗言一样，还没有交出去，需要交付给父进程之后才能被回收。它应该在父进程调用wait获取子进程的返回值后，再由内核回收子进程pcb所占用的页框。</p>
<p>说到这里，相信僵尸进程就很好理解了，因为子进程结束了，父进程没有调用wait，导致子进程的pcb无法被内核回收，而导致内核空间被浪费。如果系统中存在大量的僵尸进程，还可能导致无法启动新的进程，毕竟内核的空间总是有限的。</p>
<p>孤儿进程相对来说好理解一点，父进程退出了，子进程还没有调用exit，此时子进程便成了孤儿进程。因为没有父进程再来获取该子进程的退出状态了嘛。但是在linux的处理策略中，孤儿进程会被init进程收养，也就是说，init进程会成为这些进程的父进程，子进程退出的时候就有init进程来为其”收尸”罗。这其实是一种顺理成章的处理策略，因为init进程本身就是所有进程的父进程。</p>
<p>概念上差不多就这些，接下来看一下实现</p>
<p>wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等待子进程调用exit,将子进程的退出状态保存到status指向的变量.</span></span><br><span class="line"><span class="comment"> * 成功则返回子进程的pid,失败则返回-1 */</span></span><br><span class="line"><span class="keyword">pid_t</span> sys_wait(<span class="keyword">int32_t</span> *status)</span><br><span class="line">&#123;</span><br><span class="line">    task_struct *parent_thread = running_thread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 优先处理已经是挂起状态的任务 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> *<span class="title">child_elem</span> = <span class="title">list_traversal</span>(&amp;<span class="title">thread_all_list</span>, <span class="title">find_hanging_child</span>, <span class="title">parent_thread</span>-&gt;<span class="title">pid</span>);</span></span><br><span class="line">        <span class="comment">/* 若有挂起的子进程 */</span></span><br><span class="line">        <span class="keyword">if</span> (child_elem != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            task_struct *child_thread = elem2entry(task_struct, all_list_tag, child_elem);</span><br><span class="line">            *status = child_thread-&gt;exit_status;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* thread_exit之后,pcb会被回收,因此提前获取pid */</span></span><br><span class="line">            <span class="keyword">uint16_t</span> child_pid = child_thread-&gt;pid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 2 从就绪队列和全部队列中删除进程表项*/</span></span><br><span class="line">            thread_exit(child_thread, <span class="literal">false</span>); <span class="comment">// 传入false,使thread_exit调用后回到此处</span></span><br><span class="line">            <span class="comment">/* 进程表项是进程或线程的最后保留的资源, 至此该进程彻底消失了 */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> child_pid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断是否有子进程 */</span></span><br><span class="line">        child_elem = list_traversal(&amp;thread_all_list, find_child, parent_thread-&gt;pid);</span><br><span class="line">        <span class="keyword">if</span> (child_elem == <span class="literal">NULL</span>)</span><br><span class="line">        &#123; <span class="comment">// 若没有子进程则出错返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 若子进程还未运行完,即还未调用exit,则将自己挂起,直到子进程在执行exit时将自己唤醒 */</span></span><br><span class="line">            thread_block(TASK_WAITING);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>exit<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 子进程用来结束自己时调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">int32_t</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_struct *child_thread = running_thread();</span><br><span class="line">    child_thread-&gt;exit_status = status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将进程child_thread的所有子进程都过继给init */</span></span><br><span class="line">    list_traversal(&amp;thread_all_list, init_adopt_a_child, child_thread-&gt;pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 回收进程child_thread的资源 */</span></span><br><span class="line">    release_prog_resource(child_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果父进程正在等待子进程退出,将父进程唤醒 */</span></span><br><span class="line">    task_struct *parent_thread = pid2thread(child_thread-&gt;parent_pid);</span><br><span class="line">    <span class="keyword">if</span> (parent_thread-&gt;status == TASK_WAITING)</span><br><span class="line">    &#123;</span><br><span class="line">        thread_unblock(parent_thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将自己挂起,等待父进程获取其status,并回收其pcb */</span></span><br><span class="line">    thread_block(TASK_HANGING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h1><h2 id="管道的原理"><a href="#管道的原理" class="headerlink" title="管道的原理"></a>管道的原理</h2><p>进程虽然是独立运行的个体，但他们之间有时候也需要协作才能完成一些工作，比如有两个进程需要同步数据，进程A把数据准备好后，想把数据发往进程B，进程B必须被提前通知有数据到来。这些需求很多，所以操作系统必须要实现进程间的相互通信。</p>
<p>进程间通信的方式有很多种，有消息队列，共享内存，socket通信，管道等。在这里kernel中就打算实现管道。而且管道命令在linux的shell中使用可以说是非常频繁的。</p>
<p>管道是文件的一种，(操作系统上文件是一个非常大的概念，像管道，socket，设备等都归属于文件的概念中)只是该文件并不存在与文件系统上，它只存在于内存中。既然管道是属于文件的一种，就要按照文件操作的方式来使用，通过open，close，read，write来使用管道，这应该是约定的一种规范吧。</p>
<p>管道是数据的一个中转站，当某个进程往管道中写入数据后，该数据就会被另一个进程读取，之后用新的数据覆盖旧数据，既然是一块数据缓存区，就应该有一个大小。但是由于写入的数据大小是不确定的，这块缓存区的大小很难确定下来，一般来说会使用环形缓存区来存储数据，通过生产者消费者模型对这块环形缓冲区的数据进行读写。这个环形缓冲区用两个指针来维护，一个专门负责读，一个专门负责写，当缓冲区数据满时，生产者睡眠并唤醒消费者。缓冲区空时，消费者睡眠，唤醒生产者。</p>
<p>管道有两端，一端用来读，一端用来写。这个两端的概念实质上是内核为一个管道分配了两个文件描述符，一个负责写，一个负责读。它的模型如下图<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180518/9FC1HDLEHL.png?imageslim" alt=""><br>当然，管道创建出来后，自己写自己读是没有意义的。所以通常的走法是创建一个管道后，fork一个子进程，这个子进程会继承当前进程的所有资源，当然也就包括他打开的管道啦。所以父子进程都能通过管道描述符向管道中读写数据。</p>
<p>管道分为两种，匿名管道和命名管道。匿名管道是创建之后只能通过文件描述符来访问的，此管道只对创建它的进程和其子进程可见，其他进程是访问不到的。命名管道就是可以通过其名称，找到该管道的文件描述符，对所有进程都可见。</p>
<h2 id="linux中管道的设计"><a href="#linux中管道的设计" class="headerlink" title="linux中管道的设计"></a>linux中管道的设计</h2><p>linux支持的文件系统比较多，包括ext2，ext3，ext4，ntfs等。为了提供统一的接口，linux加了一层中间层VFS(虚拟文件系统)。Linux处理管道时是利用现有的文件结构和VFS中inode共同完成的，并没有为管道提供另外的数据结构。如下图所示<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180518/FK0E7lbl8F.png?imageslim" alt=""><br>在图中的文件结构中，f_inode执行VFS中的inode，该inode指向1一个页框大小的内存区域，也就是说linux中管道的缓冲区大小为4096byte，f_op指向操作方法，对于不同的操作对象提供不同的操作方法，对于管道来说，f_op会指向pipe_read或pipe_write方法。</p>
<h2 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断文件描述符local_fd是否是管道 */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pipe</span><span class="params">(<span class="keyword">uint32_t</span> local_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> global_fd = fd_local2global(local_fd);</span><br><span class="line">    <span class="keyword">return</span> file_table[global_fd].fd_flag == PIPE_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建管道,成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_pipe(<span class="keyword">int32_t</span> pipefd[<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> global_fd = get_free_slot_in_global();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 申请一页内核内存做环形缓冲区 */</span></span><br><span class="line">    file_table[global_fd].fd_inode = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化环形缓冲区 */</span></span><br><span class="line">    ioqueue_init((struct ioqueue *)file_table[global_fd].fd_inode);</span><br><span class="line">    <span class="keyword">if</span> (file_table[global_fd].fd_inode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将fd_flag复用为管道标志 */</span></span><br><span class="line">    file_table[global_fd].fd_flag = PIPE_FLAG;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将fd_pos复用为管道打开数 */</span></span><br><span class="line">    file_table[global_fd].fd_pos = <span class="number">2</span>;</span><br><span class="line">    pipefd[<span class="number">0</span>] = pcb_fd_install(global_fd);</span><br><span class="line">    pipefd[<span class="number">1</span>] = pcb_fd_install(global_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从管道中读数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从管道中读数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_read(<span class="keyword">int32_t</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *buffer = buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取管道的环形缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span> *<span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span> *)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选择较小的数据读取量,避免阻塞 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ioq_len = ioq_length(ioq);</span><br><span class="line">    <span class="keyword">uint32_t</span> size = ioq_len &gt; count ? count : ioq_len;</span><br><span class="line">    <span class="keyword">while</span> (bytes_read &lt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        *buffer = ioq_getchar(ioq);</span><br><span class="line">        ++bytes_read;</span><br><span class="line">        ++buffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>往管道写数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 往管道中写数据 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> pipe_write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> global_fd = fd_local2global(fd);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioqueue</span> *<span class="title">ioq</span> = (<span class="title">struct</span> <span class="title">ioqueue</span> *)<span class="title">file_table</span>[<span class="title">global_fd</span>].<span class="title">fd_inode</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选择较小的数据写入量,避免阻塞 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ioq_left = bufsize - ioq_length(ioq);</span><br><span class="line">    <span class="keyword">uint32_t</span> size = ioq_left &gt; count ? count : ioq_left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *buffer = buf;</span><br><span class="line">    <span class="keyword">while</span> (bytes_write &lt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        ioq_putchar(ioq, *buffer);</span><br><span class="line">        bytes_write++;</span><br><span class="line">        buffer++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在shell中支持管道"><a href="#在shell中支持管道" class="headerlink" title="在shell中支持管道"></a>在shell中支持管道</h2><p>在平常使用shell的使用，经常会使用到管道命令，类似这种。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep xxx | grep -v grep</span><br></pre></td></tr></table></figure></p>
<p>管道之所以可以这样使用，是进行了输入输出重定向。通常情况下键盘是输入，屏幕是输入。这就是标准输入与标准输出。而输入输出重定向就是改变输入输出的位置，比如从文件中读取输入称为输入重定向，将结果输出到文件中称为输出重定向。</p>
<p>而管道的作用就是利用了输入输出重定向的与原理，将一个命令的输出作为另一个命令的输入来使用。管道符左边命令的输出数据会作为右边命令的输入数据使用。</p>
<p>核心原理就是这样，实现的时候就需要把旧的文件描述符替换为新的文件描述符，文件描述符是我们获取数据和写入数据的根本，改变了文件描述符中的数据，输入输出的位置自然也就变了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符old_local_fd重定向为new_local_fd */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_fd_redirect</span><span class="params">(<span class="keyword">uint32_t</span> old_local_fd, <span class="keyword">uint32_t</span> new_local_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    task_struct *cur = running_thread();</span><br><span class="line">    <span class="comment">/* 恢复标准描述符 */</span></span><br><span class="line">    <span class="keyword">if</span> (new_local_fd &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cur-&gt;fd_table[old_local_fd] = new_local_fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> new_global_fd = cur-&gt;fd_table[new_local_fd];</span><br><span class="line">        cur-&gt;fd_table[old_local_fd] = new_global_fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下shell中对管道的处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 针对管道的处理 */</span></span><br><span class="line"><span class="keyword">char</span> *pipe_symbol = <span class="built_in">strchr</span>(cmd_line, <span class="string">'|'</span>);</span><br><span class="line"><span class="keyword">if</span> (pipe_symbol)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 支持多重管道操作,如cmd1|cmd2|..|cmdn,</span></span><br><span class="line"><span class="comment">     * cmd1的标准输出和cmdn的标准输入需要单独处理 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1 生成管道*/</span></span><br><span class="line">    <span class="keyword">int32_t</span> fd[<span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;; <span class="comment">// fd[0]用于输入,fd[1]用于输出</span></span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="comment">/* 将标准输出重定向到fd[1],使后面的输出信息重定向到内核环形缓冲区 */</span></span><br><span class="line">    fd_redirect(stdout_no, fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2 第一个命令 */</span></span><br><span class="line">    <span class="keyword">char</span> *each_cmd = cmd_line;</span><br><span class="line">    pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>);</span><br><span class="line">    *pipe_symbol = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行第一个命令,命令的输出会写入环形缓冲区 */</span></span><br><span class="line">    argc = <span class="number">-1</span>;</span><br><span class="line">    argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">    cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 跨过'|',处理下一个命令 */</span></span><br><span class="line">    each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将标准输入重定向到fd[0],使之指向内核环形缓冲区*/</span></span><br><span class="line">    fd_redirect(stdin_no, fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">/*3 中间的命令,命令的输入和输出都是指向环形缓冲区 */</span></span><br><span class="line">    <span class="keyword">while</span> ((pipe_symbol = <span class="built_in">strchr</span>(each_cmd, <span class="string">'|'</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        *pipe_symbol = <span class="number">0</span>;</span><br><span class="line">        argc = <span class="number">-1</span>;</span><br><span class="line">        argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">        cmd_execute(argc, argv);</span><br><span class="line">        each_cmd = pipe_symbol + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4 处理管道中最后一个命令 */</span></span><br><span class="line">    <span class="comment">/* 将标准输出恢复屏幕 */</span></span><br><span class="line">    fd_redirect(stdout_no, stdout_no);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 执行最后一个命令 */</span></span><br><span class="line">    argc = <span class="number">-1</span>;</span><br><span class="line">    argc = cmd_parse(each_cmd, argv, <span class="string">' '</span>);</span><br><span class="line">    cmd_execute(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5  将标准输入恢复为键盘 */</span></span><br><span class="line">    fd_redirect(stdin_no, stdin_no);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*6 关闭管道 */</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/16/exec/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/16/exec/" class="post-title-link" itemprop="http://yoursite.com/index.html">二十二. 让shell支持外部命令</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-16 00:14:30" itemprop="dateCreated datePublished" datetime="2018-05-16T00:14:30+08:00">2018-05-16</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h1><p>在linux的bash shell中，执行外部命令时，该shell会fork一个子进程，这个子进程调用exec从磁盘上加载外部命令对应的程序。这是exec的一个应用。通过它的应用来看原理</p>
<p>exec会把一个可执行文件的绝对路径作为参数，把当前正在运行的用户进程的进程体用该可执行文件的进程体替换，从而实现新进程的执行，而进程的pid是不变的。可以这样认为，exec并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。</p>
<p>从实现上来说，只需要加载一个新的进程，然后将当前进程的堆栈环境替换即可，下面是实现代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用path指向的程序替换当前进程 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_execv(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (argv[argc])</span><br><span class="line">    &#123;</span><br><span class="line">        argc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int32_t</span> entry_point = load(path);</span><br><span class="line">    <span class="keyword">if</span> (entry_point == <span class="number">-1</span>)</span><br><span class="line">    &#123; <span class="comment">// 若加载失败则返回-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task_struct *cur = running_thread();</span><br><span class="line">    <span class="comment">/* 修改进程名 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(cur-&gt;name, path, TASK_NAME_LEN);</span><br><span class="line">    cur-&gt;name[TASK_NAME_LEN - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    intr_stack *intr_0_stack = (intr_stack *)((<span class="keyword">uint32_t</span>)cur + PG_SIZE - <span class="keyword">sizeof</span>(intr_stack));</span><br><span class="line">    <span class="comment">/* 参数传递给用户进程 */</span></span><br><span class="line">    intr_0_stack-&gt;ebx = (<span class="keyword">int32_t</span>)argv;</span><br><span class="line">    intr_0_stack-&gt;ecx = argc;</span><br><span class="line">    intr_0_stack-&gt;eip = (<span class="keyword">void</span> *)entry_point;</span><br><span class="line">    <span class="comment">/* 使新用户进程的栈地址为最高用户空间地址 */</span></span><br><span class="line">    intr_0_stack-&gt;esp = (<span class="keyword">void</span> *)<span class="number">0xc0000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* exec不同于fork,为使新进程更快被执行,直接从中断返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"movl %0, %%esp; jmp intr_exit"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 :</span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"g"</span>(intr_0_stack)</span></span></span><br><span class="line"><span class="function"><span class="params">                 : <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想要让shell支持外部命令的话需要对当前的shell进行改进，当遇到外部命令时，fork一个子进程，让这个子进程来调用exec，那么外部的进程便执行起来了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    make_clear_abs_path(argv[<span class="number">0</span>], final_path);</span><br><span class="line">    argv[<span class="number">0</span>] = final_path;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">0</span>], &amp;file_stat) ！= <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execv(argv[<span class="number">0</span>], argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里稍微解释一下这里的两个while(1)。</p>
<p>第一次while(1)，也就是当前的shell进程，这个shell本身是一个死循环，处于不断的检测输入的状态，当fork一个子进程后，为了不使当前进程的堆栈数据被修改，使其在此空转，因为父进程一般会先与子进程执行，它再执行的话会对栈中的数据进行修改，比如子进程中将会使用到的final_path。</p>
<p>第二个while(1)，也就是子进程复制了父进程的数据会会执行到的代码，因为目前没有实现进程的退出，为了不使该进程乱执行，在其应该结束的位置使其空转。等到后面实现了wait和exit后，就可以将其替换掉。</p>
<p>目前的shell能够支持外部命令了，先随便写个进程测试一下效果。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/2Kk2HhjgLb.png?imageslim" alt=""><br>在我的linux上写了一个prog的程序，它的作用是输出一句话，将其用gcc编译链接成可执行文件后，将其写入到虚拟机的文件系统当中，图上就是它的执行效果啦。当然这个链接的过程必须使用目前这个kernel中支持的目标文件，比如printf函数，必须用我们自己实现的printf，而不是linux中自带的printf。所以用户进程所能实现的功能比较有限。</p>
<h1 id="支持参数的用户进程"><a href="#支持参数的用户进程" class="headerlink" title="支持参数的用户进程"></a>支持参数的用户进程</h1><p>在之前的内建命令中，传递参数还是非常简单的，在调用的时候将参数直接传递过去即可，内建的命令只是一个函数，还可以通过栈来传递参数。但是对于外部的命令来说，如何让其支持形如 “cat file”这样的命令呢，这个file就是前面所说的参数。</p>
<p>获取参数是在命令执行之前，要想把获取到的参数传递给某个命令，该命令所属的进程必须先有栈，但外部命令的执行，实质上是加载一个用户进程的过程，进程都没创建，更何况进程的栈了。</p>
<p>大家应该见过main函数的这种形式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main函数有了参数，那么这个参数是谁传递给他的，既然他有参数，那么肯定是被调用执行的，调用者将参数传给了它。这个调用者就是CRT(c 运行库)，CRT最主要的工作就是初始化运行环境，在进入main函数之前为用户进程准备条件，参数等。在main函数执行完返回之后，对用户进程的资源进行回收。</p>
<p>我们编译好的程序主体大概长这样<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/C22FB3gHCk.png?imageslim" alt=""></p>
<p>main函数只是夹在中间的一部分，既不是从它开始，也不是从它结束</p>
<p>当然这里不可能真的实现一个CRT，我们要做的工作只是将参数push进来，call main即可</p>
<p>所以这个简陋的CRT只有8行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[bits 32]</span><br><span class="line">extern main</span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">    ;这两个要和exec中指定的寄存器一致</span><br><span class="line">    push ebx    ;压入argv</span><br><span class="line">    push ecx    ;压入argc</span><br><span class="line">    call main</span><br></pre></td></tr></table></figure></p>
<p>这个才是程序真正的入口，既然真正的入口在这里，那么main函数的函数名是什么都不重要了，我们可以使用自己想取的任意名字，只是在习惯上使用main作为入口。</p>
<p>接下来测试一下带参数的版本，将参数打印出来。<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/mLCGbjA9Gb.png?imageslim" alt=""></p>
<h1 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h1><p>前面说了那么多进程方面的概念，但目前为止还没有实现一个真正能用的进程。下面就实现一下cat命令，当前，是简化之后的，通过这个命令查看普通文件的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buf_size = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">char</span> abs_path[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">void</span> *buf = <span class="built_in">malloc</span>(buf_size);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">'/'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        getcwd(abs_path, <span class="number">512</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(abs_path, <span class="string">"/"</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(abs_path, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(abs_path, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(abs_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> read_bytes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            read_bytes = read(fd, buf ,buf_size);</span><br><span class="line">            <span class="keyword">if</span> (read_bytes == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(std_out, buf, read_bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是cat的实现了。下面来测试一下其功能<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180516/9ik0m9kkf7.png?imageslim" alt=""></p>
<p>进程的基本功能有了，我们可以从磁盘上加载用户进程，可以通过shell执行外部命令。后面会实现一种进程同步的方式和一种进程间通信的方式</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/elf/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/15/elf/" class="post-title-link" itemprop="http://yoursite.com/index.html">二十一. elf文件格式解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-15 18:48:48" itemprop="dateCreated datePublished" datetime="2018-05-15T18:48:48+08:00">2018-05-15</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="elf文件格式"><a href="#elf文件格式" class="headerlink" title="elf文件格式"></a>elf文件格式</h1><p>我们的程序是通过gcc编译的，在linux下，gcc编译出来的可执行文件是elf格式的二进制文件。那么肯定要elf文件进行解析才能正确的得到进程可执行数据的位置。</p>
<p>下面介绍一下elf格式的几个基本概念</p>
<p>一个程序中最重要的部分是段和节，他们是真正的程序体，存储程序执行所需要的数据，程序中有很多段，常见的有代码段和数据段，段是由节组成的。多个节经过链接之后被合并成一个段。</p>
<p>段和节的信息用header来描述，程序头是program header，节头是section header。</p>
<p>程序中段的大小和数量不固定，节也是如此，因此需要一个专门的数据结构来描述他们，这个就是程序头表和节头表，他们用来存储多个程序头和节头，相当于数组的概念。</p>
<p>由于程序中段和节的数量不固定，程序头表和节头表的大小也就不固定。并且各表在程序中存储的先后顺序不同，所有这些表在程序中存储的位置也是不固定了，为了能方便的找到这些表的位置，获取其信息，需要一个固定的结构来描述他们，记录其存储的位置和大小等信息，这个结构就是elf header</p>
<p>elf格式的作用体现在两方面，一是链接阶段，二是运行阶段。下图是这两方面elf格式数据的布局<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/K837jihA1C.png?imageslim" alt=""></p>
<p>下面重点说一下elf header中的数据</p>
<h1 id="elf-header"><a href="#elf-header" class="headerlink" title="elf header"></a>elf header</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 32位elf头 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">    Elf32_Half e_type;</span><br><span class="line">    Elf32_Half e_machine;</span><br><span class="line">    Elf32_Word e_version;</span><br><span class="line">    Elf32_Addr e_entry;</span><br><span class="line">    Elf32_Off e_phoff;</span><br><span class="line">    Elf32_Off e_shoff;</span><br><span class="line">    Elf32_Word e_flags;</span><br><span class="line">    Elf32_Half e_ehsize;</span><br><span class="line">    Elf32_Half e_phentsize;</span><br><span class="line">    Elf32_Half e_phnum;</span><br><span class="line">    Elf32_Half e_shentsize;</span><br><span class="line">    Elf32_Half e_shnum;</span><br><span class="line">    Elf32_Half e_shstrndx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面是elf header中存储的数据，里面涉及这几种数据类型，数据类型的本质是其所占的字节数，赋予数据类型意义是为了方便里面，下图是这几种类型代表的意义。<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/LE444K0JJJ.png?imageslim" alt=""></p>
<p>接下来是e_ident这个成员所表示的意义，见下图<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/3AEj89Ic8m.png?imageslim" alt=""></p>
<p>下面是e_type所代表的意义<br>elf目标文件类型|取值|意义<br>—-|—-|—-<br>ET_NONE|0|未知目标文件格式<br>ET_REL|1|可重定位文件<br>ET_EXEC|2|可执行文件<br>ET_DYN|3|动态共享目标文件<br>ET_CORE|4|core文件<br>ET_LOPROC|0xff00|特定处理器文件的扩展下边界<br>ET_HIPROC|0xffff|特定处理器文件的扩展上边界</p>
<p>虽然这里有很多的类型，但我们使用的只有ET_EXEC.</p>
<p>接下来是e_machine，它表示该文件在哪种硬件平台上才能运行<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/hLB70846l6.png?imageslim" alt=""></p>
<p>后面还有的数据不一一描述，这里从书上截图来说明<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/lC3HIhJJiB.png?imageslim" alt=""></p>
<h1 id="program-header"><a href="#program-header" class="headerlink" title="program header"></a>program header</h1><p>程序头是专门用来描述段信息的，这个段不是内存中的段，内存中的段是记录在全局描述符表中的。程序头描述的段是磁盘上程序中的一个段，常见的如代码段和数据段，下面是其结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word p_type;</span><br><span class="line">    Elf32_Off p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;</span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>p_type所表示的意义如下<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/6152bkkDBF.png?imageslim" alt=""></p>
<p>p_offset表示本段在文件的偏移量<br>p_vaddr表示本段在内存中起始的虚拟地址<br>p_paddr仅用于与物理地址相关的系统中<br>p_fiesz表示本段在文件中的大小<br>p_memsz表示本段在内存中的大小<br>p_flags的意义见下图<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/EEDEf6KC03.png?imageslim" alt=""><br>p_align表示本段在文件和内存中的对齐方式。</p>
<p>目标文件在链接之后代码和数据等资源都是在段中，有了上面这些结构来记录相关信息，程序在加载的时候就根据这些信息从磁盘的某个位置将程序运行所需的资源加载到内存中，接下来通过一个实例对elf文件进行分析一下。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/AfeI0IbehF.png?imageslim" alt=""></p>
<p>这是我随便找的一个可执行文件查看的数据，用路线标出来的属于elf header中的数据，红线标出来的属于一个program header的数据，具体的意义可以对照着上面结构的字段去看。</p>
<p>接下来的工作就是要实现一个加载器，将一个可执行文件的段数据加载到内存中去。使cs：eip指向其入口地址，一个进程就运行起来了。</p>
<h1 id="实现进程加载器"><a href="#实现进程加载器" class="headerlink" title="实现进程加载器"></a>实现进程加载器</h1><p>elf header和program header的数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> Elf32_Word, Elf32_Addr, Elf32_Off;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> Elf32_Half;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 32位elf头 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">    Elf32_Half e_type;</span><br><span class="line">    Elf32_Half e_machine;</span><br><span class="line">    Elf32_Word e_version;</span><br><span class="line">    Elf32_Addr e_entry;</span><br><span class="line">    Elf32_Off e_phoff;</span><br><span class="line">    Elf32_Off e_shoff;</span><br><span class="line">    Elf32_Word e_flags;</span><br><span class="line">    Elf32_Half e_ehsize;</span><br><span class="line">    Elf32_Half e_phentsize;</span><br><span class="line">    Elf32_Half e_phnum;</span><br><span class="line">    Elf32_Half e_shentsize;</span><br><span class="line">    Elf32_Half e_shnum;</span><br><span class="line">    Elf32_Half e_shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序头表Program header.就是段描述头 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word p_type; <span class="comment">// 见下面的enum segment_type</span></span><br><span class="line">    Elf32_Off p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;</span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 段类型 */</span></span><br><span class="line"><span class="keyword">enum</span> segment_type</span><br><span class="line">&#123;</span><br><span class="line">    PT_NULL,    <span class="comment">// 忽略</span></span><br><span class="line">    PT_LOAD,    <span class="comment">// 可加载程序段</span></span><br><span class="line">    PT_DYNAMIC, <span class="comment">// 动态加载信息</span></span><br><span class="line">    PT_INTERP,  <span class="comment">// 动态加载器名称</span></span><br><span class="line">    PT_NOTE,    <span class="comment">// 一些辅助信息</span></span><br><span class="line">    PT_SHLIB,   <span class="comment">// 保留</span></span><br><span class="line">    PT_PHDR     <span class="comment">// 程序头表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>加载一个段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将文件描述符fd指向的文件中,偏移为offset,大小为filesz的段加载到虚拟地址为vaddr的内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">segment_load</span><span class="params">(<span class="keyword">int32_t</span> fd, <span class="keyword">uint32_t</span> offset, <span class="keyword">uint32_t</span> filesz, <span class="keyword">uint32_t</span> vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr_first_page = vaddr &amp; <span class="number">0xfffff000</span>;               <span class="comment">// vaddr地址所在的页框</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size_in_first_page = PG_SIZE - (vaddr &amp; <span class="number">0x00000fff</span>); <span class="comment">// 加载到内存后,文件在第一个页框中占用的字节大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> occupy_pages = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 若一个页框容不下该段 */</span></span><br><span class="line">    <span class="keyword">if</span> (filesz &gt; size_in_first_page)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> left_size = filesz - size_in_first_page;</span><br><span class="line">        occupy_pages = DIV_ROUND_UP(left_size, PG_SIZE) + <span class="number">1</span>; <span class="comment">// 1是指vaddr_first_page</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        occupy_pages = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为进程分配内存 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> page_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> vaddr_page = vaddr_first_page;</span><br><span class="line">    <span class="keyword">while</span> (page_idx &lt; occupy_pages)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> *pde = pde_ptr(vaddr_page);</span><br><span class="line">        <span class="keyword">uint32_t</span> *pte = pte_ptr(vaddr_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果pde不存在,或者pte不存在就分配内存.</span></span><br><span class="line"><span class="comment">       * pde的判断要在pte之前,否则pde若不存在会导致</span></span><br><span class="line"><span class="comment">       * 判断pte时缺页异常 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(*pde &amp; <span class="number">0x00000001</span>) || !(*pte &amp; <span class="number">0x00000001</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (get_a_page(PF_USER, vaddr_page) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// 如果原进程的页表已经分配了,利用现有的物理页,直接覆盖进程体</span></span><br><span class="line">        vaddr_page += PG_SIZE;</span><br><span class="line">        page_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    sys_lseek(fd, offset, SEEK_SET);</span><br><span class="line">    sys_read(fd, (<span class="keyword">void</span> *)vaddr, filesz);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件系统上加载用户程序pathname,成功则返回程序的起始地址,否则返回-1 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Ehdr</span> <span class="title">elf_header</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf32_Phdr</span> <span class="title">prog_header</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;elf_header, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct Elf32_Ehdr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> fd = sys_open(pathname, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sys_read(fd, &amp;elf_header, <span class="keyword">sizeof</span>(struct Elf32_Ehdr)) != <span class="keyword">sizeof</span>(struct Elf32_Ehdr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 校验elf头 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(elf_header.e_ident, <span class="string">"\177ELF\1\1\1"</span>, <span class="number">7</span>) || elf_header.e_type != <span class="number">2</span> || elf_header.e_machine != <span class="number">3</span> || elf_header.e_version != <span class="number">1</span> || elf_header.e_phnum &gt; <span class="number">1024</span> || elf_header.e_phentsize != <span class="keyword">sizeof</span>(struct Elf32_Phdr))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Elf32_Off prog_header_offset = elf_header.e_phoff;</span><br><span class="line">    Elf32_Half prog_header_size = elf_header.e_phentsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有程序头 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> prog_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (prog_idx &lt; elf_header.e_phnum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;prog_header, <span class="number">0</span>, prog_header_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将文件的指针定位到程序头 */</span></span><br><span class="line">        sys_lseek(fd, prog_header_offset, SEEK_SET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 只获取程序头 */</span></span><br><span class="line">        <span class="keyword">if</span> (sys_read(fd, &amp;prog_header, prog_header_size) != prog_header_size)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果是可加载段就调用segment_load加载到内存 */</span></span><br><span class="line">        <span class="keyword">if</span> (PT_LOAD == prog_header.p_type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!segment_load(fd, prog_header.p_offset, prog_header.p_filesz, prog_header.p_vaddr))</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 更新下一个程序头的偏移 */</span></span><br><span class="line">        prog_header_offset += elf_header.e_phentsize;</span><br><span class="line">        prog_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = elf_header.e_entry;</span><br><span class="line">done:</span><br><span class="line">    sys_close(fd);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/shell1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/15/shell1/" class="post-title-link" itemprop="http://yoursite.com/index.html">二十. 内建shell的实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-15 15:38:14" itemprop="dateCreated datePublished" datetime="2018-05-15T15:38:14+08:00">2018-05-15</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="路径解析转换"><a href="#路径解析转换" class="headerlink" title="路径解析转换"></a>路径解析转换</h1><p>路径有绝对路径和相对路径之分，在平常使用linux的过程中，我们在输入命令和参数的时候，往往使用的都是相对路径。相对路径是基于当前的工作路径的出的。</p>
<p>当前工作路径 + 相对路径 = 绝对路径</p>
<p>比如说当前工作路径为 <strong>/home/work</strong> 此时输入 ls file，那么file所在的绝对路径就是 <strong>/home/work/file</strong> 了。</p>
<p>因为这个kernel比较简单，如果路径以根目录/ 开头，就会被认为是绝对路径，其他的路径都会被认为是相对路径，会将其转换成绝对路径来使用。</p>
<p>以下是路径转换函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将路径old_abs_path中的..和.转换为实际路径后存入new_abs_path */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wash_path</span><span class="params">(<span class="keyword">char</span> *old_abs_path, <span class="keyword">char</span> *new_abs_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(old_abs_path[<span class="number">0</span>] == <span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">char</span> name[MAX_FILE_NAME_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *sub_path = old_abs_path;</span><br><span class="line">    sub_path = path_parse(sub_path, name);</span><br><span class="line">    <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 若只键入了"/",直接将"/"存入new_abs_path后返回</span></span><br><span class="line">        new_abs_path[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">        new_abs_path[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_abs_path[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 避免传给new_abs_path的缓冲区不干净</span></span><br><span class="line">    <span class="built_in">strcat</span>(new_abs_path, <span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">while</span> (name[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果是上一级目录“..” */</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">".."</span>, name))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *slash_ptr = <span class="built_in">strrchr</span>(new_abs_path, <span class="string">'/'</span>);</span><br><span class="line">            <span class="comment">/*如果未到new_abs_path中的顶层目录,就将最右边的'/'替换为0,</span></span><br><span class="line"><span class="comment">	 这样便去除了new_abs_path中最后一层路径,相当于到了上一级目录 */</span></span><br><span class="line">            <span class="keyword">if</span> (slash_ptr != new_abs_path)</span><br><span class="line">            &#123; <span class="comment">// 如new_abs_path为“/a/b”,".."之后则变为“/a”</span></span><br><span class="line">                *slash_ptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">// 如new_abs_path为"/a",".."之后则变为"/"</span></span><br><span class="line">                <span class="comment">/* 若new_abs_path中只有1个'/',即表示已经到了顶层目录,就将下一个字符置为结束符0. */</span></span><br><span class="line">                *(slash_ptr + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"."</span>, name))</span><br><span class="line">        &#123; <span class="comment">// 如果路径不是‘.’,就将name拼接到new_abs_path</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(new_abs_path, <span class="string">"/"</span>))</span><br><span class="line">            &#123; <span class="comment">// 如果new_abs_path不是"/",就拼接一个"/",此处的判断是为了避免路径开头变成这样"//"</span></span><br><span class="line">                <span class="built_in">strcat</span>(new_abs_path, <span class="string">"/"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcat</span>(new_abs_path, name);</span><br><span class="line">        &#125; <span class="comment">// 若name为当前目录".",无须处理new_abs_path</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 继续遍历下一层路径 */</span></span><br><span class="line">        <span class="built_in">memset</span>(name, <span class="number">0</span>, MAX_FILE_NAME_LEN);</span><br><span class="line">        <span class="keyword">if</span> (sub_path)</span><br><span class="line">        &#123;</span><br><span class="line">            sub_path = path_parse(sub_path, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将path处理成不含..和.的绝对路径,存储在final_path */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_clear_abs_path</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> *final_path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> abs_path[MAX_PATH_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/* 先判断是否输入的是绝对路径 */</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">'/'</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 若输入的不是绝对路径,就拼接成绝对路径</span></span><br><span class="line">        <span class="built_in">memset</span>(abs_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">        <span class="keyword">if</span> (getcwd(abs_path, MAX_PATH_LEN) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!((abs_path[<span class="number">0</span>] == <span class="string">'/'</span>) &amp;&amp; (abs_path[<span class="number">1</span>] == <span class="number">0</span>)))</span><br><span class="line">            &#123; <span class="comment">// 若abs_path表示的当前目录不是根目录/</span></span><br><span class="line">                <span class="built_in">strcat</span>(abs_path, <span class="string">"/"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(abs_path, path);</span><br><span class="line">    wash_path(abs_path, final_path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路径转换完成之后接下来就来实现几个常用的shell。</p>
<h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p>ls的命令支持以下形式 <strong>ls -l, ls -h, ls filename</strong>，它们的功能自不必多说，函数的前半部分对其参数进行解析，后半部分根据参数对应的功能构造好路径，将对应的信息输出出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ls命令的内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_ls</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pathname = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">    <span class="keyword">bool</span> long_info = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg_path_nr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg_idx = <span class="number">1</span>; <span class="comment">// 跨过argv[0],argv[0]是字符串“ls”</span></span><br><span class="line">    <span class="keyword">while</span> (arg_idx &lt; argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[arg_idx][<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">        &#123; <span class="comment">// 如果是选项,单词的首字符是-</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"-l"</span>, argv[arg_idx]))</span><br><span class="line">            &#123; <span class="comment">// 如果是参数-l</span></span><br><span class="line">                long_info = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"-h"</span>, argv[arg_idx]))</span><br><span class="line">            &#123; <span class="comment">// 参数-h</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"usage: -l list all infomation about the file.\n-h for help\nlist all files in the current dirctory if no option\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123; <span class="comment">// 只支持-h -l两个选项</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ls: invalid option %s\nTry `ls -h' for more information.\n"</span>, argv[arg_idx]);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// ls的路径参数</span></span><br><span class="line">            <span class="keyword">if</span> (arg_path_nr == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pathname = argv[arg_idx];</span><br><span class="line">                arg_path_nr = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ls: only support one path\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arg_idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pathname == <span class="literal">NULL</span>)</span><br><span class="line">    &#123; <span class="comment">// 若只输入了ls 或 ls -l,没有输入操作路径,默认以当前路径的绝对路径为参数.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != getcwd(final_path, MAX_PATH_LEN))</span><br><span class="line">        &#123;</span><br><span class="line">            pathname = final_path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ls: getcwd for default path failed\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        make_clear_abs_path(pathname, final_path);</span><br><span class="line">        pathname = final_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stat(pathname, &amp;file_stat) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ls: cannot access %s: No such file or directory\n"</span>, pathname);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (file_stat.st_filetype == FT_DIRECTORY)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dir</span> *<span class="title">dir</span> = <span class="title">opendir</span>(<span class="title">pathname</span>);</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> *<span class="title">dir_e</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">char</span> sub_pathname[MAX_PATH_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">uint32_t</span> pathname_len = <span class="built_in">strlen</span>(pathname);</span><br><span class="line">        <span class="keyword">uint32_t</span> last_char_idx = pathname_len - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(sub_pathname, pathname, pathname_len);</span><br><span class="line">        <span class="keyword">if</span> (sub_pathname[last_char_idx] != <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sub_pathname[pathname_len] = <span class="string">'/'</span>;</span><br><span class="line">            pathname_len++;</span><br><span class="line">        &#125;</span><br><span class="line">        rewinddir(dir);</span><br><span class="line">        <span class="keyword">if</span> (long_info)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> ftype;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"total: %d\n"</span>, file_stat.st_size);</span><br><span class="line">            <span class="keyword">while</span> ((dir_e = readdir(dir)))</span><br><span class="line">            &#123;</span><br><span class="line">                ftype = <span class="string">'d'</span>;</span><br><span class="line">                <span class="keyword">if</span> (dir_e-&gt;f_type == FT_REGULAR)</span><br><span class="line">                &#123;</span><br><span class="line">                    ftype = <span class="string">'-'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sub_pathname[pathname_len] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">strcat</span>(sub_pathname, dir_e-&gt;filename);</span><br><span class="line">                <span class="built_in">memset</span>(&amp;file_stat, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line">                <span class="keyword">if</span> (stat(sub_pathname, &amp;file_stat) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"ls: cannot access %s: No such file or directory\n"</span>, dir_e-&gt;filename);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c  %d  %d  %s\n"</span>, ftype, dir_e-&gt;i_no, file_stat.st_size, dir_e-&gt;filename);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ((dir_e = readdir(dir)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s "</span>, dir_e-&gt;filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (long_info)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-  %d  %d  %s\n"</span>, file_stat.st_ino, file_stat.st_size, pathname);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pathname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* cd命令的内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">buildin_cd</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cd: only support 1 argument!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若是只键入cd而无参数,直接返回到根目录. */</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        final_path[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">        final_path[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        make_clear_abs_path(argv[<span class="number">1</span>], final_path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chdir(final_path) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cd: no such directory %s\n"</span>, final_path);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> final_path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mkdir命令内建函数 */</span></span><br><span class="line"><span class="keyword">int32_t</span> buildin_mkdir(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mkdir: only support 1 argument!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        make_clear_abs_path(argv[<span class="number">1</span>], final_path);</span><br><span class="line">        <span class="comment">/* 若创建的不是根目录 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"/"</span>, final_path))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mkdir(final_path) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"mkdir: create directory %s failed.\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rmdir命令内建函数 */</span></span><br><span class="line"><span class="keyword">int32_t</span> buildin_rmdir(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rmdir: only support 1 argument!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        make_clear_abs_path(argv[<span class="number">1</span>], final_path);</span><br><span class="line">        <span class="comment">/* 若删除的不是根目录 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"/"</span>, final_path))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rmdir(final_path) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"rmdir: remove %s failed.\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* rm命令内建函数 */</span><br><span class="line">int32_t buildin_rm(uint32_t argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int32_t ret = -1;</span><br><span class="line">    if (argc != 2)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;rm: only support 1 argument!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        make_clear_abs_path(argv[1], final_path);</span><br><span class="line">        /* 若删除的不是根目录 */</span><br><span class="line">        if (strcmp(&quot;/&quot;, final_path))</span><br><span class="line">        &#123;</span><br><span class="line">            if (unlink(final_path) == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;rm: delete %s failed.\n&quot;, argv[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ps命令内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_ps</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span> **argv UNUSED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ps: no argument support!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear命令内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_clear</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span> **argv UNUSED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"clear: no argument support!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pwd命令的内建函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildin_pwd</span><span class="params">(<span class="keyword">uint32_t</span> argc, <span class="keyword">char</span> **argv UNUSED)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pwd: no argument support!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != getcwd(final_path, MAX_PATH_LEN))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, final_path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"pwd: get current work directory failed.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的很多对文件和目录操作的命令都是在文件系统中实现的，这里只是对其进一步的封装。</p>
<p>接下来就要为这些命令提供统一的调用接口，也就是shell拉。</p>
<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>shell在执行的时候肯定要对用户的输入进行解析，根据解析结果找到对应的处理程序，然后调用执行，首先上命令解析函数</p>
<p>该函数主要是对命令进行拆分，根据其拆分标志，一般是空格，将一个个分割好的参数存入argv中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分析字符串cmd_str中以token为分隔符的单词,将各单词的指针存入argv数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">cmd_parse</span><span class="params">(<span class="keyword">char</span> *cmd_str, <span class="keyword">char</span> **argv, <span class="keyword">char</span> token)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(cmd_str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int32_t</span> arg_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (arg_idx &lt; MAX_ARG_NR)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[arg_idx] = <span class="literal">NULL</span>;</span><br><span class="line">        arg_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *next = cmd_str;</span><br><span class="line">    <span class="keyword">int32_t</span> argc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 外层循环处理整个命令行 */</span></span><br><span class="line">    <span class="keyword">while</span> (*next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 去除命令字或参数之间的空格 */</span></span><br><span class="line">        <span class="keyword">while</span> (*next == token)</span><br><span class="line">        &#123;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 处理最后一个参数后接空格的情况,如"ls dir2 " */</span></span><br><span class="line">        <span class="keyword">if</span> (*next == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        argv[argc] = next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 内层循环处理命令行中的每个命令字及参数 */</span></span><br><span class="line">        <span class="keyword">while</span> (*next &amp;&amp; *next != token)</span><br><span class="line">        &#123; <span class="comment">// 在字符串结束前找单词分隔符</span></span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果未结束(是token字符),使tocken变成0 */</span></span><br><span class="line">        <span class="keyword">if</span> (*next)</span><br><span class="line">        &#123;</span><br><span class="line">            *next++ = <span class="number">0</span>; <span class="comment">// 将token字符替换为字符串结束符0,做为一个单词的结束,并将字符指针next指向下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 避免argv数组访问越界,参数过多则返回0 */</span></span><br><span class="line">        <span class="keyword">if</span> (argc &gt; MAX_ARG_NR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        argc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> argc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就上shell拉。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_shell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cwd_cache[<span class="number">0</span>] = <span class="string">'/'</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print_prompt();</span><br><span class="line">        <span class="built_in">memset</span>(final_path, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">        <span class="built_in">memset</span>(cmd_line, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">        readline(cmd_line, MAX_PATH_LEN);</span><br><span class="line">        <span class="keyword">if</span> (cmd_line[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 若只键入了一个回车</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        argc = <span class="number">-1</span>;</span><br><span class="line">        argc = cmd_parse(cmd_line, argv, <span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"num of arguments exceed %d\n"</span>, MAX_ARG_NR);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"ls"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            buildin_ls(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"cd"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buildin_cd(argc, argv) != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(cwd_cache, <span class="number">0</span>, MAX_PATH_LEN);</span><br><span class="line">                <span class="built_in">strcpy</span>(cwd_cache, final_path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"pwd"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            buildin_pwd(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"ps"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            buildin_ps(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"clear"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            buildin_clear(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"mkdir"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            buildin_mkdir(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"rmdir"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            buildin_rmdir(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"rm"</span>, argv[<span class="number">0</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            buildin_rm(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"external command\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上一节中说了，执行这个shell的是init进程fork出的子进程，所以要将这个myshell函数放入init进程中，当fork返回值为0时，就执行myshell<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fork)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> (fork == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myshell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是init进程目前所做的工作，它是在内核主线程创建之前就已经创建好了的进程。</p>
<p>接下来就运行一下，享受一下成果。<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/75CmAAFmFD.png?imageslim" alt=""><br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/2Fck56F72A.png?imageslim" alt="mark"></p>
<p>可以看到确实能进行一定程度上的交互了，但是目前的命令都是内部命令，写死在程序中的，这样想新增命令时非常不方便，所以后面要实现加载用户程序，让shell支持外部命令。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/shell/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/15/shell/" class="post-title-link" itemprop="http://yoursite.com/index.html">十九. fork的原理及实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-15 14:30:34" itemprop="dateCreated datePublished" datetime="2018-05-15T14:30:34+08:00">2018-05-15</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="fork的原理"><a href="#fork的原理" class="headerlink" title="fork的原理"></a>fork的原理</h1><p>先通过下面这段代码简单的介绍一下fork这个函数，了解一下它的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am father, my pid is %d\n"</span>, getpid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child, my pid is %d\n"</span>, getpid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是这段代码的运行结果<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/57CmIh6kD1.png?imageslim" alt=""><br>看到这个结果是不是很奇怪，为什么if的分支执行到了，else的分支也执行到了。这明显不符合程序执行最基本的原理。这个放到后面再来解释，先来了解一下fork这个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> fork();</span><br></pre></td></tr></table></figure>
<p>上面是fork函数的原型，它有三个返回值</p>
<ul>
<li>该进程为父进程时，返回子进程的pid</li>
<li>该进程为子进程时，返回0</li>
<li>fork执行失败，返回-1</li>
</ul>
<p>那么问题来了，fork它是如何知道一个进程是父进程还是子进程的。</p>
<p>这个就涉及到fork本身的功能了，它的作用是克隆进程，也就是将原先的一个进程再克隆出一个来，克隆出的这个进程就是原进程的子进程，这个子进程和其他的进程没有什么区别，同样拥有自己的独立的地址空间。不同的是子进程是在fork返回之后才开始执行的，就像一把叉子一样，执行fork之后，父子进程就分道扬镳了，所以fork这个名字就很形象，叉子的意思。</p>
<p>这幅图就非常形象</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/GGfiJL6JKH.png?imageslim" alt=""></p>
<p>接下来同过ps命令查看一下是否真的出现了两个一样的进程<br><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180515/5E60i4m91I.png?imageslim" alt=""></p>
<p>透过这些现象，来看一下fork的本质。</p>
<p>fork在执行之后，会创建出一个新的进程，这个新的进程内部的数据是原进程所有数据的一份拷贝。因此fork就相当于把某个进程的全部资源复制了一遍，然后让cs：eip指向新进程的指令部分。</p>
<p>fork给父进程返回子进程pid，给其拷贝出来的子进程返回0，这也是他的特点之一，一次调用，两次返回。两次返回看上去有点神秘，实质是在子进程的栈中构造好数据后，子进程从栈中获取到的返回值。</p>
<p>接下来就看看fork的实现</p>
<h1 id="fork的实现"><a href="#fork的实现" class="headerlink" title="fork的实现"></a>fork的实现</h1><p>fork的实现分为以下两步</p>
<ol>
<li>复制进程资源</li>
<li>执行该进程</li>
</ol>
<p>复制进程的资源包括以下几步</p>
<ol>
<li>进程pcb</li>
<li>程序体，即代码段数据段等</li>
<li>用户栈</li>
<li>内核栈</li>
<li>虚拟内存池</li>
<li>页表</li>
</ol>
<p>进行进程的话就比较简单了，只需要将其加入到就绪队列即可，接下来就等待cpu的调度了。</p>
<p>将父进程的pcb、虚拟地址位图拷贝给子进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">copy_pcb_vaddrbitmap_stack0</span><span class="params">(task_struct *child_thread, task_struct *parent_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">/* a 复制pcb所在的整个页,里面包含进程pcb信息及特级0极的栈,里面包含了返回地址, 然后再单独修改个别部分 */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(child_thread, parent_thread, PG_SIZE);</span><br><span class="line">      child_thread-&gt;pid = fork_pid();</span><br><span class="line">      child_thread-&gt;elapsed_ticks = <span class="number">0</span>;</span><br><span class="line">      child_thread-&gt;status = TASK_READY;</span><br><span class="line">      child_thread-&gt;ticks = child_thread-&gt;priority; <span class="comment">// 为新进程把时间片充满</span></span><br><span class="line">      child_thread-&gt;parent_pid = parent_thread-&gt;pid;</span><br><span class="line">      child_thread-&gt;general_tag.prev = child_thread-&gt;general_tag.next = <span class="literal">NULL</span>;</span><br><span class="line">      child_thread-&gt;all_list_tag.prev = child_thread-&gt;all_list_tag.next = <span class="literal">NULL</span>;</span><br><span class="line">      block_desc_init(child_thread-&gt;u_block_desc);</span><br><span class="line">      <span class="comment">/* b 复制父进程的虚拟地址池的位图 */</span></span><br><span class="line">      <span class="keyword">uint32_t</span> bitmap_pg_cnt = DIV_ROUND_UP((<span class="number">0xc0000000</span> - USER_VADDR_START) / PG_SIZE / <span class="number">8</span>, PG_SIZE);</span><br><span class="line">      <span class="keyword">void</span> *vaddr_btmp = get_kernel_pages(bitmap_pg_cnt);</span><br><span class="line">      <span class="keyword">if</span> (vaddr_btmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      <span class="comment">/* 此时child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits还是指向父进程虚拟地址的位图地址</span></span><br><span class="line"><span class="comment">    * 下面将child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits指向自己的位图vaddr_btmp */</span></span><br><span class="line">      <span class="built_in">memcpy</span>(vaddr_btmp, child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits, bitmap_pg_cnt * PG_SIZE);</span><br><span class="line">      child_thread-&gt;userprog_vaddr.vaddr_bitmap.bits = vaddr_btmp;</span><br><span class="line">     </span><br><span class="line">      ASSERT(<span class="built_in">strlen</span>(child_thread-&gt;name) &lt; <span class="number">11</span>); <span class="comment">// pcb.name的长度是16,为避免下面strcat越界</span></span><br><span class="line">      <span class="built_in">strcat</span>(child_thread-&gt;name, <span class="string">"_fork"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复制子进程的进程体(代码和数据)及用户栈<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy_body_stack3</span><span class="params">(task_struct *child_thread, task_struct *parent_thread, <span class="keyword">void</span> *buf_page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">uint8_t</span> *vaddr_btmp = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.bits;</span><br><span class="line">      <span class="keyword">uint32_t</span> btmp_bytes_len = parent_thread-&gt;userprog_vaddr.vaddr_bitmap.btmp_bytes_len;</span><br><span class="line">      <span class="keyword">uint32_t</span> vaddr_start = parent_thread-&gt;userprog_vaddr.vaddr_start;</span><br><span class="line">      <span class="keyword">uint32_t</span> idx_byte = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">uint32_t</span> idx_bit = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">uint32_t</span> prog_vaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 在父进程的用户空间中查找已有数据的页 */</span></span><br><span class="line">      <span class="keyword">while</span> (idx_byte &lt; btmp_bytes_len)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">if</span> (vaddr_btmp[idx_byte])</span><br><span class="line">            &#123;</span><br><span class="line">                  idx_bit = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">while</span> (idx_bit &lt; <span class="number">8</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((BITMAP_MASK &lt;&lt; idx_bit) &amp; vaddr_btmp[idx_byte])</span><br><span class="line">                        &#123;</span><br><span class="line">                              prog_vaddr = (idx_byte * <span class="number">8</span> + idx_bit) * PG_SIZE + vaddr_start;</span><br><span class="line">                              <span class="comment">/* 下面的操作是将父进程用户空间中的数据通过内核空间做中转,最终复制到子进程的用户空间 */</span></span><br><span class="line"></span><br><span class="line">                              <span class="comment">/* a 将父进程在用户空间中的数据复制到内核缓冲区buf_page,</span></span><br><span class="line"><span class="comment">	       目的是下面切换到子进程的页表后,还能访问到父进程的数据*/</span></span><br><span class="line">                              <span class="built_in">memcpy</span>(buf_page, (<span class="keyword">void</span> *)prog_vaddr, PG_SIZE);</span><br><span class="line"></span><br><span class="line">                              <span class="comment">/* b 将页表切换到子进程,目的是避免下面申请内存的函数将pte及pde安装在父进程的页表中 */</span></span><br><span class="line">                              page_dir_activate(child_thread);</span><br><span class="line">                              <span class="comment">/* c 申请虚拟地址prog_vaddr */</span></span><br><span class="line">                              get_a_page_without_opvaddrbitmap(PF_USER, prog_vaddr);</span><br><span class="line"></span><br><span class="line">                              <span class="comment">/* d 从内核缓冲区中将父进程数据复制到子进程的用户空间 */</span></span><br><span class="line">                              <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)prog_vaddr, buf_page, PG_SIZE);</span><br><span class="line"></span><br><span class="line">                              <span class="comment">/* e 恢复父进程页表 */</span></span><br><span class="line">                              page_dir_activate(parent_thread);</span><br><span class="line">                        &#125;</span><br><span class="line">                        idx_bit++;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            idx_byte++;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为子进程构建thread_stack和修改返回值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">build_child_stack</span><span class="params">(task_struct *child_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">/* a 使子进程pid返回值为0 */</span></span><br><span class="line">      <span class="comment">/* 获取子进程0级栈栈顶 */</span></span><br><span class="line">      intr_stack *intr_0_stack = (intr_stack *)((<span class="keyword">uint32_t</span>)child_thread + PG_SIZE - <span class="keyword">sizeof</span>(intr_stack));</span><br><span class="line">      <span class="comment">/* 修改子进程的返回值为0 */</span></span><br><span class="line">      intr_0_stack-&gt;eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* b 为switch_to 构建 struct thread_stack,将其构建在紧临intr_stack之下的空间*/</span></span><br><span class="line">      <span class="keyword">uint32_t</span> *ret_addr_in_thread_stack = (<span class="keyword">uint32_t</span> *)intr_0_stack - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* ebp在thread_stack中的地址便是当时的esp(0级栈的栈顶),</span></span><br><span class="line"><span class="comment">   即esp为"(uint32_t*)intr_0_stack - 5" */</span></span><br><span class="line">      <span class="keyword">uint32_t</span> *ebp_ptr_in_thread_stack = (<span class="keyword">uint32_t</span> *)intr_0_stack - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* switch_to的返回地址更新为intr_exit,直接从中断返回 */</span></span><br><span class="line">      *ret_addr_in_thread_stack = (<span class="keyword">uint32_t</span>)intr_exit;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 把构建的thread_stack的栈顶做为switch_to恢复数据时的栈顶 */</span></span><br><span class="line">      child_thread-&gt;self_kstack = ebp_ptr_in_thread_stack;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拷贝父进程本身所占资源给子进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> int32_t <span class="title">copy_process</span><span class="params">(task_struct *child_thread, task_struct *parent_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">/* 内核缓冲区,作为父进程用户空间的数据复制到子进程用户空间的中转 */</span></span><br><span class="line">      <span class="keyword">void</span> *buf_page = get_kernel_pages(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (buf_page == <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* a 复制父进程的pcb、虚拟地址位图、内核栈到子进程 */</span></span><br><span class="line">      <span class="keyword">if</span> (copy_pcb_vaddrbitmap_stack0(child_thread, parent_thread) == <span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* b 为子进程创建页表,此页表仅包括内核空间 */</span></span><br><span class="line">      child_thread-&gt;pgdir = create_page_dir();</span><br><span class="line">      <span class="keyword">if</span> (child_thread-&gt;pgdir == <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* c 复制父进程进程体及用户栈给子进程 */</span></span><br><span class="line">      copy_body_stack3(child_thread, parent_thread, buf_page);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* d 构建子进程thread_stack和修改返回值pid */</span></span><br><span class="line">      build_child_stack(child_thread);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* e 更新文件inode的打开数 */</span></span><br><span class="line">      update_inode_open_cnts(child_thread);</span><br><span class="line"></span><br><span class="line">      mfree_page(PF_KERNEL, buf_page, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fork子进程,内核线程不可直接调用 */</span></span><br><span class="line"><span class="keyword">pid_t</span> sys_fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">      task_struct *parent_thread = running_thread();</span><br><span class="line">      task_struct *child_thread = get_kernel_pages(<span class="number">1</span>); <span class="comment">// 为子进程创建pcb(task_struct结构)</span></span><br><span class="line">      <span class="keyword">if</span> (child_thread == <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ASSERT(INTR_OFF == intr_get_status() &amp;&amp; parent_thread-&gt;pgdir != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (copy_process(child_thread, parent_thread) == <span class="number">-1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 添加到就绪线程队列和所有线程队列,子进程由调试器安排运行 */</span></span><br><span class="line">      ASSERT(!elem_find(&amp;thread_ready_list, &amp;child_thread-&gt;general_tag));</span><br><span class="line">      list_append(&amp;thread_ready_list, &amp;child_thread-&gt;general_tag);</span><br><span class="line">      ASSERT(!elem_find(&amp;thread_all_list, &amp;child_thread-&gt;all_list_tag));</span><br><span class="line">      list_append(&amp;thread_all_list, &amp;child_thread-&gt;all_list_tag);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> child_thread-&gt;pid; <span class="comment">// 父进程返回子进程的pid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="fork的应用"><a href="#fork的应用" class="headerlink" title="fork的应用"></a>fork的应用</h1><p>fork的应用场景非常多，这里只讨论在这里kernel中的应用。</p>
<p>在之后的内容中，将会实现shell，那么这个shell由谁来调用呢。比如说内建的shell命令，他是写死在程序中的，本质上就是一个函数。肯定要有一个东西来调用它</p>
<p>在这个kernel的设计中，会有一个init进程，通过这个init进程fork出一个子进程，这个子进程就专门来处理我们的shell。</p>
<p>下一节就会实现shell了。终于从内核层到了用户层，可以直观的看出效果了。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/filesystem4/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/15/filesystem4/" class="post-title-link" itemprop="http://yoursite.com/index.html">十八. 文件系统四(文件的读写与删除)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-15 12:37:36" itemprop="dateCreated datePublished" datetime="2018-05-15T12:37:36+08:00">2018-05-15</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h1><p>文件的数据都是记录在inode中的文件块中，在该文件系统的设计中，只用了12个直接块和一个间接块来存储文件，所以一个文件最大可以存放 140 * 512字节的数据。</p>
<p>写文件的过程对文件块和扇区的分配过程，根据当前要写入的数据量大小，来判断是否需要分配新的数据块。如果12个直接块不够存储该数据，就分配间接块来存储，当所需的数据块分配好了之后，就会逐块的往硬盘上写入数据，知道所有的数据被写入硬盘，最后返回写入的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把buf中的count个字节写入file,成功则返回写入的字节数,失败则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_write(struct file *file, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((file-&gt;fd_inode-&gt;i_size + count) &gt; (BLOCK_SIZE * <span class="number">140</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文件目前最大只支持512*140=71680字节</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint8_t</span> *io_buf = sys_malloc(BLOCK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> *all_blocks = (<span class="keyword">uint32_t</span> *)sys_malloc(BLOCK_SIZE + <span class="number">48</span>); <span class="comment">// 用来记录文件所有的块地址</span></span><br><span class="line">    <span class="keyword">if</span> (all_blocks == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"file_write: sys_malloc for all_blocks failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src = buf;      <span class="comment">// 用src指向buf中待写入的数据</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bytes_written = <span class="number">0</span>;    <span class="comment">// 用来记录已写入数据大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size_left = count;    <span class="comment">// 用来记录未写入数据大小</span></span><br><span class="line">    <span class="keyword">int32_t</span> block_lba = <span class="number">-1</span>;        <span class="comment">// 块地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> block_bitmap_idx = <span class="number">0</span>; <span class="comment">// 用来记录block对应于block_bitmap中的索引,做为参数传给bitmap_sync</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sec_idx;              <span class="comment">// 用来索引扇区</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sec_lba;              <span class="comment">// 扇区地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sec_off_bytes;        <span class="comment">// 扇区内字节偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sec_left_bytes;       <span class="comment">// 扇区内剩余字节量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> chunk_size;           <span class="comment">// 每次写入硬盘的数据块大小</span></span><br><span class="line">    <span class="keyword">int32_t</span> indirect_block_table;  <span class="comment">// 用来获取一级间接表地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> block_idx;            <span class="comment">// 块索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断文件是否是第一次写,如果是,先为其分配一个块 */</span></span><br><span class="line">    <span class="keyword">if</span> (file-&gt;fd_inode-&gt;i_sectors[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">        <span class="keyword">if</span> (block_lba == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;fd_inode-&gt;i_sectors[<span class="number">0</span>] = block_lba;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">        block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">        ASSERT(block_bitmap_idx != <span class="number">0</span>);</span><br><span class="line">        bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 写入count个字节前,该文件已经占用的块数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> file_has_used_blocks = file-&gt;fd_inode-&gt;i_size / BLOCK_SIZE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 存储count字节后该文件将占用的块数 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> file_will_use_blocks = (file-&gt;fd_inode-&gt;i_size + count) / BLOCK_SIZE + <span class="number">1</span>;</span><br><span class="line">    ASSERT(file_will_use_blocks &lt;= <span class="number">140</span>);</span><br><span class="line">    <span class="comment">/* 通过此增量判断是否需要分配扇区,如增量为0,表示原扇区够用 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> add_blocks = file_will_use_blocks - file_has_used_blocks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始将文件所有块地址收集到all_blocks,(系统中块大小等于扇区大小)</span></span><br><span class="line"><span class="comment">     * 后面都统一在all_blocks中获取写入扇区地址 */</span></span><br><span class="line">    <span class="keyword">if</span> (add_blocks == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 在同一扇区内写入数据,不涉及到分配新扇区 */</span></span><br><span class="line">        <span class="keyword">if</span> (file_has_used_blocks &lt;= <span class="number">12</span>)</span><br><span class="line">        &#123;                                         <span class="comment">// 文件数据量将在12块之内</span></span><br><span class="line">            block_idx = file_has_used_blocks - <span class="number">1</span>; <span class="comment">// 指向最后一个已有数据的扇区</span></span><br><span class="line">            all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 未写入新数据之前已经占用了间接块,需要将间接块地址读进来 */</span></span><br><span class="line">            ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>);</span><br><span class="line">            indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];</span><br><span class="line">            ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 若有增量,便涉及到分配新扇区及是否分配一级间接块表,下面要分三种情况处理 */</span></span><br><span class="line">        <span class="comment">/* 第一种情况:12个直接块够用*/</span></span><br><span class="line">        <span class="keyword">if</span> (file_will_use_blocks &lt;= <span class="number">12</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 先将有剩余空间的可继续用的扇区地址写入all_blocks */</span></span><br><span class="line">            block_idx = file_has_used_blocks - <span class="number">1</span>;</span><br><span class="line">            ASSERT(file-&gt;fd_inode-&gt;i_sectors[block_idx] != <span class="number">0</span>);</span><br><span class="line">            all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 再将未来要用的扇区分配好后写入all_blocks */</span></span><br><span class="line">            block_idx = file_has_used_blocks; <span class="comment">// 指向第一个要分配的新扇区</span></span><br><span class="line">            <span class="keyword">while</span> (block_idx &lt; file_will_use_blocks)</span><br><span class="line">            &#123;</span><br><span class="line">                block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">                <span class="keyword">if</span> (block_lba == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 写文件时,不应该存在块未使用但已经分配扇区的情况,当文件删除时,就会把块地址清0 */</span></span><br><span class="line">                ASSERT(file-&gt;fd_inode-&gt;i_sectors[block_idx] == <span class="number">0</span>); <span class="comment">// 确保尚未分配扇区地址</span></span><br><span class="line">                file-&gt;fd_inode-&gt;i_sectors[block_idx] = all_blocks[block_idx] = block_lba;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">                block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">                bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">                block_idx++; <span class="comment">// 下一个分配的新扇区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (file_has_used_blocks &lt;= <span class="number">12</span> &amp;&amp; file_will_use_blocks &gt; <span class="number">12</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第二种情况: 旧数据在12个直接块内,新数据将使用间接块*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 先将有剩余空间的可继续用的扇区地址收集到all_blocks */</span></span><br><span class="line">            block_idx = file_has_used_blocks - <span class="number">1</span>; <span class="comment">// 指向旧数据所在的最后一个扇区</span></span><br><span class="line">            all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">            <span class="comment">/* 创建一级间接块表 */</span></span><br><span class="line">            block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">            <span class="keyword">if</span> (block_lba == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] == <span class="number">0</span>); <span class="comment">// 确保一级间接块表未分配</span></span><br><span class="line">            <span class="comment">/* 分配一级间接块索引表 */</span></span><br><span class="line">            indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] = block_lba;</span><br><span class="line"></span><br><span class="line">            block_idx = file_has_used_blocks; <span class="comment">// 第一个未使用的块,即本文件最后一个已经使用的直接块的下一块</span></span><br><span class="line">            <span class="keyword">while</span> (block_idx &lt; file_will_use_blocks)</span><br><span class="line">            &#123;</span><br><span class="line">                block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">                <span class="keyword">if</span> (block_lba == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(<span class="string">"file_write: block_bitmap_alloc for situation 2 failed\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (block_idx &lt; <span class="number">12</span>)</span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="comment">// 新创建的0~11块直接存入all_blocks数组</span></span><br><span class="line">                    ASSERT(file-&gt;fd_inode-&gt;i_sectors[block_idx] == <span class="number">0</span>); <span class="comment">// 确保尚未分配扇区地址</span></span><br><span class="line">                    file-&gt;fd_inode-&gt;i_sectors[block_idx] = all_blocks[block_idx] = block_lba;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="comment">// 间接块只写入到all_block数组中,待全部分配完成后一次性同步到硬盘</span></span><br><span class="line">                    all_blocks[block_idx] = block_lba;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">                block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">                bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line"></span><br><span class="line">                block_idx++; <span class="comment">// 下一个新扇区</span></span><br><span class="line">            &#125;</span><br><span class="line">            ide_write(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>); <span class="comment">// 同步一级间接块表到硬盘</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (file_has_used_blocks &gt; <span class="number">12</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第三种情况:新数据占据间接块*/</span></span><br><span class="line">            ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>);           <span class="comment">// 已经具备了一级间接块表</span></span><br><span class="line">            indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>]; <span class="comment">// 获取一级间接表地址</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 已使用的间接块也将被读入all_blocks,无须单独收录 */</span></span><br><span class="line">            ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>); <span class="comment">// 获取所有间接块地址</span></span><br><span class="line"></span><br><span class="line">            block_idx = file_has_used_blocks; <span class="comment">// 第一个未使用的间接块,即已经使用的间接块的下一块</span></span><br><span class="line">            <span class="keyword">while</span> (block_idx &lt; file_will_use_blocks)</span><br><span class="line">            &#123;</span><br><span class="line">                block_lba = block_bitmap_alloc(cur_part);</span><br><span class="line">                <span class="keyword">if</span> (block_lba == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    printk(<span class="string">"file_write: block_bitmap_alloc for situation 3 failed\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                all_blocks[block_idx++] = block_lba;</span><br><span class="line">                <span class="comment">/* 每分配一个块就将位图同步到硬盘 */</span></span><br><span class="line">                block_bitmap_idx = block_lba - cur_part-&gt;sb-&gt;data_start_lba;</span><br><span class="line">                bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);</span><br><span class="line">            &#125;</span><br><span class="line">            ide_write(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>); <span class="comment">// 同步一级间接块表到硬盘</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> first_write_block = <span class="literal">true</span>; <span class="comment">// 含有剩余空间的扇区标识</span></span><br><span class="line">    <span class="comment">/* 块地址已经收集到all_blocks中,下面开始写数据 */</span></span><br><span class="line">    file-&gt;fd_pos = file-&gt;fd_inode-&gt;i_size - <span class="number">1</span>; <span class="comment">// 置fd_pos为文件大小-1,下面在写数据时随时更新</span></span><br><span class="line">    <span class="keyword">while</span> (bytes_written &lt; count)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 直到写完所有数据</span></span><br><span class="line">        <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">        sec_idx = file-&gt;fd_inode-&gt;i_size / BLOCK_SIZE;</span><br><span class="line">        sec_lba = all_blocks[sec_idx];</span><br><span class="line">        sec_off_bytes = file-&gt;fd_inode-&gt;i_size % BLOCK_SIZE;</span><br><span class="line">        sec_left_bytes = BLOCK_SIZE - sec_off_bytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断此次写入硬盘的数据大小 */</span></span><br><span class="line">        chunk_size = size_left &lt; sec_left_bytes ? size_left : sec_left_bytes;</span><br><span class="line">        <span class="keyword">if</span> (first_write_block)</span><br><span class="line">        &#123;</span><br><span class="line">            ide_read(cur_part-&gt;my_disk, sec_lba, io_buf, <span class="number">1</span>);</span><br><span class="line">            first_write_block = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(io_buf + sec_off_bytes, src, chunk_size);</span><br><span class="line">        ide_write(cur_part-&gt;my_disk, sec_lba, io_buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        src += chunk_size;  <span class="comment">// 将指针推移到下个新数据</span></span><br><span class="line">        file-&gt;fd_inode-&gt;i_size += chunk_size; <span class="comment">// 更新文件大小</span></span><br><span class="line">        file-&gt;fd_pos += chunk_size;</span><br><span class="line">        bytes_written += chunk_size;</span><br><span class="line">        size_left -= chunk_size;</span><br><span class="line">    &#125;</span><br><span class="line">    inode_sync(cur_part, file-&gt;fd_inode, io_buf);</span><br><span class="line">    sys_free(all_blocks);</span><br><span class="line">    sys_free(io_buf);</span><br><span class="line">    <span class="keyword">return</span> bytes_written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将write添加到系统调用中, 根据其文件描述符来判断数据是写入磁盘还是标准输出中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int32_t</span> sys_write(<span class="keyword">int32_t</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fd == stdout_no)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> tmp_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="built_in">memcpy</span>(tmp_buf, buf, count);</span><br><span class="line">		console_put_str(tmp_buf);</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">wr_file</span> = &amp;<span class="title">file_table</span>[_<span class="title">fd</span>];</span></span><br><span class="line">	<span class="keyword">if</span> (wr_file-&gt;fd_flag &amp; O_WRONLY || wr_file-&gt;fd_flag &amp; O_RDWR)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> bytes_written = file_write(wr_file, buf, count);</span><br><span class="line">		<span class="keyword">return</span> bytes_written;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		console_put_str(<span class="string">"sys_write: not allowed to write file without flag O_RDWR or O_WRONLY\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180514/em5hc8lG8k.png?imageslim" alt=""><br>上图是向文件file1中写入数据hello，world之后，磁盘上数据的表现。</p>
<p>写入的位置是第0xa6c个扇区，将其*512转换成地址之后查看该地址的数，可以看到数据确实写入到磁盘上了。</p>
<h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从文件file中读取count个字节写入buf, 返回读出的字节数,若到文件尾则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_read(struct file *file, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *buf_dst = (<span class="keyword">uint8_t</span> *)buf;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = count, size_left = size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若要读取的字节数超过了文件可读的剩余量, 就用剩余量做为待读取的字节数 */</span></span><br><span class="line">    <span class="keyword">if</span> ((file-&gt;fd_pos + count) &gt; file-&gt;fd_inode-&gt;i_size)</span><br><span class="line">    &#123;</span><br><span class="line">        size = file-&gt;fd_inode-&gt;i_size - file-&gt;fd_pos;</span><br><span class="line">        size_left = size;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 若到文件尾则返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *io_buf = sys_malloc(BLOCK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> *all_blocks = (<span class="keyword">uint32_t</span> *)sys_malloc(BLOCK_SIZE + <span class="number">48</span>); <span class="comment">// 用来记录文件所有的块地址</span></span><br><span class="line">    <span class="keyword">if</span> (all_blocks == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> block_read_start_idx = file-&gt;fd_pos / BLOCK_SIZE;        <span class="comment">// 数据所在块的起始地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> block_read_end_idx = (file-&gt;fd_pos + size) / BLOCK_SIZE; <span class="comment">// 数据所在块的终止地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> read_blocks = block_read_start_idx - block_read_end_idx; <span class="comment">// 如增量为0,表示数据在同一扇区</span></span><br><span class="line">    ASSERT(block_read_start_idx &lt; <span class="number">139</span> &amp;&amp; block_read_end_idx &lt; <span class="number">139</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> indirect_block_table; <span class="comment">// 用来获取一级间接表地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> block_idx;           <span class="comment">// 获取待读的块地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 以下开始构建all_blocks块地址数组,专门存储用到的块地址(本程序中块大小同扇区大小) */</span></span><br><span class="line">    <span class="keyword">if</span> (read_blocks == <span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 在同一扇区内读数据,不涉及到跨扇区读取</span></span><br><span class="line">        ASSERT(block_read_end_idx == block_read_start_idx);</span><br><span class="line">        <span class="keyword">if</span> (block_read_end_idx &lt; <span class="number">12</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 待读的数据在12个直接块之内</span></span><br><span class="line">            block_idx = block_read_end_idx;</span><br><span class="line">            all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 若用到了一级间接块表,需要将表中间接块读进来</span></span><br><span class="line">            indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];</span><br><span class="line">            ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 若要读多个块</span></span><br><span class="line">        <span class="comment">/* 第一种情况: 起始块和终止块属于直接块*/</span></span><br><span class="line">        <span class="keyword">if</span> (block_read_end_idx &lt; <span class="number">12</span>)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 数据结束所在的块属于直接块</span></span><br><span class="line">            block_idx = block_read_start_idx;</span><br><span class="line">            <span class="keyword">while</span> (block_idx &lt;= block_read_end_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">                block_idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (block_read_start_idx &lt; <span class="number">12</span> &amp;&amp; block_read_end_idx &gt;= <span class="number">12</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第二种情况: 待读入的数据跨越直接块和间接块两类*/</span></span><br><span class="line">            <span class="comment">/* 先将直接块地址写入all_blocks */</span></span><br><span class="line">            block_idx = block_read_start_idx;</span><br><span class="line">            <span class="keyword">while</span> (block_idx &lt; <span class="number">12</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                all_blocks[block_idx] = file-&gt;fd_inode-&gt;i_sectors[block_idx];</span><br><span class="line">                block_idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>); <span class="comment">// 确保已经分配了一级间接块表</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 再将间接块地址写入all_blocks */</span></span><br><span class="line">            indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];</span><br><span class="line">            ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>); <span class="comment">// 将一级间接块表读进来写入到第13个块的位置之后</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第三种情况: 数据在间接块中*/</span></span><br><span class="line">            ASSERT(file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>] != <span class="number">0</span>);                            <span class="comment">// 确保已经分配了一级间接块表</span></span><br><span class="line">            indirect_block_table = file-&gt;fd_inode-&gt;i_sectors[<span class="number">12</span>];                  <span class="comment">// 获取一级间接表地址</span></span><br><span class="line">            ide_read(cur_part-&gt;my_disk, indirect_block_table, all_blocks + <span class="number">12</span>, <span class="number">1</span>); <span class="comment">// 将一级间接块表读进来写入到第13个块的位置之后</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用到的块地址已经收集到all_blocks中,下面开始读数据 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sec_idx, sec_lba, sec_off_bytes, sec_left_bytes, chunk_size;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bytes_read &lt; size)</span><br><span class="line">    &#123; <span class="comment">// 直到读完为止</span></span><br><span class="line">        sec_idx = file-&gt;fd_pos / BLOCK_SIZE;</span><br><span class="line">        sec_lba = all_blocks[sec_idx];</span><br><span class="line">        sec_off_bytes = file-&gt;fd_pos % BLOCK_SIZE;</span><br><span class="line">        sec_left_bytes = BLOCK_SIZE - sec_off_bytes;</span><br><span class="line">        chunk_size = size_left &lt; sec_left_bytes ? size_left : sec_left_bytes; <span class="comment">// 待读入的数据大小</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, BLOCK_SIZE);</span><br><span class="line">        ide_read(cur_part-&gt;my_disk, sec_lba, io_buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(buf_dst, io_buf + sec_off_bytes, chunk_size);</span><br><span class="line"></span><br><span class="line">        buf_dst += chunk_size;</span><br><span class="line">        file-&gt;fd_pos += chunk_size;</span><br><span class="line">        bytes_read += chunk_size;</span><br><span class="line">        size_left -= chunk_size;</span><br><span class="line">    &#125;</span><br><span class="line">    sys_free(all_blocks);</span><br><span class="line">    sys_free(io_buf);</span><br><span class="line">    <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="设置文件的读写偏移量"><a href="#设置文件的读写偏移量" class="headerlink" title="设置文件的读写偏移量"></a>设置文件的读写偏移量</h1><p>想象一下这种情况，在文件读取到文件尾的时候，再想去读取文件前面的部分。在目前的实现下，只能将该文件关闭之后，再重新打开，才能读取到之前的数据，这样做的话显然是不合理的。所以需要实现文件读写定位的功能。也就是lseek的实现。</p>
<p>文件的读写偏移量的设置有三个基准数，文件头，文件当前位置，文件尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件读写位置偏移量</span></span><br><span class="line"><span class="keyword">enum</span> whence</span><br><span class="line">&#123;</span><br><span class="line">    SEEK_SET = <span class="number">1</span>,</span><br><span class="line">    SEEK_CUR,</span><br><span class="line">    SEEK_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 重置用于文件读写操作的偏移指针,成功时返回新的偏移量,出错时返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_lseek(<span class="keyword">int32_t</span> fd, <span class="keyword">int32_t</span> offset, <span class="keyword">uint8_t</span> whence)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ASSERT(whence &gt; <span class="number">0</span> &amp;&amp; whence &lt; <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">pf</span> = &amp;<span class="title">file_table</span>[_<span class="title">fd</span>];</span></span><br><span class="line">	<span class="keyword">int32_t</span> new_pos = <span class="number">0</span>; <span class="comment">//新的偏移量必须位于文件大小之内</span></span><br><span class="line">	<span class="keyword">int32_t</span> file_size = (<span class="keyword">int32_t</span>)pf-&gt;fd_inode-&gt;i_size;</span><br><span class="line">	<span class="keyword">switch</span> (whence)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">/* SEEK_SET 新的读写位置是相对于文件开头再增加offset个位移量 */</span></span><br><span class="line">	<span class="keyword">case</span> SEEK_SET:</span><br><span class="line">		new_pos = offset;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SEEK_CUR 新的读写位置是相对于当前的位置增加offset个位移量 */</span></span><br><span class="line">	<span class="keyword">case</span> SEEK_CUR: <span class="comment">// offse可正可负</span></span><br><span class="line">		new_pos = (<span class="keyword">int32_t</span>)pf-&gt;fd_pos + offset;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SEEK_END 新的读写位置是相对于文件尺寸再增加offset个位移量 */</span></span><br><span class="line">	<span class="keyword">case</span> SEEK_END: <span class="comment">// 此情况下,offset应该为负值</span></span><br><span class="line">		new_pos = file_size + offset;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (new_pos &lt; <span class="number">0</span> || new_pos &gt; (file_size - <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pf-&gt;fd_pos = new_pos;</span><br><span class="line">	<span class="keyword">return</span> pf-&gt;fd_pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>删除文件主要是对资源的回收。主要有以下几部分的数据</p>
<ol>
<li>inode<ul>
<li>inode bitmap</li>
<li>inode table</li>
<li>inode中的12个直接块和一个间接块</li>
<li>存储间接块的扇区</li>
</ul>
</li>
<li>目录项<ul>
<li>该文件对应的目录项数据需要清0</li>
<li>该文件删除之后，目录中不存在目录项，需要回收目录项对应的块</li>
<li>目录inode中的size需要减去该文件目录项大小</li>
<li>将目录inode同步到硬盘</li>
</ul>
</li>
</ol>
<p>上面两部分资源的回收主要通过inode_release和delete_dir_entry这两个函数实现，这里只贴出删除文件的整体调用过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除文件(非目录),成功返回0,失败返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_unlink(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span><br><span class="line">&#123;</span><br><span class="line">	ASSERT(<span class="built_in">strlen</span>(pathname) &lt; MAX_PATH_LEN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先检查待删除的文件是否存在 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line">	<span class="keyword">int</span> inode_no = search_file(pathname, &amp;searched_record);</span><br><span class="line">	ASSERT(inode_no != <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (inode_no == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (searched_record.file_type == FT_DIRECTORY)</span><br><span class="line">	&#123;</span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 检查是否在已打开文件列表(文件表)中 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> file_idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (file_idx &lt; MAX_FILE_OPEN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (file_table[file_idx].fd_inode != <span class="literal">NULL</span> &amp;&amp; (<span class="keyword">uint32_t</span>)inode_no == file_table[file_idx].fd_inode-&gt;i_no)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		file_idx++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (file_idx &lt; MAX_FILE_OPEN)</span><br><span class="line">	&#123;</span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ASSERT(file_idx == MAX_FILE_OPEN);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 为delete_dir_entry申请缓冲区 */</span></span><br><span class="line">	<span class="keyword">void</span> *io_buf = sys_malloc(SECTOR_SIZE + SECTOR_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir</span> *<span class="title">parent_dir</span> = <span class="title">searched_record</span>.<span class="title">parent_dir</span>;</span></span><br><span class="line">	delete_dir_entry(cur_part, parent_dir, inode_no, io_buf);</span><br><span class="line">	inode_release(cur_part, inode_no);</span><br><span class="line">	sys_free(io_buf);</span><br><span class="line">	dir_close(searched_record.parent_dir);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 成功删除文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/13/filesystem3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/13/filesystem3/" class="post-title-link" itemprop="http://yoursite.com/index.html">十七. 文件系统三(文件的创建)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-13 02:12:58" itemprop="dateCreated datePublished" datetime="2018-05-13T02:12:58+08:00">2018-05-13</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>在之前介绍的概念中，inode是用来表示一个文件的，用于描述文件的存储信息，文件的权限等。但这个inode结构是操作系统为自己的文件系统准备的数据结构，仅供其内部使用，与用户的关系不大，接下来要介绍的文件描述符才是用户能够使用的结构。</p>
<p>在linux系统中，读写文件的本质是先通过文件的inode找到文件数据块的扇区地址，随后对这些扇区的数据进行读写，从而实现了文件的读写。</p>
<p>对用户进程来说，一个进程可以多次的打开同一个文件，一个文件也可以被多个进行同时打开。对于这个被多次打开的文件，每打开一次，都需要一个结构来记录该文件目前的状态。比如说A进行第一次打开1.txt的时候，读取到了第10行的位置，第二次打开1.txt的时候，读取到了20行的位置。这里的10行，20行就是打开的文件状态中的文件偏移量，它记录的是相对于文件首地址的一个偏移。即使一个文件被同时多次打开，各自操作的偏移量也互不影响。</p>
<p>也就是说，会有一个文件结构来描述文件打开后，文件读写的偏移量等信息。一个文件对应一个inode，一个文件可以被多次打开，即一个inode对应多个文件结构。</p>
<p>文件描述符的基本结构如下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180512/Ba42f1HEEc.png?imageslim" alt="文件描述符的结构"></p>
<p>接下来通过linux的open函数来了解一下文件描述符</p>
<p>open的函数原型如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, inf flags)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>成功调用该函数之后，它会返回文件pathname的文件描述符，该返回值是一个int的数值，肯定不是代表真正的文件描述符结构。它是作为进程pcb中文件描述符数组的下标索引。通过这个下标在进程pcb中找到某个数据。大家可能会认为这个数据就是真正的文件描述符了。其实不然，在进程pcb的文件描述符数组中，记录的任然不是真正的文件描述符结构，它是一个指针数组，数组中的数据指向文件表中某个文件结构，该文件结构就是真正记录被打开文件的信息所在。</p>
<p>该过程比较复杂，将其分解为下面四步</p>
<ol>
<li>调用open函数，得到一个文件描述符</li>
<li>将第一步得到的文件描述符作为进程pcb中文件描述符数组的下标，取得该下标对应的数据</li>
<li>将第二步得到的数据，相当于是一个指针，从这个指针中取到对应的文件结构</li>
<li>从该文件结构中获取到记录的文件信息</li>
</ol>
<p>通过一副图来描述一下这个过程</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180512/mcCchbaaE9.png?imageslim" alt="mark"></p>
<p>看到这里获取会有一个疑问，为什么pcb中不直接记录文件的描述符信息，而是指向了其他的区域。</p>
<p>因为记录文件信息的描述符较大，每打开一次文件，就需要记录一次。打开的文件多了之后，进程pcb的结构就会变的很大，而pcb占用的内存通常就是几个页框，linux中的pcb也只是2页框的大小，所以这些信息不会被放入pcb中。</p>
<p>看完了上面的理论之后，接下来就来具体看一下文件描述符的代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int32_t</span> fd_table[MAX_FILES_OPEN_PER_PROC];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是在进程pcb中记录的文件描述符数组，为了简化实现，这里并不是一个指针数组。里面记录的数据就是对应文件表的下标值。通过该下标去文件表中找到对应的文件结构。</p>
<p>文件描述符的初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_thread</span><span class="params">(task_struct* pthread, <span class="keyword">char</span>* name, <span class="keyword">int</span> prio)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pthread-&gt;fd_table[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    pthread-&gt;fd_table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    pthread-&gt;fd_table[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> fd_idx = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fd_idx &lt; MAX_FILES_OPEN_PER_PROC)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread-&gt;fd_table[fd_idx++] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>文件描述符的前三个文件结构将作为标准输入，标准输出，标准错误预留出来。置为-1表示该文件描述符可被分配。</p>
<p>文件描述符结构和文件表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> fd_pos; <span class="comment">// 记录当前文件操作的偏移地址,以0为起始,最大为文件大小-1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> fd_flag;<span class="comment">// 文件打开的标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">fd_inode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file_table</span>[<span class="title">MAX_FILE_OPEN</span>];</span></span><br></pre></td></tr></table></figure></p>
<p>文件描述符只存储了打开一个需要记录的最基础的信息。文件表的本质就是一个文件描述符结构的数组。</p>
<h1 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建文件,若成功则返回文件描述符,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_create(struct dir *parent_dir, <span class="keyword">char</span> *filename, <span class="keyword">uint8_t</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 后续操作的公共缓冲区 */</span></span><br><span class="line">    <span class="keyword">void</span> *io_buf = sys_malloc(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (io_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> rollback_step = <span class="number">0</span>; <span class="comment">// 用于操作失败时回滚各资源状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为新文件分配inode */</span></span><br><span class="line">    <span class="keyword">int32_t</span> inode_no = inode_bitmap_alloc(cur_part);</span><br><span class="line">    <span class="keyword">if</span> (inode_no == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此inode要从堆中申请内存,不可生成局部变量(函数退出时会释放)</span></span><br><span class="line"><span class="comment">     * 因为file_table数组中的文件描述符的inode指针要指向它.*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">new_file_inode</span> = (<span class="title">struct</span> <span class="title">inode</span> *)<span class="title">sys_malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">inode</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (new_file_inode == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rollback_step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> rollback;</span><br><span class="line">    &#125;</span><br><span class="line">    inode_init(inode_no, new_file_inode); <span class="comment">// 初始化inode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回的是file_table数组的下标 */</span></span><br><span class="line">    <span class="keyword">int</span> fd_idx = get_free_slot_in_global();</span><br><span class="line">    <span class="keyword">if</span> (fd_idx == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rollback_step = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">goto</span> rollback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file_table[fd_idx].fd_inode = new_file_inode;</span><br><span class="line">    file_table[fd_idx].fd_pos = <span class="number">0</span>;</span><br><span class="line">    file_table[fd_idx].fd_flag = flag;</span><br><span class="line">    file_table[fd_idx].fd_inode-&gt;write_deny = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> <span class="title">new_dir_entry</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;new_dir_entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct dir_entry));</span><br><span class="line"></span><br><span class="line">    create_dir_entry(filename, inode_no, FT_REGULAR, &amp;new_dir_entry);</span><br><span class="line">    <span class="comment">// 同步内存数据到硬盘</span></span><br><span class="line">                                                            </span><br><span class="line">    <span class="comment">/* a 在目录parent_dir下安装目录项new_dir_entry, 写入硬盘后返回true,否则false */</span></span><br><span class="line">    <span class="keyword">if</span> (!sync_dir_entry(parent_dir, &amp;new_dir_entry, io_buf))</span><br><span class="line">    &#123;</span><br><span class="line">        rollback_step = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> rollback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/* b 将父目录i结点的内容同步到硬盘 */</span></span><br><span class="line">    inode_sync(cur_part, parent_dir-&gt;inode, io_buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(io_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/* c 将新创建文件的i结点内容同步到硬盘 */</span></span><br><span class="line">    inode_sync(cur_part, new_file_inode, io_buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* d 将inode_bitmap位图同步到硬盘 */</span></span><br><span class="line">    bitmap_sync(cur_part, inode_no, INODE_BITMAP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* e 将创建的文件i结点添加到open_inodes链表 */</span></span><br><span class="line">    list_push(&amp;cur_part-&gt;open_inodes, &amp;new_file_inode-&gt;inode_tag);</span><br><span class="line">    new_file_inode-&gt;i_open_cnts = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sys_free(io_buf);</span><br><span class="line">    <span class="keyword">return</span> pcb_fd_install(fd_idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 </span></span><br><span class="line">rollback:</span><br><span class="line">    <span class="keyword">switch</span> (rollback_step)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">/* 失败时,将file_table中的相应位清空 */</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;file_table[fd_idx], <span class="number">0</span>, <span class="keyword">sizeof</span>(struct file));</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        sys_free(new_file_inode);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">/* 如果新文件的i结点创建失败,之前位图中分配的inode_no也要恢复 */</span></span><br><span class="line">        bitmap_set(&amp;cur_part-&gt;inode_bitmap, inode_no, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sys_free(io_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的功能是在目录parent_dir下以创建模式flag去创建普通文件，如果函数执行成功的话返回文件描述符。</p>
<p>创建的过程如下：</p>
<ol>
<li>首先为文件创建inode，该过程需要向inode的管理单元inode_bitmap申请inode号，并更新inode_bitmap</li>
<li>确定文件存储的扇区地址，这个需要在block_bitmap中申请可用的块，并更新block_bitmap</li>
<li>新增的文件必然位于某个目录中，所以该目录的目录项数量要加1，并且要将新增的目录项写入目录对应的扇区中，如果原有的扇区已满，需要申请新扇区来存储目录项</li>
<li>将上面过程中被改变的数据写入硬盘中。</li>
</ol>
<h1 id="系统调用open"><a href="#系统调用open" class="headerlink" title="系统调用open"></a>系统调用open</h1><p>open函数的功能相当强大，通过它的打开标志，不仅可以打开一个文件，同样可以创建一个文件。所以这里不打算单独实现文件的创建。</p>
<p>文件创建的标志<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> oflags</span><br><span class="line">&#123;</span><br><span class="line">    O_RDONLY,   <span class="comment">// 只读</span></span><br><span class="line">    O_WRONLY,   <span class="comment">// 只写</span></span><br><span class="line">    O_RDWR,     <span class="comment">// 读写</span></span><br><span class="line">    O_CREAT = <span class="number">4</span> <span class="comment">// 创建</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开或创建文件成功后,返回文件描述符,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_open(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uint8_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pathname[<span class="built_in">strlen</span>(pathname) - <span class="number">1</span>] == <span class="string">'/'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ASSERT(flags &lt;= <span class="number">7</span>);</span><br><span class="line">	<span class="keyword">int32_t</span> fd = <span class="number">-1</span>; <span class="comment">// 默认为找不到</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path_search_record</span> <span class="title">searched_record</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;searched_record, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct path_search_record));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 记录目录深度.帮助判断中间某个目录不存在的情况 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> pathname_depth = path_depth_cnt((<span class="keyword">char</span> *)pathname);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先检查文件是否存在 */</span></span><br><span class="line">	<span class="keyword">int</span> inode_no = search_file(pathname, &amp;searched_record);</span><br><span class="line">	<span class="keyword">bool</span> found = inode_no != <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (searched_record.file_type == FT_DIRECTORY)</span><br><span class="line">	&#123;</span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> path_searched_depth = path_depth_cnt(searched_record.searched_path);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先判断是否把pathname的各层目录都访问到了,即是否在某个中间目录就失败了 */</span></span><br><span class="line">	<span class="keyword">if</span> (pathname_depth != path_searched_depth)</span><br><span class="line">	&#123; </span><br><span class="line">        <span class="comment">// 说明并没有访问到全部的路径,某个中间目录是不存在的</span></span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 若是在最后一个路径上没找到,并且并不是要创建文件,直接返回-1 */</span></span><br><span class="line">	<span class="keyword">if</span> (!found &amp;&amp; !(flags &amp; O_CREAT))</span><br><span class="line">	&#123;</span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (found &amp;&amp; flags &amp; O_CREAT)</span><br><span class="line">	&#123; </span><br><span class="line">        <span class="comment">// 若要创建的文件已存在</span></span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (flags &amp; O_CREAT)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> O_CREAT:</span><br><span class="line">		printk(<span class="string">"creating file\n"</span>);</span><br><span class="line">		fd = file_create(searched_record.parent_dir, (<span class="built_in">strrchr</span>(pathname, <span class="string">'/'</span>) + <span class="number">1</span>), flags);</span><br><span class="line">		dir_close(searched_record.parent_dir);</span><br><span class="line">	<span class="comment">// 其余为打开文件</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fd = file_open(inode_no, flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 此fd是指任务pcb-&gt;fd_table数组中的元素下标,</span></span><br><span class="line"><span class="comment">      * 并不是指全局file_table中的下标 */</span></span><br><span class="line">	<span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件的创建过程中主要是对路径的解析，这里暂时还不支持相对路径，这里必须使用绝对路径来进行文件的创建。在路径没有问题且该文件不存在的前提下，就会调用之前的file_create函数创建文件。</p>
<p>接下来在模拟器上运行一下，看看创建文件的具体表现</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180513/3D3gdG5cdL.png?imageslim" alt="主分区信息"></p>
<p>上面的图片是主分区格式化时数据的区域，我用红框标记了数据的起始扇区位置，该位置应该与根目录所在的位置相同。</p>
<p>将数据起始扇区的位置*512后得到数据区的地址，在该地址处查看512字节也就是一扇区的数据内容，结果如下</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180513/CedA9m8Df4.png?imageslim" alt="mark"></p>
<p>在根目录下，目前有三个目录项 <strong>.  ..和创建的文件file1</strong>，每个目录项包含三部分的内容，16字节的filename，4字节的inode号，4字节的文件类型。共24字节的内容</p>
<p>用红框标记的是 <strong>.</strong> 这个目录项的数据，2E代表它的文件名，它表示当前目录也就是根目录，其inode号为0，文件类型为2，代表一个目录</p>
<p>黄线标记的是 <strong>..</strong> 它代表上一层目录，因为目前在根目录下，所以它还是表示根目录。</p>
<p>绿线标记的就是刚刚创建的文件，文件名为file1。inode号为1，文件类型是1，表示这是一个普通文件。</p>
<p>上面通过open函数创建了一个文件，接下来就完成其打开文件的功能。打开文件的功能主要是通过下面这个函数实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开编号为inode_no的inode对应的文件,若成功则返回文件描述符,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_open(<span class="keyword">uint32_t</span> inode_no, <span class="keyword">uint8_t</span> flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd_idx = get_free_slot_in_global();</span><br><span class="line">    <span class="keyword">if</span> (fd_idx == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"exceed max open files\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    file_table[fd_idx].fd_inode = inode_open(cur_part, inode_no);</span><br><span class="line">    file_table[fd_idx].fd_pos = <span class="number">0</span>; <span class="comment">// 每次打开文件,要将fd_pos还原为0,即让文件内的指针指向开头</span></span><br><span class="line">    file_table[fd_idx].fd_flag = flag;</span><br><span class="line">    <span class="keyword">bool</span> *write_deny = &amp;file_table[fd_idx].fd_inode-&gt;write_deny;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; O_WRONLY || flag &amp; O_RDWR)</span><br><span class="line">    &#123;   <span class="comment">// 只要是关于写文件,判断是否有其它进程正写此文件</span></span><br><span class="line">        <span class="comment">// 若是读文件,不考虑write_deny</span></span><br><span class="line">        <span class="comment">/* 以下进入临界区前先关中断 */</span></span><br><span class="line">        <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">        <span class="keyword">if</span> (!(*write_deny))</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 若当前没有其它进程写该文件,将其占用.</span></span><br><span class="line">            *write_deny = <span class="literal">true</span>;          <span class="comment">// 置为true,避免多个进程同时写此文件</span></span><br><span class="line">            intr_set_status(old_status); <span class="comment">// 恢复中断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 直接失败返回</span></span><br><span class="line">            intr_set_status(old_status);</span><br><span class="line">            printk(<span class="string">"file can`t be write now, try again later\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 若是读文件或创建文件,不用理会write_deny,保持默认</span></span><br><span class="line">    <span class="keyword">return</span> pcb_fd_install(fd_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，打开一个文件的本质就是在进程的pcb中安装了该文件对应的文件描述符。</p>
<p>open函数的功能实现完了之后就可以将其添加到系统调用中，以供用户的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    syscall_table[SYS_OPEN] = sys_open;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall2(SYS_OPEN, pathname, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="系统调用close"><a href="#系统调用close" class="headerlink" title="系统调用close"></a>系统调用close</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 关闭文件描述符fd指向的文件,成功返回0,否则返回-1 */</span></span><br><span class="line"><span class="keyword">int32_t</span> sys_close(<span class="keyword">int32_t</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int32_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> _fd = fd_local2global(fd);</span><br><span class="line">		ret = file_close(&amp;file_table[_fd]);</span><br><span class="line">		running_thread()-&gt;fd_table[fd] = <span class="number">-1</span>; <span class="comment">// 使该文件描述符位可用</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将文件描述符转化为文件表的下标 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint32_t <span class="title">fd_local2global</span><span class="params">(<span class="keyword">uint32_t</span> local_fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	task_struct *cur = running_thread();</span><br><span class="line">	<span class="keyword">int32_t</span> global_fd = cur-&gt;fd_table[local_fd];</span><br><span class="line">	ASSERT(global_fd &gt;= <span class="number">0</span> &amp;&amp; global_fd &lt; MAX_FILE_OPEN);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">uint32_t</span>)global_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭文件 */</span></span><br><span class="line"><span class="keyword">int32_t</span> file_close(struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    file-&gt;fd_inode-&gt;write_deny = <span class="literal">false</span>;</span><br><span class="line">    inode_close(file-&gt;fd_inode);</span><br><span class="line">    file-&gt;fd_inode = <span class="literal">NULL</span>; <span class="comment">// 使文件结构可用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭inode或减少inode的打开数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inode_close</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 若没有进程再打开此文件,将此inode去掉并释放空间 */</span></span><br><span class="line">    <span class="keyword">enum</span> intr_status old_status = intr_disable();</span><br><span class="line">    <span class="keyword">if</span> (--inode-&gt;i_open_cnts == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        list_remove(&amp;inode-&gt;inode_tag); <span class="comment">// 将I结点从part-&gt;open_inodes中去掉</span></span><br><span class="line">                                        </span><br><span class="line">        <span class="comment">/* inode_open时为实现inode被所有进程共享,</span></span><br><span class="line"><span class="comment">         * 已经在sys_malloc为inode分配了内核空间,</span></span><br><span class="line"><span class="comment">         * 释放inode时也要确保释放的是内核内存池 */</span></span><br><span class="line">        task_struct *cur = running_thread();</span><br><span class="line">        <span class="keyword">uint32_t</span> *cur_pagedir_bak = cur-&gt;pgdir;</span><br><span class="line">        cur-&gt;pgdir = <span class="literal">NULL</span>;</span><br><span class="line">        sys_free(inode);</span><br><span class="line">        cur-&gt;pgdir = cur_pagedir_bak;</span><br><span class="line">    &#125;</span><br><span class="line">    intr_set_status(old_status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化系统调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    syscall_table[SYS_CLOSE] = sys_close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _syscall1(SYS_CLOSE, fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/12/filesystem2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/12/filesystem2/" class="post-title-link" itemprop="http://yoursite.com/index.html">十六. 文件系统二(创建文件系统)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-12 23:39:16" itemprop="dateCreated datePublished" datetime="2018-05-12T23:39:16+08:00">2018-05-12</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在前面一节中介绍了文件系统的基本概念，接下来就要准备开始实现我们的文件系统，下面是为管理文件系统提供的几个基础数据结构。</p>
<p>超级块的结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 超级块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;         <span class="comment">// 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sec_cnt;       <span class="comment">// 本分区总共的扇区数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_cnt;     <span class="comment">// 本分区中inode数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> part_lba_base; <span class="comment">// 本分区的起始lba地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> block_bitmap_lba;   <span class="comment">// 块位图本身起始扇区地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> block_bitmap_sects; <span class="comment">// 扇区位图本身占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_bitmap_lba;   <span class="comment">// inode位图起始扇区lba地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_bitmap_sects; <span class="comment">// inode位图占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_table_lba;   <span class="comment">// inode表起始扇区lba地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> inode_table_sects; <span class="comment">// inode表占用的扇区数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> data_start_lba; <span class="comment">// 数据区开始的第一个扇区号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> root_inode_no;  <span class="comment">// 根目录所在的I结点号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dir_entry_size; <span class="comment">// 目录项大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> pad[<span class="number">460</span>]; <span class="comment">// 加上460字节,凑够512字节1扇区大小</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></p>
<p>inode的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_no;  <span class="comment">// inode编号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_size; <span class="comment">// 此inode为文件时，表示文件的大小。为目录时，表示该目录下所有目录项大小之和 </span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_open_cnts; <span class="comment">// 文件被打开的次数</span></span><br><span class="line">    <span class="keyword">bool</span> write_deny;  <span class="comment">// 写文件的标识，防止多个进行同时对一个文件写</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i_sectors[<span class="number">13</span>]; <span class="comment">// 一个文件只支持13个块，12个直接块，1个间接块。在这个文件系统中，块的大小直接等于1扇区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elem</span> <span class="title">inode_tag</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目录和目录项的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> file_types </span><br><span class="line">&#123;</span><br><span class="line">    FT_UNKNOWN,   </span><br><span class="line">    FT_REGULAR,   </span><br><span class="line">    FT_DIRECTORY  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dir_pos;</span><br><span class="line">    <span class="keyword">uint8_t</span> dir_buf[<span class="number">512</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> filename[MAX_FILE_NAME_LEN]; <span class="comment">// 普通文件或目录名称</span></span><br><span class="line">    <span class="keyword">uint32_t</span> i_no;</span><br><span class="line">    <span class="keyword">enum</span> file_types f_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了这些结构之后，第一步要做的工作就是对硬盘上的分区进行格式化</p>
<p>创建的步骤如下</p>
<ol>
<li>根据分区大小，计算分区文件系统各元信息需要的扇区数及位置</li>
<li>在内存中创建超级块，将上面的元信息写入超级块</li>
<li>将超级块写入磁盘</li>
<li>将元信息写入磁盘上各自的位置</li>
<li>将根目录写入磁盘</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">partition_format</span><span class="params">(struct partition *part)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> boot_sector_sects = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> super_block_sects = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART, BITS_PER_SECTOR); <span class="comment">// inode位图占用的扇区数.最多支持4096个文件</span></span><br><span class="line">	<span class="keyword">uint32_t</span> inode_table_sects = DIV_ROUND_UP(((<span class="keyword">sizeof</span>(struct inode) * MAX_FILES_PER_PART)), SECTOR_SIZE);</span><br><span class="line">	<span class="keyword">uint32_t</span> used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;</span><br><span class="line">	<span class="keyword">uint32_t</span> free_sects = part-&gt;sec_cnt - used_sects;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/************** 简单处理块位图占据的扇区数 ***************/</span></span><br><span class="line">	<span class="keyword">uint32_t</span> block_bitmap_sects;</span><br><span class="line">	block_bitmap_sects = DIV_ROUND_UP(free_sects, BITS_PER_SECTOR);</span><br><span class="line">	<span class="comment">/* block_bitmap_bit_len是位图中位的长度,也是可用块的数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> block_bitmap_bit_len = free_sects - block_bitmap_sects;</span><br><span class="line">	block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len, BITS_PER_SECTOR);</span><br><span class="line">	<span class="comment">/*********************************************************/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 超级块初始化 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">sb</span>;</span></span><br><span class="line">	sb.magic = <span class="number">0x19971234</span>;</span><br><span class="line">	sb.sec_cnt = part-&gt;sec_cnt;</span><br><span class="line">	sb.inode_cnt = MAX_FILES_PER_PART;</span><br><span class="line">	sb.part_lba_base = part-&gt;start_lba;</span><br><span class="line"></span><br><span class="line">	sb.block_bitmap_lba = sb.part_lba_base + <span class="number">2</span>; <span class="comment">// 第0块是引导块,第1块是超级块</span></span><br><span class="line">	sb.block_bitmap_sects = block_bitmap_sects;</span><br><span class="line"></span><br><span class="line">	sb.inode_bitmap_lba = sb.block_bitmap_lba + sb.block_bitmap_sects;</span><br><span class="line">	sb.inode_bitmap_sects = inode_bitmap_sects;</span><br><span class="line"></span><br><span class="line">	sb.inode_table_lba = sb.inode_bitmap_lba + sb.inode_bitmap_sects;</span><br><span class="line">	sb.inode_table_sects = inode_table_sects;</span><br><span class="line"></span><br><span class="line">	sb.data_start_lba = sb.inode_table_lba + sb.inode_table_sects;</span><br><span class="line">	sb.root_inode_no = <span class="number">0</span>;</span><br><span class="line">	sb.dir_entry_size = <span class="keyword">sizeof</span>(struct dir_entry);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">disk</span> *<span class="title">hd</span> = <span class="title">part</span>-&gt;<span class="title">my_disk</span>;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//1 将超级块写入本分区的1扇区</span></span><br><span class="line">	ide_write(hd, part-&gt;start_lba + <span class="number">1</span>, &amp;sb, <span class="number">1</span>);</span><br><span class="line">	printk(<span class="string">"   super_block_lba:0x%x\n"</span>, part-&gt;start_lba + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 找出数据量最大的元信息,用其尺寸做存储缓冲区*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span> buf_size = (sb.block_bitmap_sects &gt;= sb.inode_bitmap_sects ? sb.block_bitmap_sects : sb.inode_bitmap_sects);</span><br><span class="line">	buf_size = (buf_size &gt;= sb.inode_table_sects ? buf_size : sb.inode_table_sects) * SECTOR_SIZE;</span><br><span class="line">	<span class="keyword">uint8_t</span> *buf = (<span class="keyword">uint8_t</span> *)sys_malloc(buf_size); <span class="comment">// 申请的内存由内存管理系统清0后返回</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2 将块位图初始化并写入sb.block_bitmap_lba </span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 初始化块位图block_bitmap */</span></span><br><span class="line">	buf[<span class="number">0</span>] |= <span class="number">0x01</span>; <span class="comment">// 第0个块预留给根目录,位图中先占位</span></span><br><span class="line">	<span class="keyword">uint32_t</span> block_bitmap_last_byte = block_bitmap_bit_len / <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">uint8_t</span> block_bitmap_last_bit = block_bitmap_bit_len % <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE); <span class="comment">// last_size是位图所在最后一个扇区中，不足一扇区的其余部分</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1 先将位图最后一字节到其所在的扇区的结束全置为1,即超出实际块数的部分直接置为已占用*/</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;buf[block_bitmap_last_byte], <span class="number">0xff</span>, last_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2 再将上一步中覆盖的最后一字节内的有效位重新置0 */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> bit_idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (bit_idx &lt;= block_bitmap_last_bit)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[block_bitmap_last_byte] &amp;= ~(<span class="number">1</span> &lt;&lt; bit_idx++);</span><br><span class="line">	&#125;</span><br><span class="line">	ide_write(hd, sb.block_bitmap_lba, buf, sb.block_bitmap_sects);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//3 将inode位图初始化并写入sb.inode_bitmap_lba </span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 先清空缓冲区*/</span></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);</span><br><span class="line">	buf[<span class="number">0</span>] |= <span class="number">0x1</span>; <span class="comment">// 第0个inode分给了根目录</span></span><br><span class="line">	<span class="comment">/* 由于inode_table中共4096个inode,位图inode_bitmap正好占用1扇区,</span></span><br><span class="line"><span class="comment">      * 即inode_bitmap_sects等于1, 所以位图中的位全都代表inode_table中的inode,</span></span><br><span class="line"><span class="comment">      * 无须再像block_bitmap那样单独处理最后一扇区的剩余部分,</span></span><br><span class="line"><span class="comment">      * inode_bitmap所在的扇区中没有多余的无效位 */</span></span><br><span class="line">	ide_write(hd, sb.inode_bitmap_lba, buf, sb.inode_bitmap_sects);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 4 将inode数组初始化并写入sb.inode_table_lba </span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 准备写inode_table中的第0项,即根目录所在的inode */</span></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size); <span class="comment">// 先清空缓冲区buf</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">i</span> = (<span class="title">struct</span> <span class="title">inode</span> *)<span class="title">buf</span>;</span></span><br><span class="line">	i-&gt;i_size = sb.dir_entry_size * <span class="number">2</span>;   <span class="comment">// .和..</span></span><br><span class="line">	i-&gt;i_no = <span class="number">0</span>;						 <span class="comment">// 根目录占inode数组中第0个inode</span></span><br><span class="line">	i-&gt;i_sectors[<span class="number">0</span>] = sb.data_start_lba; <span class="comment">// 由于上面的memset,i_sectors数组的其它元素都初始化为0</span></span><br><span class="line">	ide_write(hd, sb.inode_table_lba, buf, sb.inode_table_sects);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//5 将根目录初始化并写入sb.data_start_lba</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 写入根目录的两个目录项.和.. */</span></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, buf_size);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> *<span class="title">p_de</span> = (<span class="title">struct</span> <span class="title">dir_entry</span> *)<span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化当前目录"." */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">"."</span>, <span class="number">1</span>);</span><br><span class="line">	p_de-&gt;i_no = <span class="number">0</span>;</span><br><span class="line">	p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line">	p_de++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化当前目录父目录".." */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(p_de-&gt;filename, <span class="string">".."</span>, <span class="number">2</span>);</span><br><span class="line">	p_de-&gt;i_no = <span class="number">0</span>; <span class="comment">// 根目录的父目录依然是根目录自己</span></span><br><span class="line">	p_de-&gt;f_type = FT_DIRECTORY;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sb.data_start_lba已经分配给了根目录,里面是根目录的目录项 */</span></span><br><span class="line">	ide_write(hd, sb.data_start_lba, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">"   root_dir_lba:0x%x\n"</span>, sb.data_start_lba);</span><br><span class="line">	printk(<span class="string">"%s format done\n"</span>, part-&gt;name);</span><br><span class="line">	sys_free(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的主要功能实际上就是按照我们对文件系统的规划，将硬盘每一个分区中的信息进行了初始化。这些数据就是用来记录硬盘分区的基本信息，将下图中的信息确定并保留下来。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/HhF1eH9mmh.png?imageslim" alt="mark"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在磁盘上搜索文件系统,若没有则格式化分区创建文件系统 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filesys_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint8_t</span> channel_no = <span class="number">0</span>, dev_no, part_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sb_buf用来存储从硬盘上读入的超级块 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb_buf</span> = (<span class="title">struct</span> <span class="title">super_block</span> *)<span class="title">sys_malloc</span>(<span class="title">SECTOR_SIZE</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sb_buf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PANIC(<span class="string">"alloc memory failed!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">"searching filesystem......\n"</span>);</span><br><span class="line">	<span class="keyword">while</span> (channel_no &lt; channel_cnt)</span><br><span class="line">	&#123;</span><br><span class="line">		dev_no = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (dev_no &lt; <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dev_no == <span class="number">0</span>)</span><br><span class="line">			&#123; </span><br><span class="line">                <span class="comment">// 跨过第一个裸盘，在模拟器中的第二块硬盘才是存储文件系统的硬盘</span></span><br><span class="line">				dev_no++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">disk</span> *<span class="title">hd</span> = &amp;<span class="title">channels</span>[<span class="title">channel_no</span>].<span class="title">devices</span>[<span class="title">dev_no</span>];</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">part</span> = <span class="title">hd</span>-&gt;<span class="title">prim_parts</span>;</span></span><br><span class="line">			<span class="keyword">while</span> (part_idx &lt; <span class="number">12</span>)</span><br><span class="line">			&#123;</span><br><span class="line">                 <span class="comment">// 4个主分区+8个逻辑</span></span><br><span class="line">				<span class="keyword">if</span> (part_idx == <span class="number">4</span>)</span><br><span class="line">				&#123; <span class="comment">// 开始处理逻辑分区</span></span><br><span class="line">					part = hd-&gt;logic_parts;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (part-&gt;sec_cnt != <span class="number">0</span>)</span><br><span class="line">				&#123; </span><br><span class="line">                    <span class="comment">// 如果分区存在</span></span><br><span class="line">					<span class="built_in">memset</span>(sb_buf, <span class="number">0</span>, SECTOR_SIZE);</span><br><span class="line"></span><br><span class="line">					<span class="comment">/* 读出分区的超级块,根据魔数是否正确来判断是否存在文件系统 */</span></span><br><span class="line">					ide_read(hd, part-&gt;start_lba + <span class="number">1</span>, sb_buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (sb_buf-&gt;magic == <span class="number">0x19971234</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						printk(<span class="string">"%s has filesystem\n"</span>, part-&gt;name);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123; </span><br><span class="line">                        <span class="comment">// 其它文件系统不支持,一律按无文件系统处理</span></span><br><span class="line">						printk(<span class="string">"formatting %s`s partition %s......\n"</span>, hd-&gt;name, part-&gt;name);</span><br><span class="line">						partition_format(part);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				part_idx++;</span><br><span class="line">				part++; <span class="comment">// 下一分区</span></span><br><span class="line">			&#125;</span><br><span class="line">			dev_no++; <span class="comment">// 下一磁盘</span></span><br><span class="line">		&#125;</span><br><span class="line">		channel_no++; <span class="comment">// 下一通道</span></span><br><span class="line">	&#125;</span><br><span class="line">	sys_free(sb_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180512/CKCDFCB5J5.png?imageslim" alt="mark"></p>
<p>在成功创建出文件系统之后，输入了该文件系统中四个主分区的起始扇区地址和该分区的扇区总数。</p>
<p>有了文件系统之后，我们就能对磁盘上的数据进行有效的管理，接下来就要实现文件的创建与删除操作。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/10/cdecl/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/10/cdecl/" class="post-title-link" itemprop="http://yoursite.com/index.html">六. 函数调用约定与系统调用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-10 16:36:26" itemprop="dateCreated datePublished" datetime="2018-05-10T16:36:26+08:00">2018-05-10</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h1><p>调用约定从字面上理解，他是调用函数的一套约定。主要体现在一下三个方面</p>
<ol>
<li>参数的传递方式，参数是存放在寄存器中还是栈中</li>
<li>参数的传递顺序，是从左到右传递还是从右到左传递</li>
<li>是调用者保存寄存器环境还是被调用者保存</li>
</ol>
<p>在进行函数调用的时候，函数所需要传递的参数往往是不固定的。在计算机中并没有专门储存参数的硬件，因为参数的不确定性，该硬件的容量并不好确定，而且如果传递参数的过程中，函数被换下CPU，新的进程进行参数调用时还会覆盖之前的参数。</p>
<p>考虑到这些方方面面，最后决定在栈中存储函数的参数。其优点如下</p>
<ol>
<li>每个进程都有自己的栈</li>
<li>参数的内存地址不用花精力去维护，已经有栈机制自动帮我们维护</li>
</ol>
<p>参数储存的问题解决了，那么接下来讨论另外两个问题</p>
<ol>
<li>参数存储在栈中，那么谁来负责回收参数所占的栈空间，是调用者？还是被调用者</li>
<li>当参数很多的时候后，主调函数将参数以什么样的顺序传递</li>
</ol>
<p>上面两个问题就涉及到具体的调用规定了</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180418/4h47HG63mF.png?imageslim" alt="mark"></p>
<p>在这些调用约定中，我们最常用是以下几种约定</p>
<ol>
<li>cdecl</li>
<li>stdcall</li>
<li>thiscall</li>
</ol>
<p>cdecl 是c默认的调用约定。<br>stdcall 他是微软Win32 API的一准标准，我们常用的回调函数就是通过这种调用方式<br>thiscall 是c++中非静态类成员函数的默认调用约定</p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>首先简单的介绍一下系统调用是什么，等后面需要真正实现系统调用的时候再来详细的说明</p>
<p>系统调用是linux内核提供的一套子程序，主要是为了实现在用户态不能实现的功能，比如说最常见的读写硬盘文件，这些读写的方法肯定不能由用户程序来编写，而且用户程序也没有权限去直接操控硬件，这就需要操作系统的支持，需要操作系统提供读写硬盘的接口</p>
<p>系统调用的入口只有一个，即第0x80号中断，通过eax指定子功能号。在linux中，系统调用是定义在 <strong>/usr/include/asm-generic-unistd.h</strong> 中</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180418/77l9Hfm3c1.png?imageslim" alt="mark"></p>
<p>调用系统调用有两种方式</p>
<ol>
<li>通过操作系统提供的库函数进行系统调用</li>
<li>直接通过0x80中断与系统通信</li>
</ol>
<p>我们想要自制kernel的话第一条路肯定走不通，因为没有库函数供我们调用，库函数都是我们自己写的。</p>
<p>通过中断的方式进行系统调用需要了解一下系统调用输入参数的传递方式</p>
<p>当输入的参数小于等于5个时，linux用寄存器传递参数。当输入的参数大于5个时，把参数按照顺序放入连续的内存中，并把这块内存的首地址放入ebx中</p>
<p>通过寄存器传递参数时</p>
<p>eax存放子功能号</p>
<p>ebx存放第一个参数</p>
<p>ecx存放第二个参数</p>
<p>edx存放第三个参数</p>
<p>esi存放第四个参数</p>
<p>edi存放地五个参数</p>
<p>下面是一个简单的syscall_wirte的简单实现</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">section</span> .data</span><br><span class="line"><span class="symbol">str_c_lib:</span> <span class="built_in">db</span> <span class="string">"c library says: hello world!"</span>, <span class="number">0xa</span></span><br><span class="line">str_c_lib_len <span class="built_in">equ</span> $-str_c_lib</span><br><span class="line"></span><br><span class="line"><span class="symbol">str_syscall:</span> <span class="built_in">db</span> <span class="string">"syscall says: hello world!"</span>, <span class="number">0xa</span></span><br><span class="line">str_syscall_len <span class="built_in">equ</span> $-str_syscall</span><br><span class="line"></span><br><span class="line"><span class="meta">section</span> .text</span><br><span class="line"><span class="meta">global</span> _start</span><br><span class="line"><span class="symbol">_start:</span></span><br><span class="line"> <span class="comment">;  方式 1 ：模拟 c 语言中系统调用库函数 write ;</span></span><br><span class="line">    <span class="keyword">push</span> str_c_lib_len </span><br><span class="line">    <span class="keyword">push</span> str_c_lib</span><br><span class="line">    <span class="keyword">push</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">call</span> simu_write</span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">esp</span>, <span class="number">12</span></span><br><span class="line"><span class="comment">;  方式 2 ：跨过库函数，直接进行系统调用</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">4</span>  <span class="comment">;第4号子功能是 write 系统调用（不是 c 库函数 write)  </span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, str_syscall</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, str_syscall_len</span><br><span class="line">    <span class="keyword">int</span> Ox80  <span class="comment">;发起中断，通知 Linux 完成请求的功能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;   退出程序</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span>  <span class="comment">;第1号子功能是exit</span></span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">sumu_write:</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ebx</span>, [<span class="built_in">ebp</span> + <span class="number">8</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ecx</span>, [<span class="built_in">ebp</span> + <span class="number">12</span>]</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">edx</span>, [<span class="built_in">ebp</span> + <span class="number">16</span>]</span><br><span class="line">    <span class="keyword">int</span> <span class="number">0x80</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/08/filesystem/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="melody">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="melodyのblog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/05/08/filesystem/" class="post-title-link" itemprop="http://yoursite.com/index.html">十五. 文件系统一(文件系统的基本概念)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-08 23:54:44" itemprop="dateCreated datePublished" datetime="2018-05-08T23:54:44+08:00">2018-05-08</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/kernel/" itemprop="url" rel="index"><span itemprop="name">kernel</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘的基础概念"><a href="#磁盘的基础概念" class="headerlink" title="磁盘的基础概念"></a>磁盘的基础概念</h1><p>扇区：它是磁盘读写的基本单位。在我们个人的pc上，他的大小通常为512byte</p>
<p>块：在windows中，称为簇。一个块由多个扇区组成，磁盘在进行读写数据的时候，不可能有一扇区的数据就读或写一次，而是等数据累计到一定量后，在统一进行读写，而这个数据量就叫块。在对磁盘进行格式化分区的时候可以选择块的大小，默认的是4kb。因为每次进行读写的数据量都是一块为单位，所以在磁盘上数据的存储也是以块为大小。最显著的例子是，我们在windows上创建一个文件，它的实际大小都为块大小的整数倍。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/cDcm8biCHB.png?imageslim" alt="mark"></p>
<p>总结的来说，扇区是由磁盘的设计决定的，它决定了磁盘一次读写所能取得的数据量。块这个概念是由程序员设计出来的，它就类似于缓冲区的概念，在累计到一定的数据量之后进行一次性读写。扇区和块的概念有点类似于bit和byte。bit计算机系统中最小的数据单元，但通常我们都不会直接对bit进行操作，所以通常会将byte作为计算机中最小的数据单位。所以在后面中，没有特殊的说明，文件系统的最小单元默认就是块。</p>
<h1 id="链式文件系统"><a href="#链式文件系统" class="headerlink" title="链式文件系统"></a>链式文件系统</h1><p>磁盘中，数据的存储都是以块为大小，这里的块大小都以4KB来举例，对于大于4KB的文件，就会对其进行分块存储。如10KB的文件，就会将其分为3块。不同对文件系统对这3块文件的存储方式都会不一样，这里用FAT的链式文件系统举例。</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/DG2f0F722k.png?imageslim" alt="链式文件系统的数据存储"></p>
<p>这幅图很形象的说明了链式文件系统的特点，文件的块是分布在各个零散的空间中，这样对空间的利用率有极大的提升。但是想要放到到某个指定的块就必须从第一个块开始向下寻找，访问的速度较慢。</p>
<p>windows的上古时期使用的就是这种文件系统。</p>
<h1 id="索引式文件系统"><a href="#索引式文件系统" class="headerlink" title="索引式文件系统"></a>索引式文件系统</h1><p>在UNIX时代，就已经实现了索引式的文件系统。它的原理是为一个文件的所有块建立一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，第n个数组元素指向文件中的第n个块，这样访问任意一个块的时候，只需要从索引表中获得块地址就可以了。而且文件中的块依然可以分散到不连续的零散空间中。其结构如下图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/FJC3Cdkm6b.png?imageslim" alt="索引式文件系统"></p>
<p>索引表的索引结构称为inode，用来索引，跟踪一个文件的所有块。inode是文件索引结构组织形式的具体体现，一个文件就必须对应一个inode。</p>
<p>索引表本身要占用存储空间，如果文件很大时，块就比较多，索引表就会很大。UNIX为了解决这个问题，采用间接索引表来处理。</p>
<p>具体的做法是：每个索引表中有15个索引项，前12个索引项对应文件的12个块，他们是文件的直接块。若文件大于12块，就再建立一个新的块索引表，新索引表称为一级间接索引表，表中可容纳256个块地址，这个索引表也会占用一个物理块，老的索引表的第13个索引项就会指向这个索引表所在的物理块。通过一级间接索引表，文件最大可达到 12 + 256 = 268块。</p>
<p>如果文件超过268块的大小，就再建立二级间接索引表，此表中各个表项存储的是一级间接索引表，老的索引表中的第14个索引项就会指向这个二级间接索引表，此时的文件最大可到 268 + 256 * 256。如果块大小为4KB的话，大约可以表示257MB的文件。</p>
<p>如果任然不够用的话，就会建立三级间接索引表，让老索引表的第15个索引项指向这个三级间接索引表。此时能表示的文件大小大约是64GB。</p>
<p>inode的结构如图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/ag54Fh98Ed.png?imageslim" alt="inode结构"></p>
<h1 id="目录与目录项"><a href="#目录与目录项" class="headerlink" title="目录与目录项"></a>目录与目录项</h1><p>在磁盘上的文件系统中，没有用来专门表示目录的结构，磁盘上有的只是inode，inode是用于描述一个文件实体的数据块，至于数据块中记录的是什么，并不是有inode决定的。</p>
<p>既然磁盘上只有这一个结构，那么目录同样也是通过inode来表示的。inode是用来表示文件的，那么也可以说，目录也是文件的一种。</p>
<p>inode既可以表示普通文件，也可以表示目录，那么肯定要有一种方法来区分它到底是普通文件还是目录。这个就是通过inode中的数据块来区分的。</p>
<p>普通文件的inode的数据块是指向普通文件自己的数据的。</p>
<p>目录的inode的数据块是指向位于该目录下的目录项的。</p>
<p>不管是普通文件还是目录文件，它总会存在于某个目录中，所有的文件都位于根目录 <strong>/</strong> 之下。我们平时使用的 <strong>ls</strong> 命令就是目录项的外在表现</p>
<p>在目录项中会记录该文件的类型，是属于普通文件，还是属于一个目录。</p>
<p>下面是目录项的一个示意图</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/5c6HFLB741.png?imageslim" alt="mark"></p>
<p>通过目录项便可以通过文件名找到文件对应的数据了。</p>
<p>首先通过文件名找到位于该目录项中对应的inode编号</p>
<p>然后通过通过这个inode编号在inode数组中找到该文件对应的inode</p>
<p>最后通过这个文件对应的inode找到该文件对应的数据。</p>
<h1 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h1><p>在文件系统中，一个文件用一个inode表示，所有的inode组成了inode数组，这个inode数组存储在哪里，如何对其进行管理。文件系统中，哪些块被使用了，哪些块是空闲的，这些信息都需要记录，对这些数据进行统一管理和记录的数据结构叫做超级块。它的结构如图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/FdLBD0fH5k.png?imageslim" alt="超级块"></p>
<p>超级块中的大部分数据都很好理解，里面的魔数是用来确定文件系统的标志的，用它来区别其他的文件系统。虽然对于我们这个简单的内核来说没什么意义，但是模仿就模仿到底，加上这个结构也不是很复杂。</p>
<p>超级块是文件系统基本信息的配置文件，它是在为分区创建文件系统时创建的，所有关于文件系统的基本信息都记录在超级块中，因此超级块的位置和大小是固定的，它被固定存储在各个分区的第2个扇区中，通常占用1扇区的大小。</p>
<p>这个kernel的文件系统模仿ext2文件系统实现，其文件系统的布局如图所示</p>
<p><img src="http://p5inpf0t8.bkt.clouddn.com/pic/180508/HhF1eH9mmh.png?imageslim" alt="文件系统"></p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="melody">
            
              <p class="site-author-name" itemprop="name">melody</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">melody</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
